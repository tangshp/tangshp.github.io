<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>04-C++-组合与继承</title>
      <link href="/2022/08/05/CPP/04-C-%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF/"/>
      <url>/2022/08/05/CPP/04-C-%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<p><strong>类和类之间的关系</strong>包含以下<strong>三种</strong>：</p><ul><li><code>Composition</code> - <strong>复合</strong></li><li><code>Delegation</code> - <strong>委托</strong></li><li><code>Inheritance</code> - <strong>继承</strong></li></ul><h1 id="Composition-复合"><a href="#Composition-复合" class="headerlink" title="Composition(复合)"></a>Composition(复合)</h1><p><strong>复合</strong>表示类中有一个<strong>成员变量</strong>(<strong>非指针变量</strong>), 即表示<code>has-a</code>, 如下图所示:类<code>queue</code>中有一个<code>deque</code>(<code>has a</code>); <strong>变量和类本身的寿命是同生同灭</strong><br><img src="/images/queue-deque.png" alt="queue-deque.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _QUEUE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _QUEUE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> learn&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Itr</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        T* cur;</span><br><span class="line">        T* first;</span><br><span class="line">        T* last;</span><br><span class="line">        T** node;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">deque</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="built_in">deque</span>()&#123; std::cout &lt;&lt; <span class="string">&quot;deque ctor.&quot;</span> &lt;&lt; std::endl;&#125;</span><br><span class="line">            ~<span class="built_in">deque</span>()&#123; std::cout &lt;&lt; <span class="string">&quot;deque dctor.&quot;</span> &lt;&lt; std::endl;&#125;</span><br><span class="line">        <span class="keyword">protected</span>:</span><br><span class="line">            Itr&lt;T&gt; start;</span><br><span class="line">            Itr&lt;T&gt; finish;</span><br><span class="line">            T** map;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> map_size;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Sequence</span> =</span> deque&lt;T&gt;&gt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">queue</span>&#123;</span></span><br><span class="line">        <span class="keyword">protected</span>:</span><br><span class="line">            Sequence c;<span class="comment">// 复合 has-a</span></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="built_in">queue</span>()&#123; std::cout &lt;&lt; <span class="string">&quot;queue ctor.&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">            ~<span class="built_in">queue</span>()&#123; std::cout &lt;&lt; <span class="string">&quot;queue dctor.&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">            <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">empty</span>();&#125;</span><br><span class="line">            <span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> c.<span class="built_in">size</span>();&#125;</span><br><span class="line">            </span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span></span>&#123;c.<span class="built_in">push_back</span>(x);&#125;</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;c.<span class="built_in">pop_front</span>();&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="Adapter概念"><a href="#Adapter概念" class="headerlink" title="Adapter概念"></a><code>Adapter</code>概念</h2><p><code>deque</code>是两端都可以进出的<strong>双队列</strong>, 而<code>queue</code>是先进的<strong>队列</strong>,明显<code>deque</code>功能比<code>queue</code>强大;上面的<code>queue</code>并没有重新创建新的函数都是对<code>deque</code>进行了一层包装,这就是<strong>适配器设计模式</strong></p><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p><img src="/images/Composition_picture.png" alt="Composition_picture.png"></p><h2 id="构造和析构"><a href="#构造和析构" class="headerlink" title="构造和析构"></a>构造和析构</h2><p><code>Composition</code> 关系下的构造和析构<br><img src="/images/Compostion_ctor_dctor.png" alt="Compostion_ctor_dctor.png"><br><code>Composition</code>关系下的构造和析构函数, <code>Container</code>和 <code>Component</code>的构造和析构函数的<strong>调用关系由编译器帮我们决定</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;queue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    learn::queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 运行结果</span><br><span class="line">deque ctor.</span><br><span class="line">queue ctor.</span><br><span class="line">queue dctor.</span><br><span class="line">deque dctor.</span><br></pre></td></tr></table></figure></p><h3 id="构造由内而外"><a href="#构造由内而外" class="headerlink" title="构造由内而外"></a>构造由内而外</h3><p><code>Container</code>的<strong>构造函数</strong>先调用<code>Component</code>的<code>default</code> <strong>构造函数</strong>, 然后执行<strong>自己的构造函数</strong>,即:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Container::<span class="built_in">Container</span>(...): <span class="built_in">Component</span>() &#123;...&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="析构由外而内"><a href="#析构由外而内" class="headerlink" title="析构由外而内"></a>析构由外而内</h3><p><code>Container</code>的<strong>析构函数</strong>先执行自己的<strong>析构任务</strong>, 然后<code>Component</code>的<strong>析构函数</strong>,即:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Container::~<span class="built_in">Container</span>(...): &#123; ...; ~<span class="built_in">Component</span>()&#125;;</span><br></pre></td></tr></table></figure></p><p><br><br><br></p><h1 id="Delegation-委托"><a href="#Delegation-委托" class="headerlink" title="Delegation(委托)"></a>Delegation(委托)</h1><p><strong>委托</strong>表示类中有一个<strong>成员变量</strong>(<strong>指针变量</strong>),即<code>Composition by reference</code> 如下图所示:类<code>String</code>中有一个<code>StringRep</code>, <code>String</code>是<code>Handle</code>, <code>StringRep</code>是<code>Body</code>； 指针变量指向的<code>Body</code>和<code>Handle</code>的生命周期不一致(可能<code>Handle</code>对象先被创建, <code>Body</code>之后用到才被创建)<br><img src="/images/Delegation.png" alt="Delegation.png"><br>其中<code>n</code>是用作<strong>引用计数</strong></p><h2 id="pimpl"><a href="#pimpl" class="headerlink" title="pimpl"></a>pimpl</h2><p>像上述的<strong>设计模式</strong>即为<code>pimpl</code>(Pointer to Implementation), <code>Handle</code>部分被用户直接调用, 实现部分由<code>Body</code>完成, 这种手法被称为<strong>编译防火墙</strong>(<code>Handle</code>不用重新编译, 单独编译<code>Body</code>部分即可)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _MYSTRINGDELEGATION_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _MYSTRINGDELEGATION_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> learn</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">StringDe</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">StringRep</span>&#123;</span></span><br><span class="line">        <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDe</span>;</span></span><br><span class="line">        <span class="built_in">StringRep</span>(<span class="keyword">const</span> <span class="keyword">char</span>* s);</span><br><span class="line">        ~<span class="built_in">StringRep</span>();</span><br><span class="line">        <span class="keyword">int</span> count;<span class="comment">// 引用计数器</span></span><br><span class="line">        <span class="keyword">char</span> *rep;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">StringDe</span>&#123;</span></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="built_in">StringDe</span>();</span><br><span class="line">            <span class="built_in">StringDe</span>(<span class="keyword">const</span> <span class="keyword">char</span> *s);</span><br><span class="line">            <span class="built_in">StringDe</span>(<span class="keyword">const</span> StringDe&amp; s);</span><br><span class="line">            StringDe&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> StringDe&amp; s);</span><br><span class="line">            ~<span class="built_in">StringDe</span>();</span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            StringReq* rep; <span class="comment">// pimpl - Pointer to Implementation</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;   </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p><p><br><br><br></p><h1 id="Inheritance-继承"><a href="#Inheritance-继承" class="headerlink" title="Inheritance(继承)"></a>Inheritance(继承)</h1><p><strong>继承</strong>表示<strong>类在数据包含了父类的数据部分</strong>, 即表现为 <code>is a</code>; 但这<strong>不是继承的核心要义, 继承和虚函数搭配才是核心</strong><br><img src="/images/Inheritance.png" alt="Inheritance.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _LIST_NODE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _LIST_NODE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> learn</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">List_node_base</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        _List_node_base()&#123;std::cout &lt;&lt; <span class="string">&quot;_List_node_base ctor.&quot;</span>&lt;&lt; std::endl;&#125;</span><br><span class="line">        <span class="keyword">virtual</span> ~_List_node_base()&#123;std::cout &lt;&lt; <span class="string">&quot;_List_node_base dctor.&quot;</span>&lt;&lt; std::endl;&#125;</span><br><span class="line">        _List_node_base *_M_next;</span><br><span class="line">        _List_node_base *_M_prev;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">List_node</span>:</span> <span class="keyword">public</span> _List_node_base</span><br><span class="line">    &#123;</span><br><span class="line">        _List_node()&#123;std::cout &lt;&lt; <span class="string">&quot;_List_node ctor.&quot;</span>&lt;&lt; std::endl;&#125;</span><br><span class="line">        ~_List_node()&#123;std::cout &lt;&lt; <span class="string">&quot;_List_node dctor.&quot;</span>&lt;&lt; std::endl;&#125;</span><br><span class="line"></span><br><span class="line">        _Tp _M_data;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="构造和析构-1"><a href="#构造和析构-1" class="headerlink" title="构造和析构"></a>构造和析构</h2><p><code>Inheritance</code>关系下的构造和析构函数, <code>Base</code>和 <code>Derive</code>的构造和析构函数的<strong>调用关系由编译器帮我们决定</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;List_node.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    learn::_List_node&lt;<span class="keyword">int</span>&gt; list_node;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"># 运行结果</span><br><span class="line">_List_node_base ctor.</span><br><span class="line">_List_node ctor.</span><br><span class="line">_List_node dctor.</span><br><span class="line">_List_node_base dctor.</span><br></pre></td></tr></table></figure><h3 id="构造由内而外-1"><a href="#构造由内而外-1" class="headerlink" title="构造由内而外"></a>构造由内而外</h3><p><code>Derive</code>的<strong>构造函数</strong>先调用<code>Base</code>的<code>default</code> <strong>构造函数</strong>, 然后执行<strong>自己的构造函数</strong>,即:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Derive::<span class="built_in">Derive</span>(...): <span class="built_in">Base</span>() &#123;...&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="析构由外而内-1"><a href="#析构由外而内-1" class="headerlink" title="析构由外而内"></a>析构由外而内</h3><p><code>Derive</code>的<strong>析构函数</strong>先执行自己的<strong>析构任务</strong>, 然后<code>Base</code>的<strong>析构函数</strong>,即:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Derive::~<span class="built_in">Derive</span>(...): &#123; ...; ~<span class="built_in">Base</span>()&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="基类析构函数"><a href="#基类析构函数" class="headerlink" title="基类析构函数"></a>基类析构函数</h2><p>如果一个<strong>类有可能成为基类, 则应该把该类的析构函数定义</strong>为<code>virtual</code>(理由比较长),这是一个<strong>良好的编程习惯</strong>, 否则会出现<code>undefined behavior</code></p><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p><strong>继承搭配虚函数</strong>时(<code>Inheritance with virtual functions</code>),才能产生<strong>强有力的效果</strong>, 类中一个函数被定义为<code>virtual</code>时,是希望子类重新定义该函数</p><ul><li><p><code>non-virtual</code>函数: 你<strong>不希望</strong><code>derived class</code> <strong>重新定义</strong><code>override</code>该函数</p></li><li><p><code>virtual</code>函数: 你<strong>希望</strong><code>derived class</code><strong>重新定义</strong><code>override</code>该函数,而且你已经<strong>对该函数有一个默认定义了</strong></p></li><li><p><code>pure virtual</code>函数: 你<strong>希望</strong><code>derived class</code> <strong>一定要重新定义</strong><code>override</code>该函数,而且你<strong>已经对该函数有没有默认定义</strong>(其实纯虚函数可以有定义)</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03-C++-模板、函数模板与其它</title>
      <link href="/2022/08/05/CPP/03-C-%E6%A8%A1%E6%9D%BF%E3%80%81%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E4%B8%8E%E5%85%B6%E5%AE%83/"/>
      <url>/2022/08/05/CPP/03-C-%E6%A8%A1%E6%9D%BF%E3%80%81%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E4%B8%8E%E5%85%B6%E5%AE%83/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>02-C++-内存、栈与内存管理</title>
      <link href="/2022/07/31/CPP/02-C-%E5%86%85%E5%AD%98%E3%80%81%E6%A0%88%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/2022/07/31/CPP/02-C-%E5%86%85%E5%AD%98%E3%80%81%E6%A0%88%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01-C++-指针类</title>
      <link href="/2022/07/31/CPP/01-C-%E6%8C%87%E9%92%88%E7%B1%BB/"/>
      <url>/2022/07/31/CPP/01-C-%E6%8C%87%E9%92%88%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>00-C++-非指针类</title>
      <link href="/2022/07/31/CPP/00-C-%E9%9D%9E%E6%8C%87%E9%92%88%E7%B1%BB/"/>
      <url>/2022/07/31/CPP/00-C-%E9%9D%9E%E6%8C%87%E9%92%88%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p><strong>C++</strong>类可以分为两种类型:</p><ul><li>非指针类型的<code>Class</code></li><li>指针类型的<code>Class</code></li></ul><p>这两种类型的<code>Class</code>的<strong>重要区别</strong>在于<strong>拷贝构造、拷贝赋值和析构函数</strong>(<code>Big Three</code>)上的巨大差异, 主要在于编译器在拷贝时是<strong>傻瓜式对象内存拷贝</strong>:</p><ul><li>非指针类型的<code>Class</code>使用编译器给的<strong>拷贝构造、拷贝赋值和析构函数</strong>即可</li><li>指针类型的<code>Class</code>必须自己<strong>实现这三个函数</strong></li></ul><p>本笔记对应的<a href="/code/C++面向对象编程上.zip">代码笔记链接-C++面向对象编程上</a>, 对应<code>complex</code>的实现</p><h1 id="非指针类Complex的基本框架"><a href="#非指针类Complex的基本框架" class="headerlink" title="非指针类Complex的基本框架"></a>非指针类Complex的基本框架</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p><strong>非指针类</strong>的核心特点在于<strong>其数据不是指针</strong>,如下面复数模板类的成员数据是<code>T</code>,关键点如下:</p><ul><li><code>_Complex_H_</code><strong>防卫式声明</strong></li><li><strong>构造函数</strong>放在<code>public</code>中,构造函数可以被外部调用<ul><li>构造函数中有<strong>两个阶段完成数据初始化</strong>,分别是<strong>初始化列表中完成数据初始化</strong>和<strong>构造函数体内完成数据初始化</strong></li><li>该构造函数指定了默认参数,所有此外还定义<code>Complex() : re(0), im(0) &#123;&#125;</code>这样的函数,就会导致编译器不知道调用哪个不带参数的函数</li><li>构造函数不能直接调用,只能在对象创建时被间接调用<ul><li>1、<code>learn::Complex&lt;double&gt; c1(2.5, 1.5);</code>调用<strong>构造函数1</strong></li><li>2、<code>learn::Complex&lt;double&gt; c2;</code>调用<strong>构造函数1</strong>,使用默认参数</li><li>3、<code>learn::Complex&lt;double&gt; c3();</code>这不是定义一个<code>Complex</code>对象是声明了一个函数,函数名为<code>c3</code></li><li>4、<code>learn::Complex&lt;double&gt; *p = new learn::Complex&lt;double&gt;(4);</code>// 定义一个<code>Complex</code>对象,让指针<code>p</code>指向该对象</li></ul></li><li>当没有调用<strong>拷贝构造、拷贝赋值、析构函数</strong>时,编译器会生成一份<strong>拷贝构造、拷贝赋值、析构函数</strong>,这份<strong>拷贝构造和拷贝赋值</strong>就是就是简单的对象内存拷贝,而这份析构函数没有做如何处理,这对非指针类型的<code>Class</code>来说刚好够用,像<code>Complex</code>类其数据就是<code>re</code>和<code>im</code>;而指针类的<code>class</code><strong>必须自己实现这三个函数</strong>,不实现<strong>拷贝构造、拷贝赋值</strong>会导致<strong>浅拷贝</strong>,<strong>不实现析构函数</strong>可能会造成<strong>内存泄露</strong></li></ul></li><li>数据放在<code>private</code>作用域中起到对数据封装的作用</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _Complex_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _Complex_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> learn</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 模板类声明格式</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Complex</span>;</span></span><br><span class="line">    <span class="comment">// ... 此次可以申明一些用到Complex的全局函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 构造函数1-指定默认实参</span></span><br><span class="line">        <span class="built_in">Complex</span>(T r = <span class="number">0</span>, T i = <span class="number">0</span>) : <span class="built_in">re</span>(r), <span class="built_in">im</span>(i)</span><br><span class="line">        &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;use default ctor &quot;</span> &lt;&lt; <span class="string">&quot;r: &quot;</span>&lt;&lt; r &lt;&lt; <span class="string">&quot;, i:&quot;</span>&lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T re, im;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; <span class="comment">// end namespace learn</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><blockquote><p><strong>构造函数</strong>不一定放在<code>public</code>中,经典的单例模式实现如下,其构造函数就放在<code>private</code>中;</p><ul><li>函数中定义的<code>static</code>变量对应的内存<strong>在堆中</strong>,第一次调用<code>getInstance</code>时定义该变量(分配内存),直到程序退出时才死亡; 不调用<code>getInstance</code>函数不定义定义对象,这样节省了内存;</li><li>构造函数都被定义在<code>private</code>中,在类的外部<strong>无法直接定义</strong>,只能通过<code>getInstance</code>函数创建一份<code>A</code>对象</li><li><code>static</code>函数是为<code>static</code>成员变量服务</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> learn</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">static</span> A &amp;<span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">A</span>() &#123;&#125;</span><br><span class="line">        <span class="built_in">A</span>(<span class="keyword">const</span> A &amp;rhs) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A &amp;<span class="title">A::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> A a;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><p><code>c++</code><strong>成员函数</strong>的参数都带有一个<code>this</code>指针,该指针指向<strong>对象本身</strong>,因此可以通过<code>this</code>指针来<strong>访问/修改对象的成员数据</strong></p><ul><li>成员函数参数与函数体之间的<code>const</code>用来修饰指针<code>this</code>,即<code>const typename *this</code>;因此这类函数不能修改入参<code>this</code>指向的对象</li><li>如果一个<code>const</code>对象调用了非<code>const</code>方法,编译器会报<code>passing ‘const learn::Complex&lt;int&gt;’ as ‘this’ argument discards qualifiers [-fpermissive]</code>将<code>const learn::Complex&lt;int&gt;</code>传递给<code>this</code>指针会丢失掉<code>const</code>限定符</li><li>比如<code>a.fun(b)</code>的调用方式,为什么对象<code>a</code>可以在<code>func</code>中直接拿到<code>b</code>的<strong>私有数据</strong>呢？ =&gt; <strong>相同class的各对象互为friends</strong><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// const表示不能通过this来修改对象的数据</span></span><br><span class="line">    <span class="function">T <span class="title">real</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> re; &#125;</span><br><span class="line">    <span class="function">T <span class="title">imag</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> im; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this 对象直接访问 另外一个(同类型)对象的private数据, 相同class的各对象互为friends</span></span><br><span class="line">    <span class="function">T <span class="title">func</span><span class="params">(<span class="keyword">const</span> Complex&lt;T&gt; &amp;param)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> param.re + param.im;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h2 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h2><p><strong>友元函数声明</strong>告诉编译器<code>__doapl</code>是我<strong>这个类的友元</strong>, <strong>那么</strong>可以<strong>在该函数中直接访问</strong>该类的<code>private</code>数据或方法,这也打开了<strong>封装的大门</strong></p><ul><li><strong>友元模板函数</strong>必须定义在<code>.h</code>文件中</li><li><code>inline</code>和<strong>模板函数</strong>的格式</li><li><code>__doapl</code>是<code>do assign plus</code>执行赋值加法<ul><li><code>ths</code>指针<strong>会被修改</strong>, 所以<strong>没有被声明</strong>为<code>const</code></li><li><code>r</code>对象<strong>不会被修改</strong>, 所以<strong>声明</strong>为<code>const</code></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模板类声明格式</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Complex&lt;T&gt; &amp;__doapl(Complex&lt;T&gt; *ths, <span class="keyword">const</span> Complex&lt;T&gt; &amp;r);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 成员函数重载</span></span><br><span class="line">    Complex&lt;T&gt; &amp;<span class="keyword">operator</span>+=(<span class="keyword">const</span> Complex&lt;T&gt; &amp;rhs)&#123;<span class="keyword">return</span> __doapl(<span class="keyword">this</span>, rhs);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T re, im;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 友元函数声明</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="keyword">friend</span> Complex&lt;U&gt; &amp;__doapl(Complex&lt;U&gt; *, <span class="keyword">const</span> Complex&lt;U&gt; &amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> Complex&lt;T&gt; &amp;__doapl(Complex&lt;T&gt; *ths, <span class="keyword">const</span> Complex&lt;T&gt; &amp;r)</span><br><span class="line">&#123;</span><br><span class="line">    ths-&gt;re += r.re;</span><br><span class="line">    ths-&gt;im += r.im;</span><br><span class="line">    <span class="keyword">return</span> *ths; <span class="comment">// 传递着无需知道接收者以reference形式接收</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h2><h3 id="二元操作符重载"><a href="#二元操作符重载" class="headerlink" title="二元操作符重载"></a>二元操作符重载</h3><ul><li>[同一个<code>class</code>] 当我们想执行类似<code>object1 += object2</code>这样的运算时, <strong>编译器</strong>会去在<code>class</code>中找一个函数<code>function</code>来完成<code>object2.function(object2)</code>;所以<code>function</code>是<code>class</code>的<strong>成员函数</strong>, 按照<code>C++</code>的<strong>语法</strong>,这个<code>function</code>应该<strong>被定义为</strong>:<ul><li>该函数的入参是<code>object2</code>,且是<code>const Complex&lt;T&gt; &amp;</code></li><li>该运算的结果还是<code>object1</code>(也即该函数的返回值)</li></ul></li></ul><p><code>Complex&lt;T&gt; &amp;operator+=(const Complex&lt;T&gt; &amp;rhs)&#123;return __doapl(this, rhs);&#125;</code></p><ul><li>[不同<code>class</code>] 当<code>object1</code>和<code>object2</code>不是同一个<code>class</code>时,且<code>object1</code>的<code>class</code>不是自己实现的类,比如<code>std::cout &lt;&lt; object1</code>; 此时的<strong>二元操作符重载</strong>应该按照如下实现<ul><li>将该函数声明为为<code>Complex</code>的友元函数, 方便取数据</li><li>输出时会改变<code>os</code>,所以没有用<code>const</code>修饰<code>os</code>; 不改变<code>rhs</code>,所以使用<code>const</code>修改<code>rhs</code></li><li>该函数返回<code>os</code>是为了方便连续输出, 比如<code>std::cout &lt;&lt; object1 &lt;&lt; &quot;::&quot; &lt;&lt; std::endl;</code></li><li><code>os</code>在调用<code>&lt;&lt;</code>之前就已经存在, 所以返回<strong>引用没有问题</strong></li><li><strong>实数 + 复数</strong>的案例中, 使用<code>typename() 创建临时对象(temp object)</code>,所以返回时必须使用<code>reture by value</code></li><li><code>&lt;&lt;</code>必须定义为<strong>函数重载</strong>;<strong>复数 + 实数</strong>可以是<strong>成员函数重载</strong>也可以是<strong>全局函数重载</strong></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 复数 + 实数</span></span><br><span class="line">    Complex&lt;T&gt; <span class="keyword">operator</span>+(<span class="keyword">double</span> re) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Complex&lt;T&gt;(<span class="keyword">this</span>-&gt;re + re, <span class="keyword">this</span>-&gt;im); <span class="comment">// 这里会创建一个临时变量, 所以返回值是return by value</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T re, im;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 友元函数声明</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="keyword">friend</span> std::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;os, <span class="keyword">const</span> Complex&lt;U&gt; &amp;rhs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实数 + 复数</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="keyword">friend</span> Complex&lt;U&gt; <span class="keyword">operator</span>+(<span class="keyword">double</span> re, <span class="keyword">const</span> Complex&lt;U&gt; &amp;rhs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复数 + 实数</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="keyword">friend</span> Complex&lt;U&gt; <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex&lt;U&gt;&amp; lhs, <span class="keyword">double</span> re) ; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">inline</span> std::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;os, <span class="keyword">const</span> learn::Complex&lt;U&gt; &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; rhs.re &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; rhs.im &lt;&lt; <span class="string">&quot;i)&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实数 + 复数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">Complex&lt;U&gt; <span class="keyword">operator</span>+(<span class="keyword">double</span> re, <span class="keyword">const</span> Complex&lt;U&gt; &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Complex&lt;U&gt;(re + rhs.re, rhs.im);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复数 + 实数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">Complex&lt;U&gt; <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex&lt;U&gt;&amp; lhs, <span class="keyword">double</span> re)</span><br><span class="line">&#123;   </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;global function&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> Complex&lt;U&gt;(lhs.re + re, lhs.im);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一元操作符重载"><a href="#一元操作符重载" class="headerlink" title="一元操作符重载"></a>一元操作符重载</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        T re, im;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 友元函数声明</span></span><br><span class="line">    <span class="comment">// 取反</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="keyword">friend</span> Complex&lt;U&gt; <span class="keyword">operator</span>-(<span class="keyword">const</span> Complex&lt;U&gt; &amp;rhs);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">Complex&lt;U&gt; <span class="keyword">operator</span>-(<span class="keyword">const</span> Complex&lt;U&gt; &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Complex&lt;U&gt;(-rhs.re, -rhs.im);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Raspberry+Docker+Gitlab+Jenkins</title>
      <link href="/2022/06/05/Raspberry-Docker-Gitlab-Jenkins/"/>
      <url>/2022/06/05/Raspberry-Docker-Gitlab-Jenkins/</url>
      
        <content type="html"><![CDATA[<h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><ul><li><p>1、安装curl</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install curl</span><br></pre></td></tr></table></figure></li><li><p>2、使用<code>curl</code>安装<code>docker</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -sSL https://get.docker.com | sh</span><br></pre></td></tr></table></figure></li><li><p>3、安装<code>docker-compose</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip3 install docker-compose</span><br></pre></td></tr></table></figure></li></ul><h2 id="docker的基本操作"><a href="#docker的基本操作" class="headerlink" title="docker的基本操作"></a>docker的基本操作</h2><ul><li><strong>查看当前有</strong>哪些<code>docker</code>镜像<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ sudo -i</span><br><span class="line">[sudo] password for tangshp:</span><br><span class="line">root@tangshp-desktop:~# docker images</span><br><span class="line">REPOSITORY               TAG       IMAGE ID       CREATED      SIZE</span><br><span class="line">yrzr/gitlab-ce-arm64v8   latest    6db1d4ba809d   3 days ago   2.46GB</span><br></pre></td></tr></table></figure></li><li><p>查看当前哪些<strong>镜像被运行</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@tangshp-desktop:~# docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE                           COMMAND             CREATED        STATUS                  PORTS                                                                                                         NAMES</span><br><span class="line">e39d62cc5e81   yrzr/gitlab-ce-arm64v8:latest   &quot;/assets/wrapper&quot;   25 hours ago   Up 13 hours (healthy)   0.0.0.0:22-&gt;22/tcp, :::22-&gt;22/tcp, 0.0.0.0:80-&gt;80/tcp, :::80-&gt;80/tcp, 0.0.0.0:443-&gt;443/tcp, :::443-&gt;443/tcp   gitlab</span><br></pre></td></tr></table></figure></li><li><p>暂停指定正运行的<strong>镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop e39d62cc5e81</span><br></pre></td></tr></table></figure></li><li><p>将<strong>暂停的镜像删除</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm e39d62cc5e81</span><br></pre></td></tr></table></figure></li><li><p><strong>删除镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi 6db1d4ba809d</span><br></pre></td></tr></table></figure></li><li><p>进入<code>docker</code>的<code>bash</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ sudo docker exec -it gitlab bash</span><br></pre></td></tr></table></figure></li></ul><h1 id="gitlab镜像"><a href="#gitlab镜像" class="headerlink" title="gitlab镜像"></a>gitlab镜像</h1><h2 id="yml文件配置"><a href="#yml文件配置" class="headerlink" title="yml文件配置"></a>yml文件配置</h2><p>保证在<code>/opt/gitlab</code>有<code>config,data,logs</code>文件夹与<code>docker-compose.yml</code>文件<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  gitlab ls -l</span><br><span class="line">total 16</span><br><span class="line">drwxrwxr-x  3 root root 4096 6月   4 19:09 config</span><br><span class="line">drwxr-xr-x 21 root root 4096 6月   4 19:41 data</span><br><span class="line">-rw-r--r--  1 root root  710 6月   4 19:29 docker-compose.yml</span><br><span class="line">drwxr-xr-x 21 root root 4096 6月   4 19:36 logs</span><br></pre></td></tr></table></figure><br><code>docker-compose.yml</code>文件内容如下<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">gitlab:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">yrzr/gitlab-ce-arm64v8:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">gitlab</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">&#x27;Asia/Shanghai&#x27;</span></span><br><span class="line">      <span class="attr">GITLAB_OMNIBUS_CONFIG:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        external_url = &quot;http://192.168.0.100&quot;</span></span><br><span class="line"><span class="string">        gitlab_rails[&#x27;time_zone&#x27;] = &#x27;Asia/Shanghai&#x27;</span></span><br><span class="line"><span class="string">        gitlab_rails[&#x27;smtp_enable&#x27;] = true</span></span><br><span class="line"><span class="string">        gitlab_rails[&#x27;gitlab_shell_ssh_port&#x27;] = 22</span></span><br><span class="line"><span class="string"></span>    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;80:80&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;443:443&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;22:22&#x27;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;/opt/gitlab/config:/etc/gitlab&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;/opt/gitlab/logs:/var/log/gitlab&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;/opt/gitlab/data:/var/opt/gitlab&#x27;</span></span><br><span class="line">    <span class="attr">logging:</span></span><br><span class="line">      <span class="attr">driver:</span> <span class="string">&quot;json-file&quot;</span></span><br><span class="line">      <span class="attr">options:</span></span><br><span class="line">        <span class="attr">max-size:</span> <span class="string">&quot;20m&quot;</span></span><br><span class="line">        <span class="attr">max-file:</span> <span class="string">&quot;10&quot;</span></span><br></pre></td></tr></table></figure></p><h2 id="运行gitlab镜像"><a href="#运行gitlab镜像" class="headerlink" title="运行gitlab镜像"></a>运行<code>gitlab</code>镜像</h2><ul><li>修改<code>ssh</code>端口</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">Port 22</span></span><br><span class="line">Port 5000</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在/opt/gitlab路径下运行 以sudo运行</span></span><br><span class="line">docker-compose up -d</span><br><span class="line"></span><br><span class="line">docker-compose logs -f</span><br></pre></td></tr></table></figure><h2 id="gitlab的基本操作"><a href="#gitlab的基本操作" class="headerlink" title="gitlab的基本操作"></a><code>gitlab</code>的基本操作</h2><h3 id="修改root密码"><a href="#修改root密码" class="headerlink" title="修改root密码"></a>修改<code>root</code>密码</h3><ul><li><p>进入<code>gitlab-rails console</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ sudo docker exec -it gitlab /bin/bash</span><br><span class="line">root@f6dc09e1b62b:/# gitlab-rails console</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line"> Ruby:         ruby 2.7.5p203 (2021-11-24 revision f69aeb8314) [aarch64-linux]</span><br><span class="line"> GitLab:       15.0.1 (39b217000de) FOSS</span><br><span class="line"> GitLab Shell: 14.3.0</span><br><span class="line"> PostgreSQL:   13.6</span><br><span class="line">-----------------------------------------------------------[ booted in 145.96s ]</span><br><span class="line">Loading production environment (Rails 6.1.4.7)</span><br><span class="line">irb(main):001:0&gt;</span><br></pre></td></tr></table></figure></li><li><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">irb(main):001:0&gt; user = User.where(username:&quot;root&quot;).first</span><br><span class="line">=&gt; #&lt;User id:1 @root&gt;</span><br><span class="line">irb(main):002:0&gt; user.password = &quot;xxxxx&quot;</span><br><span class="line">=&gt; &quot;xxxxx&quot;</span><br><span class="line">irb(main):003:0&gt; user.save!</span><br><span class="line">=&gt; true</span><br></pre></td></tr></table></figure></li></ul><h3 id="修改下载地址为ip"><a href="#修改下载地址为ip" class="headerlink" title="修改下载地址为ip"></a>修改下载地址为<code>ip</code></h3><ul><li><p>修改<code>gitlab.rb</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/gitlab/gitlab.rb</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#! https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instancedata-data-retrieval.html</span></span></span><br><span class="line">external_url &#x27;http://192.168.5.48/gitlab&#x27;</span><br></pre></td></tr></table></figure></li><li><p>重启<code>gitlab</code>服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure></li></ul><h1 id="jenkins"><a href="#jenkins" class="headerlink" title="jenkins"></a>jenkins</h1><h2 id="安装jenkins"><a href="#安装jenkins" class="headerlink" title="安装jenkins"></a>安装jenkins</h2><ul><li>1、安装<code>daemon</code><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install daemon</span><br></pre></td></tr></table></figure></li><li><p>2、安装<code>jenkins</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install jenkins</span><br></pre></td></tr></table></figure></li><li><p>3、修改<code>/etc/default/jenkins</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> user and group to be invoked as (default to jenkins)</span></span><br><span class="line">JENKINS_USER=root</span><br><span class="line">JENKINS_GROUP=root</span><br></pre></td></tr></table></figure></li><li><p>4、修改<code>/var/lib/jenkins/hudson.model.UpdateCenter.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://mirror.xmission.com/jenkins/updates/update-center.json</span><br></pre></td></tr></table></figure></li><li><p>5、重启服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart jenkins</span><br></pre></td></tr></table></figure></li><li>6、访问<code>http://192.168.5.48:8080/</code></li></ul><blockquote><p>jenkins插件路径<code>/var/lib/jenkins/plugins/</code></p></blockquote><h2 id="jenkins服务"><a href="#jenkins服务" class="headerlink" title="jenkins服务"></a>jenkins服务</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl start jenkins</span><br><span class="line">systemctl restart jenkins</span><br><span class="line">systemctl stop jenkins</span><br></pre></td></tr></table></figure><h2 id="jenkins的基本使用"><a href="#jenkins的基本使用" class="headerlink" title="jenkins的基本使用"></a>jenkins的基本使用</h2><h3 id="jenkins集成gitlab"><a href="#jenkins集成gitlab" class="headerlink" title="jenkins集成gitlab"></a>jenkins集成gitlab</h3><ul><li><code>http</code><ul><li><strong>设置凭据</strong>，在<code>Manage Jenkins/Security/Manage Credentials/</code>设置<br><img src="/images/jenkins设置凭据.png" alt="jenkins设置凭据"><br><img src="/images/jenkins凭据http.png" alt="jenkins设置凭据"></li><li><strong>生成流水线脚本</strong>,在<code>cubli_mini_master/配置/流水线语法/片段生成器中</code>中生成代码片段<br><img src="/images/jenkins_http_checkout.png" alt="jenkins_http_checkout.png"></li></ul></li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">pipeline &#123;</span><br><span class="line">  agent &#123;</span><br><span class="line">      label <span class="string">&#x27;ubuntu18.04&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    stages&#123;</span><br><span class="line">        stage(<span class="string">&#x27;检测环境&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            steps&#123;</span><br><span class="line">                echo <span class="string">&#x27;check the environment&#x27;</span></span><br><span class="line">                sh <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">                java -version</span></span><br><span class="line"><span class="string">                echo &quot;&quot;</span></span><br><span class="line"><span class="string">                gcc -v</span></span><br><span class="line"><span class="string">                echo &quot;&quot;</span></span><br><span class="line"><span class="string">                cmake -version</span></span><br><span class="line"><span class="string">                echo &quot;&quot;</span></span><br><span class="line"><span class="string">                git version</span></span><br><span class="line"><span class="string">                echo &quot;&quot;</span></span><br><span class="line"><span class="string">                docker -v</span></span><br><span class="line"><span class="string">                &#x27;&#x27;&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;拉取代码&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            steps&#123;</span><br><span class="line">                echo <span class="string">&#x27;git pull code from gitlab&#x27;</span></span><br><span class="line">                checkout([<span class="attr">$class:</span> <span class="string">&#x27;GitSCM&#x27;</span>, <span class="attr">branches:</span> [[<span class="attr">name:</span> <span class="string">&#x27;*/main&#x27;</span>]], <span class="attr">extensions:</span> [], <span class="attr">userRemoteConfigs:</span> [[<span class="attr">credentialsId:</span> <span class="string">&#x27;e3704e36-e832-4786-8b3c-5c3fd90f7d59&#x27;</span>, <span class="attr">url:</span> <span class="string">&#x27;http://192.168.5.48/cubli_mini_serial/cubli_mini_master.git&#x27;</span>]]])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;编译构建&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            steps&#123;</span><br><span class="line">                echo <span class="string">&#x27;build the project&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stage(<span class="string">&#x27;项目部署&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            steps&#123;</span><br><span class="line">                echo <span class="string">&#x27;deploy the project&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="查看jenkins的工作目录"><a href="#查看jenkins的工作目录" class="headerlink" title="查看jenkins的工作目录"></a>查看<code>jenkins</code>的工作目录</h3><p><img src="/images/jenkinsHome.png" alt="查看jenkins路径"><br><img src="/images/pwdJenkinsWorkspace.png" alt="pipeline"></p>]]></content>
      
      
      <categories>
          
          <category> 搭建CI环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>freeRTOS-03-freeRTOS中的互斥</title>
      <link href="/2022/05/18/FreeRTOS/freeRTOS-03-freeRTOS%E4%B8%AD%E7%9A%84%E4%BA%92%E6%96%A5/"/>
      <url>/2022/05/18/FreeRTOS/freeRTOS-03-freeRTOS%E4%B8%AD%E7%9A%84%E4%BA%92%E6%96%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="freeRTOS中的互斥概念"><a href="#freeRTOS中的互斥概念" class="headerlink" title="freeRTOS中的互斥概念"></a>freeRTOS中的互斥概念</h1><p>假设<code>StartTask1</code>和<code>StartTask2</code>如下所示,变量<code>a</code>表示<strong>两个任务共执行了多少次</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint16_t</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StartTask1</span><span class="params">(<span class="keyword">void</span> <span class="keyword">const</span> *argument)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (;;)  &#123;</span><br><span class="line">    osDelay(<span class="number">5</span>);</span><br><span class="line">    a++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StartTask2</span><span class="params">(<span class="keyword">void</span> <span class="keyword">const</span> *argument)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (;;)  &#123;</span><br><span class="line">    osDelay(<span class="number">5</span>);</span><br><span class="line">    a++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如下图所示,在<strong>汇编层面</strong><code>StartTask1</code>和<code>StartTask2</code>交替的运行,导<strong>致调用完两个任务一次后</strong>,变量<code>a</code>为<code>1</code>,而不是<code>2</code><br><img src="/images/互斥量的概念.png" alt="互斥量的概念"></p><blockquote><p>当<strong>变量在多个任务中被写时</strong>,会出现<strong>竞争关系</strong></p></blockquote><h1 id="通过队列实现互斥"><a href="#通过队列实现互斥" class="headerlink" title="通过队列实现互斥"></a>通过队列实现互斥</h1><p>如果<strong>有多个任务对一个变量写</strong>时,可以把<strong>写操作</strong>放在一个<strong>单独的函数(QueueSend)中实现</strong>,在该函数中<strong>写操作前</strong>关闭<code>Tick</code>中断,完成<strong>写操作后</strong>打开<code>Tick</code>中断;如下图所示:<br><img src="/images/freeRTOS互斥的实现.png" alt="freeRTOS互斥的实现"></p><blockquote><p>关闭<code>Tick</code>中断后,代码的运算就是<strong>裸机程序</strong></p></blockquote><h1 id="互斥队列支持休眠唤醒"><a href="#互斥队列支持休眠唤醒" class="headerlink" title="互斥队列支持休眠唤醒"></a>互斥队列支持休眠唤醒</h1><p><strong>裸机程序</strong>中经常有这样一种场景,函数<code>funA</code>中回设置标志位<code>flag</code>,函数<code>funB</code>会根据标志位<code>flag</code>是否是<code>1</code>来执行响应的操作;如以下代码所示:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funA</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// maybe set flag to 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funB</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (flag)</span><br><span class="line">    &#123;</span><br><span class="line">        do_something();</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        funA();</span><br><span class="line">        funB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果<code>funA</code>中仅有<code>5%</code>的概率将标志位<code>flag</code>设置为<code>1</code>,则循环<code>100</code>次,则有<code>95</code>次<strong>浪费时间</strong>判断<code>flag</code>是否为<code>1</code>;</p><p><code>如图freeRTOS休眠唤醒</code>所示的<strong>休眠唤醒模型</strong>就避免了<code>95</code>次<strong>浪费时间</strong>判断<code>flag</code>是否为<code>1</code>,<strong>腾出时间</strong>执行<code>StartTask1</code></p><p><img src="/images/freeRTOS休眠唤醒.png" alt="freeRTOS休眠唤醒"></p><h1 id="唤醒休眠的实现原理"><a href="#唤醒休眠的实现原理" class="headerlink" title="唤醒休眠的实现原理"></a>唤醒休眠的实现原理</h1><p><strong>消息队列的核心</strong>: <strong>关中断,环形缓冲区,链表</strong><br><strong>关中断在前面已经进行了说明</strong></p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>当执行<strong>读队列的任务</strong><code>StartTask2</code>时,如果<strong>队列为空</strong>,则在<code>QueueRead</code>中执行以下操作:</p><ul><li>使<code>StartTask2</code>休眠,把任务<code>StartTask2</code>放入<code>pxDelayedTaskList</code></li><li>把任务<code>StartTask2</code>插入<code>Queue.list</code></li></ul><p>当执行<strong>写队列的任务</strong><code>StartTask1</code>,如果确实往<strong>队列</strong>中填充了数据,则在<code>QueueSend</code>中执行以下操作:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QueueSend()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 关中断</span></span><br><span class="line">    <span class="comment">// 写数据</span></span><br><span class="line">    <span class="comment">// 链表操作</span></span><br><span class="line">    <span class="comment">// 开中断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&#x1F308;其中<strong>链表操作</strong>就是把之前插入<code>Queue.list</code>的<strong>任务来唤醒</strong></p><h2 id="环形缓冲区"><a href="#环形缓冲区" class="headerlink" title="环形缓冲区"></a>环形缓冲区</h2><p><strong>环形缓冲区</strong>:通过一个数组<code>arr</code>来完成,并通过<code>writeID</code>和<code>readID</code>来标识当前<strong>读写的位置</strong>,<strong>读写完以后</strong>就执行<strong>自加操作+取余操作</strong>:</p><ul><li><code>writeID = (writeID + 1)%sizeof(arr)</code></li><li><code>readID  = (readID + 1)%sizeof(arr)</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> FreeRTOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>freeRTOS-02-任务创建</title>
      <link href="/2022/05/14/FreeRTOS/freeRTOS-02-%E4%BF%9D%E5%AD%98%E7%8E%B0%E5%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E5%9C%BA%E6%99%AF/"/>
      <url>/2022/05/14/FreeRTOS/freeRTOS-02-%E4%BF%9D%E5%AD%98%E7%8E%B0%E5%9C%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="任务创建的3个核心"><a href="#任务创建的3个核心" class="headerlink" title="任务创建的3个核心"></a>任务创建的3个核心</h1><p><strong>任务创建的3个核心</strong>:</p><ul><li><strong>任务函数</strong></li><li><strong>任务结构体</strong></li><li><strong>栈</strong></li></ul><p><code>xTaskCreate</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BaseType_t <span class="title">xTaskCreate</span><span class="params">(TaskFunction_t pxTaskCode,<span class="comment">// 任务函数</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> pcName,<span class="comment">// 任务名</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">const</span> configSTACK_DEPTH_TYPE usStackDepth,<span class="comment">// 栈大小 = usStackDepth * 4</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">void</span> * <span class="keyword">const</span> pvParameters,<span class="comment">// 任务参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">UBaseType_t uxPriority,<span class="comment">// 任务优先级</span></span></span></span><br><span class="line"><span class="params"><span class="function">TaskHandle_t * <span class="keyword">const</span> pxCreatedTask )</span><span class="comment">// TCB</span></span></span><br></pre></td></tr></table></figure></p><h2 id="任务函数"><a href="#任务函数" class="headerlink" title="任务函数"></a>任务函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*TaskFunction_t)</span><span class="params">( <span class="keyword">void</span> * )</span></span>;</span><br></pre></td></tr></table></figure><h1 id="任务创建的细节"><a href="#任务创建的细节" class="headerlink" title="任务创建的细节"></a>任务创建的细节</h1><p><img src="/images/freeRTOS_createTask.png" alt="freeRTOS_createTask"></p><p>比对<code>tskTCB</code>和<code>xTaskCreate</code>函数,提出如下问题:</p><ul><li><code>usStackDepth</code><strong>如何使用？</strong><ul><li><strong>从哪里分配？</strong></li><li><strong>大小如何确定?</strong></li></ul></li><li><strong>任务函数信息保存在哪?</strong><ul><li><code>pxTaskCode</code><strong>被保存在哪？</strong></li><li><code>pvParameters</code><strong>被保存在哪？</strong></li></ul></li></ul><h2 id="usStackDepth如何使用？"><a href="#usStackDepth如何使用？" class="headerlink" title="usStackDepth如何使用？"></a><code>usStackDepth</code><strong>如何使用？</strong></h2><h3 id="大小如何确定"><a href="#大小如何确定" class="headerlink" title="大小如何确定?"></a><strong>大小如何确定?</strong></h3><ul><li><p><strong>局部变量的大小</strong>决定了任务<strong>栈的大小</strong>;<code>如图usStackDepth所示</code>,<code>array[100]</code>和<code>temp</code>占用了<code>412 byte</code></p></li><li><p><strong>函数调用深度</strong>也决定了<strong>栈的大小</strong>;但函数里面调用了其它函数时,汇编中的<code>lr</code>寄存器会被压入<code>sp</code>指向的栈内</p></li></ul><p><img src="/images/STM32_Cortex_debug/usStackDepth.png" alt="usStackDepth"></p><p><img src="/images/STM32_Cortex_debug/usStackDepth_stack.png" alt="usStackDepth_stack"></p><h3 id="从哪里分配？"><a href="#从哪里分配？" class="headerlink" title="从哪里分配？"></a><strong>从哪里分配？</strong></h3><p>在文件<code>Middlewares\Third_Party\FreeRTOS\Source\portable\MemMang\heap_4.c</code>中定义了一个<strong>静态数组</strong><code>ucHeap</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> configTOTAL_HEAP_SIZE                    ((size_t)3072)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint8_t</span> ucHeap[ configTOTAL_HEAP_SIZE ];</span><br></pre></td></tr></table></figure><p>在<code>build\09-FreeRTOS_V1_DEMO.map</code>中说明了<code>ucHeap</code>在地址空间中的地址<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.bss.pxEnd     0x20000460        0x4 build/heap_4.o</span><br><span class="line">.bss.ucHeap    0x20000464      0xc00 build/heap_4.o</span><br><span class="line">.bss.xBlockAllocatedBit</span><br><span class="line">               0x20001064        0x4 build/heap_4.o</span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tskTaskControlBlock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">volatile</span> StackType_t*pxTopOfStack;</span><br><span class="line">ListItem_txStateListItem;</span><br><span class="line">ListItem_txEventListItem;</span><br><span class="line">UBaseType_tuxPriority;</span><br><span class="line">StackType_t*pxStack;<span class="comment">// 在ucHeap中分配的任务栈空间的起始地址</span></span><br><span class="line"><span class="keyword">char</span>pcTaskName[ configMAX_TASK_NAME_LEN ];</span><br><span class="line">&#125; tskTCB;</span><br></pre></td></tr></table></figure><h2 id="任务函数信息保存在哪"><a href="#任务函数信息保存在哪" class="headerlink" title="任务函数信息保存在哪?"></a><strong>任务函数信息保存在哪?</strong></h2><ul><li><strong>运行任务</strong>时,只需要把<strong>任务函数的地址</strong>赋值给<code>pc</code>寄存器,同时把<strong>任务需要的参数</strong>赋值给<code>r0</code>即可</li><li><strong>任务切换</strong>时,只需要把<code>CPU</code>的<code>r0-r15</code>寄存器和<strong>状态寄存器</strong>保存在<strong>任务栈内</strong>即可<br><img src="/images/STM32_Cortex_debug/pxTaskCode_pvParameters.png" alt="pxTaskCode_pvParameters"></li></ul><h1 id="任务调度机制"><a href="#任务调度机制" class="headerlink" title="任务调度机制"></a>任务调度机制</h1><h2 id="任务优先级"><a href="#任务优先级" class="headerlink" title="任务优先级"></a>任务优先级</h2><ul><li><strong>高优先级</strong>的任务<strong>先执行</strong>,可以<strong>抢占低优先级的任务</strong></li><li><strong>高优先级的任务不停止,低优先级任务永远无法执行</strong></li><li><strong>同等优先级任务,轮流执行(时间片轮转)</strong></li></ul><h2 id="任务状态"><a href="#任务状态" class="headerlink" title="任务状态"></a>任务状态</h2><ul><li><strong>运行态</strong>:<code>running</code></li><li><strong>就绪态</strong>:<code>ready</code></li><li><strong>阻塞</strong>：<code>blocked</code>-等待某个事件(事件、事件)</li><li><strong>暂停</strong>:<code>suspend</code></li></ul><h2 id="任务管理"><a href="#任务管理" class="headerlink" title="任务管理"></a>任务管理</h2><ul><li>如何取出<strong>要运行的任务</strong>?<ul><li>找到<strong>最高优先级</strong>的<strong>运行态</strong>或则<strong>就绪态</strong>(如果<strong>找到就运行该任务</strong>)</li><li>如果<strong>所有任务都平级,则轮流执行</strong>(排队,前面的先运行,后面的后运行,运行<code>1个tick</code>后<strong>被安排到链表尾部排队</strong>)</li></ul></li></ul><p><code>FreeRTOS</code>的任务链表被定义在<code>Middlewares\Third_Party\FreeRTOS\Source\tasks.c</code>中通过数组<code>pxReadyTasksLists</code>来表示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span>  &#123;</span></span><br><span class="line">  osPriorityIdle          = <span class="number">-3</span>,          <span class="comment">///&lt; priority: idle (lowest)</span></span><br><span class="line">  osPriorityLow           = <span class="number">-2</span>,          <span class="comment">///&lt; priority: low</span></span><br><span class="line">  osPriorityBelowNormal   = <span class="number">-1</span>,          <span class="comment">///&lt; priority: below normal</span></span><br><span class="line">  osPriorityNormal        =  <span class="number">0</span>,          <span class="comment">///&lt; priority: normal (default)</span></span><br><span class="line">  osPriorityAboveNormal   = +<span class="number">1</span>,          <span class="comment">///&lt; priority: above normal</span></span><br><span class="line">  osPriorityHigh          = +<span class="number">2</span>,          <span class="comment">///&lt; priority: high</span></span><br><span class="line">  osPriorityRealtime      = +<span class="number">3</span>,          <span class="comment">///&lt; priority: realtime (highest)</span></span><br><span class="line">  osPriorityError         =  <span class="number">0x84</span>        <span class="comment">///&lt; system cannot determine priority or thread has illegal priority</span></span><br><span class="line">&#125; osPriority;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> configMAX_PRIORITIES                     ( 7 ) </span></span><br><span class="line"><span class="comment">/* Lists for ready and blocked tasks. --------------------*/</span></span><br><span class="line">PRIVILEGED_DATA <span class="keyword">static</span> List_t pxReadyTasksLists[configMAX_PRIORITIES] = &#123;<span class="number">0</span>&#125;; <span class="comment">/*&lt; Prioritised ready tasks. */</span></span><br><span class="line">PRIVILEGED_DATA <span class="keyword">static</span> List_t xDelayedTaskList1 = &#123;<span class="number">0</span>&#125;; <span class="comment">/*&lt; Delayed tasks. */</span></span><br><span class="line">PRIVILEGED_DATA <span class="keyword">static</span> List_t xDelayedTaskList2 = &#123;<span class="number">0</span>&#125;; <span class="comment">/*&lt; Delayed tasks (two lists are used - one for delays that have overflowed the current tick count. */</span></span><br><span class="line">PRIVILEGED_DATA <span class="keyword">static</span> List_t *<span class="keyword">volatile</span> pxDelayedTaskList = <span class="literal">NULL</span>; <span class="comment">/*&lt; Points to the delayed task list currently being used. */</span></span><br><span class="line">PRIVILEGED_DATA <span class="keyword">static</span> List_t *<span class="keyword">volatile</span> pxOverflowDelayedTaskList = <span class="literal">NULL</span>; <span class="comment">/*&lt; Points to the delayed task list currently being used to hold tasks that have overflowed the current tick count. */</span></span><br><span class="line">PRIVILEGED_DATA <span class="keyword">static</span> List_t xPendingReadyList = &#123;<span class="number">0</span>&#125;; <span class="comment">/*&lt; Tasks that have been readied while the scheduler was suspended.  They will be moved to the ready list when the scheduler is resumed. */</span></span><br></pre></td></tr></table></figure><br>由上可知:</p><ul><li><code>freeRTOS</code>中<strong>任务等级</strong>有<code>7</code>级,被<strong>存放</strong>在<code>pxReadyTasksLists[configMAX_PRIORITIES]</code>中</li><li><code>freeRTOS</code>中有一个<strong>延时链表</strong><code>pxDelayedTaskList</code></li><li><code>freeRTOS</code>中有一个<strong>等待链表</strong><code>xPendingReadyList</code><blockquote><p>一次次地遍历链表<code>pxReadyTasksLists[6]、pxReadyTasksLists[5]、,,,、pxReadyTasksLists[0]</code>中的<strong>任务并执行</strong>;</p></blockquote></li></ul><p><code>图FreeRTOS_list</code>实现了把<strong>任务</strong>添加到<strong>就绪链表中</strong><br><img src="/images/FreeRTOS_list.png" alt="FreeRTOS_list"></p><h2 id="调度方法"><a href="#调度方法" class="headerlink" title="调度方法"></a>调度方法</h2><h3 id="谁负责取任务"><a href="#谁负责取任务" class="headerlink" title="谁负责取任务"></a>谁负责取任务</h3><p>谁<strong>负责取出</strong>链表<code>pxReadyTasksLists</code>中的任务?<br>由<code>Tick</code>中断,并在<code>Tick</code><strong>中断函数</strong>中:</p><ul><li><strong>取出</strong>下个<code>Task</code></li><li><strong>切换</strong><ul><li><strong>保存</strong>当前<code>Task</code></li><li><strong>恢复</strong>新任务<code>Task</code></li></ul></li></ul><h3 id="osDelay"><a href="#osDelay" class="headerlink" title="osDelay"></a>osDelay</h3><ul><li><strong>高优先级的任务先执行;</strong></li><li><strong>如果高优先级的任务不休眠</strong>(<strong>不</strong>调用<code>osStatus osDelay (uint32_t millisec)</code>),<strong>低优先级的任务根本没有机会执行;</strong></li><li><strong>高优先级的任务在休眠时,低优先级的任务轮流执行</strong><ul><li>高优先级的任务在休眠时,<code>freeRTOS</code>把该任务从<strong>就绪链表</strong><code>pxReadyTasksLists</code>中取出,放在<strong>延时链表</strong><code>pxDelayedTaskList</code>中;此时<code>freeRTOS</code>只会在<strong>就绪链表</strong>中取任务运行,不考虑<strong>延时链表</strong></li><li>在<code>Tick</code>中断中,会去判断<strong>延时链表</strong><code>pxDelayedTaskList</code>中的<strong>每个任务</strong>,判断<strong>延时时间</strong>是否达到;如果<strong>达到</strong>,则把<strong>该任务</strong>从<strong>延时链表</strong><code>pxDelayedTaskList</code>中取出,放回<strong>就绪链表</strong><code>pxReadyTasksLists</code>,然后在<strong>就绪链表</strong>中<strong>按照优先级顺序取任务</strong>执行</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> FreeRTOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>freeRTOS-01-任务引入_ARM架构简明教程</title>
      <link href="/2022/05/12/FreeRTOS/freeRTOS-01-%E4%BB%BB%E5%8A%A1%E5%BC%95%E5%85%A5-ARM%E6%9E%B6%E6%9E%84%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"/>
      <url>/2022/05/12/FreeRTOS/freeRTOS-01-%E4%BB%BB%E5%8A%A1%E5%BC%95%E5%85%A5-ARM%E6%9E%B6%E6%9E%84%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><strong>什么是任务</strong><br><strong>任务</strong>是<strong>运行起来的函数</strong></p><ul><li><strong>一段代码</strong>:保存在<code>flash</code>上(不仅仅是代码)</li><li><strong>运行位置</strong>:</li><li><strong>运行的环境</strong></li></ul><p>要理解任务,先了解<code>ARM</code>架构</p><h1 id="ARM架构"><a href="#ARM架构" class="headerlink" title="ARM架构"></a><code>ARM</code>架构</h1><h2 id="常用汇编指令"><a href="#常用汇编指令" class="headerlink" title="常用汇编指令"></a>常用汇编指令</h2><ul><li><p><strong>读</strong>-<code>Load</code>:</p><ul><li><code>LDR</code> -<strong>读4个字节</strong>: <code>LDR R0, [addr]</code> 从地址<code>addr</code>读到<code>R0</code></li><li><code>LDRH</code>-<strong>读2个字节</strong>: <code>LDRH R0, [addr]</code></li><li><code>LDRB</code>-<strong>读1个字节</strong>: <code>LDRB R0, [addr]</code></li><li><code>POP</code> -<strong>读指令</strong>:<code>pop &#123;R3,PC&#125;</code> </li></ul></li><li><p><strong>写</strong>-<code>Store</code>:</p><ul><li><code>STR</code>-<strong>写</strong>:<code>STR R0, [addr]</code> 把<code>R0</code>的值写入地址<code>addr</code></li></ul></li><li><p><strong>计算</strong>:</p><ul><li><code>ADD</code>:<code>ADD R0,R1,R2</code> - <code>R0 = R1 + R2</code></li><li><code>SUB</code>:<code>SUB R1,R1,R2</code> - <code>R1 = R1 - R2</code></li></ul></li><li><p><strong>写内存指令</strong>-<code>push</code>:</p><ul><li><code>push</code>:<code>push &#123;R3, LR&#125;</code>-按照<strong>栈</strong><code>sp</code>给定的<strong>地址写内存</strong></li></ul></li><li><strong>赋值指令</strong>-<code>movs</code>:<ul><li><code>movs</code>:<code>movs r3 #0</code>-把<code>0</code>赋值给<code>r3</code></li></ul></li></ul><p><code>push &#123;R3, LR&#125;</code><strong>过程</strong>:</p><ul><li>把<code>r14</code>即<code>lr</code>寄存器的值<strong>写入</strong><code>sp</code>，同时执行<code>sp=sp-4</code></li><li>把<code>r3</code>寄存器的值<strong>写入</strong><code>sp</code>，同时执行<code>sp=sp-4</code><br><img src="/images/STM32_Instruct_push.png" alt="STM32_Instruct_push"><blockquote><p><strong>低标号的寄存器</strong>写入<strong>栈的低地址</strong>,所以<code>push</code>后的<strong>花括号内的顺序无所谓</strong>;这里<code>lr</code>是<code>r14</code></p></blockquote></li></ul><p><code>pop &#123;R3, pc&#125;</code><strong>过程</strong>,该过程与<code>push</code>过程<strong>相反</strong>:</p><ul><li><code>r3=[sp]</code>,同时<code>sp=sp+4</code></li><li><code>pc=[sp]</code>,同时<code>sp=sp+4</code></li></ul><p><code>push</code>和<code>pop</code>的流程刚好与栈的概念相符合:</p><ul><li><strong>栈区的使用</strong>是<strong>从高地址到低地址</strong></li><li><strong>栈区的使用</strong>遵循<strong>先进后出,后进先出</strong></li><li><strong>栈区的放置</strong>是<strong>从高地址往低地址放置</strong>(<strong>push压栈</strong>)</li><li><strong>删除是从低往高删除</strong>(<strong>pop出栈</strong>)<br><br></li></ul><h2 id="STM32寄存器"><a href="#STM32寄存器" class="headerlink" title="STM32寄存器"></a>STM32寄存器</h2><p><code>STM32</code>的<code>r</code>寄存器有<code>15</code>个,<code>如图STM32寄存器所示</code>,其中:</p><ul><li><code>r13</code>的<strong>别名</strong>为<code>sp</code>(<strong>栈</strong>)</li><li><code>r14</code>的<strong>别名</strong>为<code>lr</code>(<strong>返回地址</strong>)</li><li><code>r15</code>的<strong>别名</strong>为<code>pc</code>(<strong>当前指令地址</strong>)</li></ul><p><img src="/images/STM32寄存器.png" alt="STM32寄存器"></p><h1 id="a-a-b流程"><a href="#a-a-b流程" class="headerlink" title="a = a + b流程"></a><code>a = a + b</code>流程</h1><p><code>freeRTOS</code>中使用<code>ucheap</code><strong>巨大的数组</strong>来当做<strong>栈使用</strong><br><strong>被定义</strong>在<code>Middlewares\Third_Party\FreeRTOS\Source\portable\MemMang\heap_4.c</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> configTOTAL_HEAP_SIZE                    ((size_t)3072)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint8_t</span> ucHeap[ configTOTAL_HEAP_SIZE ];</span><br></pre></td></tr></table></figure><br>由<code>build\09-FreeRTOS_V1_DEMO.map</code>可知,<strong>栈</strong><code>ucHeap</code>的<strong>起始地址</strong>为<code>0x20000464</code>,而下一个<code>segment-.bss.xBlockAllocatedBit</code>的<strong>起始地址</strong>为<code>0x20001064</code>;<strong>计算可知</strong><code>0x20001064-0x20000464 = 0xc00 = 3072</code>,这<strong>与代码中分配的内存空间大小相符合;</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.bss.pxEnd     0x20000460        0x4 build/heap_4.o</span><br><span class="line">.bss.ucHeap    0x20000464      0xc00 build/heap_4.o</span><br><span class="line">.bss.xBlockAllocatedBit</span><br><span class="line">               0x20001064        0x4 build/heap_4.o</span><br></pre></td></tr></table></figure></p><p>以如下函数的执行过程描述<strong>汇编指令的运行过程</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* USER CODE END Header_LED0_Turnover_run */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LED0_Turnover_run</span><span class="params">(<span class="keyword">void</span> <span class="keyword">const</span> *argument)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* USER CODE BEGIN LED0_Turnover_run */</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">uint16_t</span> counterLT = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Infinite loop */</span></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    add_val(&amp;a, &amp;b);</span><br><span class="line">    counterLT++;</span><br><span class="line">    osDelay(<span class="number">400</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* USER CODE END LED0_Turnover_run */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private application code --------------------------------------------------*/</span></span><br><span class="line"><span class="comment">/* USER CODE BEGIN Application */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_val</span><span class="params">(<span class="keyword">int</span> *pa, <span class="keyword">int</span> *pb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">int</span> temp;</span><br><span class="line">  temp = *pa;</span><br><span class="line">  temp += *pb;</span><br><span class="line">  *pa = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* USER CODE END Application */</span></span><br></pre></td></tr></table></figure></p><p><code>STM32</code>内部的<code>ARM</code>框架如下图所示:<br><img src="/images/STM32_ARM.png" alt="STM32_ARM"><br>以下内容不是非常严谨(地址和<code>value</code>有混淆的地方),但大致流程是对的;</p><h2 id="breakpoint-1"><a href="#breakpoint-1" class="headerlink" title="breakpoint 1"></a><code>breakpoint 1</code></h2><p><img src="/images/STM32_Cortex_debug/1.png" alt="breakpoint 1"></p><ul><li>由上图可知,寄存器<code>sp</code>为<code>0x200008d0 &lt;ucHeap+1132&gt;</code></li><li>在汇编指令<code>0x0800 03ce</code>中将<strong>返回值寄存器</strong><code>lr</code>压入<code>sp</code>(同时<code>sp=sp-4</code>,此时<code>sp = 0x200008cc &lt;ucHeap+1128&gt;</code>)</li><li>在汇编指令<code>0x0800 03d0</code>中,<code>sp = sp - #20</code>,此时<code>sp = 0x200008b8 &lt;ucHeap+1108&gt;</code></li></ul><p><img src="/images/STM32_Cortex_debug/1_expect_stack.png" alt="执行完breakpoint 1后stack应该如"></p><h2 id="breakpoint-2"><a href="#breakpoint-2" class="headerlink" title="breakpoint 2"></a><code>breakpoint 2</code></h2><p><img src="/images/STM32_Cortex_debug/2.png" alt="breakpoint 2"></p><ul><li>在汇编指令<code>0x0800 03d2</code>中,给寄存器<code>r3</code>赋<code>0</code></li><li>在汇编指令<code>0x0800 03d4</code>中,把寄存器<code>r3</code><strong>赋值到栈</strong><code>[sp + 14]</code>,这应该是把<code>counterLT</code>放在栈<code>[sp + 14]</code>开始的<code>2</code>个字节,同时赋初值<code>0</code>;所以<code>counterLT</code>的地址为<code>0x200008b8 + #14 = 0x200008c6 &lt;ucHeap+1122&gt;</code></li></ul><p><img src="/images/STM32_Cortex_debug/2_expect_stack.png" alt="执行完breakpoint 2后stack应该如"></p><h2 id="breakpoint-3"><a href="#breakpoint-3" class="headerlink" title="breakpoint 3"></a><code>breakpoint 3</code></h2><p><img src="/images/STM32_Cortex_debug/3.png" alt="breakpoint 3"></p><ul><li>在汇编指令<code>0x0800 03d8</code>中,给寄存器<code>r3</code>赋<code>1</code></li><li>在汇编指令<code>0x0800 03da</code>中,把寄存器<code>r3</code>写入<strong>栈</strong><code>[sp + #8]</code>,即把变量<code>a</code>放在<code>[sp + #8] = 0x200008c0 &lt;ucHeap+1116&gt;</code></li><li>在汇编指令<code>0x0800 03dc</code>中,把寄存器<code>r3</code>写入<strong>栈</strong><code>[sp + #4]</code>,即把变量<code>a</code>放在<code>[sp + #8] = 0x200008bc &lt;ucHeap+1112&gt;</code></li></ul><p><img src="/images/STM32_Cortex_debug/3_expect_stack.png" alt="执行完breakpoint 3后stack应该如"></p><h2 id="breakpoint-4"><a href="#breakpoint-4" class="headerlink" title="breakpoint 4"></a><code>breakpoint 4</code></h2><p><img src="/images/STM32_Cortex_debug/4.png" alt="breakpoint 4"></p><ul><li>在汇编指令<code>0x0800 03de</code>中,把<strong>栈</strong><code>[sp + #4]</code>(<code>变量b的地址</code>)写入寄存器<code>r1</code></li><li>在汇编指令<code>0x0800 03e0</code>中,把<strong>栈</strong><code>[sp + #8]</code>(<code>变量a的地址</code>)写入寄存器<code>r0</code></li><li>在汇编指令<code>0x0800 03e2</code>中,使用<code>bl</code>跳转到函数<code>add_val</code>,并把<code>0x800,03E7</code>保存在返回寄存器<code>lr</code></li></ul><blockquote><p>在调用<code>c</code>函数时,默认第一个参数<code>a</code>保存在<code>r0</code>,第二个参数<code>b</code>保存在<code>r1</code></p></blockquote><p><img src="/images/STM32_Cortex_debug/4_expect_stack.png" alt="执行完breakpoint 4后stack应该如"></p><h2 id="breakpoint-5"><a href="#breakpoint-5" class="headerlink" title="breakpoint 5"></a><code>breakpoint 5</code></h2><p><img src="/images/STM32_Cortex_debug/5.png" alt="breakpoint 5"></p><ul><li>在汇编指令<code>0x0800 03b8</code>中,把<strong>寄存器</strong><code>sp</code><strong>自减为</strong><code>sp = sp - #8 = 0x200008b0 &lt;ucHeap+1100&gt;</code></li></ul><p><img src="/images/STM32_Cortex_debug/5_expect_stack.png" alt="执行完breakpoint 5后stack应该如"></p><h2 id="breakpoint-6"><a href="#breakpoint-6" class="headerlink" title="breakpoint 6"></a><code>breakpoint 6</code></h2><p><img src="/images/STM32_Cortex_debug/6.png" alt="breakpoint 6"></p><ul><li>在汇编指令<code>0x0800 03ba</code>中,把<strong>寄存器</strong><code>r0</code>(变量<code>a</code>的地址)加载到<code>r3</code>中</li><li>在汇编指令<code>0x0800 03bc</code>中,把<strong>寄存器</strong><code>r3</code>(变量<code>a</code>的地址)写入<strong>栈</strong><code>[ sp + #4]</code>(地址对应栈的数据),相当于<code>temp = *pa</code>,<code>temp</code>的栈地址为<code>[ sp + #4] = 0x200008b4 &lt;ucHeap+1104&gt;</code></li></ul><p><img src="/images/STM32_Cortex_debug/6_expect_stack.png" alt="执行完breakpoint 6后stack应该如"></p><h2 id="breakpoint-7"><a href="#breakpoint-7" class="headerlink" title="breakpoint 7"></a><code>breakpoint 7</code></h2><p><img src="/images/STM32_Cortex_debug/7.png" alt="breakpoint 7"></p><ul><li>在汇编指令<code>0x0800 03be</code>中,加载<code>r1</code>(变量<code>b</code>的地址)到<code>r3</code></li><li>在汇编指令<code>0x0800 03c0</code>中,加载<code>[ sp + #4]</code>(变量<code>temp</code>)到<code>r2</code></li><li>在汇编指令<code>0x0800 03c2</code>中,<code>r3 = r3 + temp = b + temp = b + a</code></li><li>在汇编指令<code>0x0800 03c4</code>中,把<code>r3</code>写入<code>[ sp + #4 ]</code>,即写入<strong>栈</strong>内的<code>temp</code></li></ul><p><img src="/images/STM32_Cortex_debug/7_expect_stack.png" alt="执行完breakpoint 7后stack应该如"></p><h2 id="breakpoint-8"><a href="#breakpoint-8" class="headerlink" title="breakpoint 8"></a><code>breakpoint 8</code></h2><p><img src="/images/STM32_Cortex_debug/8.png" alt="breakpoint 8"></p><ul><li>在汇编指令<code>0x0800 03c6</code>中,把栈内<code>[ sp + #4 ]</code>(<code>变量temp</code>)读入到<code>r3</code></li><li>在汇编指令<code>0x0800 03c8</code>中,把<code>r3</code>写入<code>r0 + #0</code>(变量<code>a</code>的地址)</li></ul><p><img src="/images/STM32_Cortex_debug/8_expect_stack.png" alt="执行完breakpoint 8后stack应该如"></p><h2 id="breakpoint-9"><a href="#breakpoint-9" class="headerlink" title="breakpoint 9"></a><code>breakpoint 9</code></h2><p><img src="/images/STM32_Cortex_debug/9.png" alt="breakpoint 9"></p><ul><li>在汇编指令<code>0x0800 03ca</code>中, 将<code>sp = sp + #8 = 0x200008b8 &lt;ucHeap+1108&gt;</code></li><li>在汇编指令<code>0x0800 03cc</code>中,跳转到<code>lr</code>(返回值-执行<code>add_val</code>)</li></ul><p><img src="/images/STM32_Cortex_debug/9_expect_stack.png" alt="执行完breakpoint 9后stack应该如"></p><h1 id="函数运行环境"><a href="#函数运行环境" class="headerlink" title="函数运行环境"></a>函数运行环境</h1><p>从<strong>汇编的角度</strong>理解<code>c</code>函数的<strong>运行过程</strong>后,<strong>如果有以下过程</strong>:</p><ul><li>执行<code>0x0800 03ba</code>,从<code>r0</code>指向的<strong>栈内取值</strong>-读变量<code>a</code></li><li>被打断, <code>0x0800 03bc</code>没能被执行,则<code>temp = *pa</code>没被执行完成<br><strong>此时如何保存现场</strong>:此时应该保存<code>r0</code>的值</li></ul><p><img src="/images/STM32_Cortex_debug/interrupt.png" alt="interrupt"></p><h2 id="什么是现场"><a href="#什么是现场" class="headerlink" title="什么是现场"></a>什么是现场</h2><p><strong>现场</strong>就是<strong>被中断</strong>时<code>CPU</code>内部的<strong>寄存器</strong><code>r0-r15</code>和<strong>状态寄存器</strong>的<strong>值</strong></p><h2 id="怎么保存"><a href="#怎么保存" class="headerlink" title="怎么保存"></a>怎么保存</h2><p>把<code>CPU</code>内部的<strong>寄存器</strong><code>r0-r15</code>和<strong>状态寄存器</strong>的<strong>值</strong>保存到<strong>该任务的栈内</strong></p><p>所以<strong>任务=函数+现场(栈)</strong>,即<strong>运行中的函数</strong></p><h1 id="保存现场的几种场景"><a href="#保存现场的几种场景" class="headerlink" title="保存现场的几种场景"></a>保存现场的几种场景</h1><h2 id="硬件中断"><a href="#硬件中断" class="headerlink" title="硬件中断"></a>硬件中断</h2><p><code>stm32</code>的<strong>硬件中断</strong>,<strong>当发硬件中断时,同样要保存当前的现场,处理中断,然后恢复中断;</strong><br>对应<code>F103,Cortex,M3,M4</code>,保存逻辑如下:</p><ul><li>硬件保存一部分:<code>R0,R1,R2</code></li><li>软件保存一部分:一些用到的寄存器</li></ul><h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p><code>funA</code>调用<code>funB</code>,<strong>同样要保存当前的现场,处理funB,然后恢复中断;</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  funB();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>函数调用中<code>r0,r1,r2</code>被用来传递参数,保存现场时不需要保存</p><h2 id="任务切换"><a href="#任务切换" class="headerlink" title="任务切换"></a>任务切换</h2><p>任务切换时,<code>CPU</code>的<strong>所有寄存器都会被保存</strong></p>]]></content>
      
      
      <categories>
          
          <category> FreeRTOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32-F103ZET6-13-DMA</title>
      <link href="/2022/05/08/Embedded-System-00/STM32-F103ZET6-13-DMA/"/>
      <url>/2022/05/08/Embedded-System-00/STM32-F103ZET6-13-DMA/</url>
      
        <content type="html"><![CDATA[<h1 id="DMA简介"><a href="#DMA简介" class="headerlink" title="DMA简介"></a>DMA简介</h1><p><code>DMA</code>全称<code>Direct Memory Access</code>,即<strong>直接存储器访问</strong>。<br><code>DMA</code>传输将<strong>数据</strong>从<strong>一个地址空间</strong>复制到<strong>另一个地址空间</strong>。当<code>CPU</code>初始化这个<strong>传输动作</strong>,<strong>传输动作本身</strong>是由<code>DMA</code>控制器来<strong>实现和完成</strong>的。<br><code>DMA</code>传输方式<strong>无需</strong><code>CPU</code>直接<strong>控制传输</strong>,也<strong>没有中断处理</strong>方式那样<strong>保留现场和恢复现场</strong>过程,通过硬件为<code>RAM</code>和<code>IO</code>设备<strong>开辟一条直接传输数据</strong>的通道,使得<code>CPU</code>的效率大大提高。</p><blockquote><p>作用:为<code>CPU</code>减负。</p></blockquote><h1 id="DMA原理"><a href="#DMA原理" class="headerlink" title="DMA原理"></a>DMA原理</h1><p><code>STM32</code>最多有<code>2</code>个<code>DMA</code>控制器(<code>DMA2</code>仅存在大容量产品中)</p><ul><li><code>DMA1</code>有<code>7</code>个通道</li><li><code>DMA2</code>有<code>5</code>个通道</li></ul><p>每个通道专门用来管理来自于<strong>一个或多个外设对存储器访问</strong>的请求。还有<strong>一个仲裁</strong>起来<strong>协调</strong>各个<code>DMA</code>请求的<strong>优先权</strong>。</p><h2 id="DMA框图"><a href="#DMA框图" class="headerlink" title="DMA框图"></a>DMA框图</h2><p><img src="/images/DMA_block_diagram.png" alt="DMA block diagram in low-, medium- high- and XL-density devices"></p><ul><li><code>Arbiter</code>:仲裁器</li><li><code>AHB Slave</code>:<code>AHB</code>从设备</li></ul><h2 id="STM32的DMA的特性"><a href="#STM32的DMA的特性" class="headerlink" title="STM32的DMA的特性"></a>STM32的DMA的特性</h2><ul><li>每个通道都直接连接专用的硬件DMA请求,都支持软件触发,这些通过软件来配置。</li><li>在七个请求间的<strong>优先权可以通过软件编程</strong>设置(共有四级:很高、高、中等和低)，假如在相等优先权时由硬件决定(请求0优先于请求1，依此类推) 。 </li><li><strong>独立的源和目标数据区</strong>的传输宽度(字节、半字、全字),模拟打包和拆包的过程。源<br>  和目标地址必须按数据传输宽度对齐。 </li><li>支持<strong>循环的缓冲器管理</strong> </li><li>每个通道都有<code>3</code>个事件标志(<code>DMA</code> 半传输,<code>DMA</code>传输完成和<code>DMA</code>传输出错)，<br>  这<code>3</code>个事件标志逻辑或成为一个单独的中断请求。 </li><li>外设和存储器，存储器和外设的传输,存储器和存储器间的传输</li><li>闪存、<code>SRAM</code>、外设的<code>SRAM</code>、<code>APB1</code> <code>APB2</code>和<code>AHB</code>外设均可作为访问的源和目标。 </li><li>可编程的数据传输数目：最大为<code>65536</code></li></ul><h2 id="DMA的各通道"><a href="#DMA的各通道" class="headerlink" title="DMA的各通道"></a>DMA的各通道</h2><p><img src="/images/DMA1_requests.png" alt="Summary of DMA1 requests for each channel"></p><p><img src="/images/DMA2_requests.png" alt="Summary of DMA2 requests for each channel"></p><h2 id="DMA处理"><a href="#DMA处理" class="headerlink" title="DMA处理"></a>DMA处理</h2><p>每次<code>DMA</code>传送由<code>3</code>个<strong>操作组成</strong>:</p><ul><li>从<strong>外设数据寄存器</strong>或者从当<strong>前外设/存储器地址寄存器</strong>指示的存储器地址<strong>取数据</strong>,第一次传输时的<strong>开始地址</strong>是<code>DMA_CPARx</code>或<code>DMA_CMARx</code>寄存器指定的<strong>外设基地址或存储器单元</strong>。</li><li><strong>存数据</strong>到<strong>外设数据寄存器</strong>或者<strong>当前外设/存储器地址寄存器</strong>指示的存储器地址,第一次传输时的<strong>开始地址</strong>是<code>DMA_CPARx</code>或<code>DMA_CMARx</code>寄存器指定的<strong>外设基地址或存储器单元</strong>。</li><li>执行一次<code>DMA_CNDTRx</code>寄存器的<strong>递减操作</strong>,该寄存器包含<strong>未完成的操作数目</strong>。</li></ul><p>两个重要的寄存器地址:</p><ul><li><code>DMA</code>通道<code>x</code><strong>外设地址</strong>寄存器(<code>DMA_CPARx</code>)(<code>x = 1…7</code>)-<code>32 bit</code></li><li><code>DMA</code>通道<code>x</code><strong>存储器地址</strong>寄存器(<code>DMA_CMARx</code>)(<code>x = 1…7</code>)-<code>32 bit</code></li></ul><h2 id="配置DMA的寄存器"><a href="#配置DMA的寄存器" class="headerlink" title="配置DMA的寄存器"></a>配置DMA的寄存器</h2><ul><li><code>DMA</code>通道<code>x</code>配置寄存器(<code>DMA_CCRx</code>)(<code>x = 1…7</code>)-<code>32 bit</code><ul><li><code>bit[0]-EN</code>:是否使能通道<code>x</code></li><li><code>bit[1]-TCIE</code>:允许传输完成中断(<code>Transfer complete interrupt enable</code>)</li><li><code>bit[2]-HTIE</code>:允许半传输完成中断(<code>Half transfer interrupt enable</code>)</li><li><code>bit[3]-TEIE</code>:允许传输错误中断(<code>Transfer error interrupt enable</code>)</li><li><code>bit[4]-DIR</code>:数据传输方向(<code>Data transfer direction</code>)</li><li><code>bit[5]-CIRC</code>:循环模式(<code>Circular mode</code>)</li><li><code>bit[6]-PINC</code>:外设地址增量模式 (<code>Peripheral increment mode</code>)</li><li><code>bit[7]-MINC</code>:存储器地址增量模式 (<code>Memory increment mode</code>)</li><li><code>bit[9:8]-PSIZE[1:0]</code>:外设数据宽度 (<code>Peripheral size</code>)</li><li><code>bit[11:10]-MSIZE[1:0]</code>:存储器数据宽度 (<code>Memory size</code>)</li><li><code>bit[13:12]-PL[1:0]</code>:通道优先级 (<code>Channel priority level</code>)</li><li><code>bit[14]-MEM2MEM</code>:存储器到存储器模式 (<code>Memory to memory mode</code>)</li></ul></li></ul><blockquote><p><strong>存储器到存储器模式</strong>与<strong>循环模式</strong>不能同时使用</p></blockquote><h2 id="配置DMA的传输数据量"><a href="#配置DMA的传输数据量" class="headerlink" title="配置DMA的传输数据量"></a>配置DMA的传输数据量</h2><ul><li><code>DMA</code>通道<code>x</code>传输数量寄存器(<code>DMA_CNDTRx</code>)(<code>x = 1…7</code>)-<code>16 bit</code><ul><li><strong>数据传输数量</strong>为<code>0</code>至<code>65535</code></li></ul></li></ul><h2 id="通道配置过程"><a href="#通道配置过程" class="headerlink" title="通道配置过程"></a>通道配置过程</h2><p>下面是配置<code>DMA</code>通道<code>x</code>的过程(<code>x</code>代表<strong>通道号</strong>):</p><ul><li>在<code>DMA_CPARx</code><strong>寄存器中设置外设寄存器的地址</strong>。发生<strong>外设数据传输请求</strong>时,这个地址将是数据传输的<strong>源或目标</strong>。</li><li>在<code>DMA_CMARx</code>寄存器中设置<strong>数据存储器的地址</strong>。发生<strong>外设数据传输请求</strong>时，传输的数据将从<strong>这个地址读出或写入这个地址</strong>。</li><li>在<code>DMA_CNDTRx</code>寄存器中设置要<strong>传输的数据量</strong>。在每个数据传输后,这个<strong>数值递减</strong>。</li><li>在<code>DMA_CCRx</code>寄存器的<code>PL[1:0]</code>位中设置<strong>通道的优先级</strong>。</li><li>在<code>DMA_CCRx</code>寄存器中设置数据传输的<strong>方向、循环模式、外设和存储器的增量模式、外设和存储器的数据宽度、传输一半产生中断或传输完成产生中断</strong>。</li><li>设置<code>DMA_CCRx</code>寄存器的<code>ENABLE</code>位,<strong>启动该通道</strong>。</li></ul><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><h3 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h3><ul><li><code>DMA</code>初始化<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_DMA_ALL_PERIPH(PERIPH) (((PERIPH) == DMA1_Channel1) || \</span></span><br><span class="line"><span class="meta">                                   ((PERIPH) == DMA1_Channel2) || \</span></span><br><span class="line"><span class="meta">                                   ((PERIPH) == DMA1_Channel3) || \</span></span><br><span class="line"><span class="meta">                                   ((PERIPH) == DMA1_Channel4) || \</span></span><br><span class="line"><span class="meta">                                   ((PERIPH) == DMA1_Channel5) || \</span></span><br><span class="line"><span class="meta">                                   ((PERIPH) == DMA1_Channel6) || \</span></span><br><span class="line"><span class="meta">                                   ((PERIPH) == DMA1_Channel7) || \</span></span><br><span class="line"><span class="meta">                                   ((PERIPH) == DMA2_Channel1) || \</span></span><br><span class="line"><span class="meta">                                   ((PERIPH) == DMA2_Channel2) || \</span></span><br><span class="line"><span class="meta">                                   ((PERIPH) == DMA2_Channel3) || \</span></span><br><span class="line"><span class="meta">                                   ((PERIPH) == DMA2_Channel4) || \</span></span><br><span class="line"><span class="meta">                                   ((PERIPH) == DMA2_Channel5))</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span> DMA_PeripheralBaseAddr; <span class="comment">// 外设基地址</span></span><br><span class="line">  <span class="keyword">uint32_t</span> DMA_MemoryBaseAddr;     <span class="comment">// 存储器基地址</span></span><br><span class="line">  <span class="keyword">uint32_t</span> DMA_DIR;                <span class="comment">// DMA传输方向</span></span><br><span class="line">  <span class="keyword">uint32_t</span> DMA_BufferSize;         <span class="comment">// 通道传输数据量</span></span><br><span class="line">  <span class="keyword">uint32_t</span> DMA_PeripheralInc;      <span class="comment">// 外设增量模式</span></span><br><span class="line">  <span class="keyword">uint32_t</span> DMA_MemoryInc;          <span class="comment">// 存储器增量模式</span></span><br><span class="line">  <span class="keyword">uint32_t</span> DMA_PeripheralDataSize; <span class="comment">// 外设数据宽度 8/16/32</span></span><br><span class="line">  <span class="keyword">uint32_t</span> DMA_MemoryDataSize;     <span class="comment">// 存储器数据宽度 8/16/32</span></span><br><span class="line">  <span class="keyword">uint32_t</span> DMA_Mode;               <span class="comment">// 是否循环模式</span></span><br><span class="line">  <span class="keyword">uint32_t</span> DMA_Priority;           <span class="comment">// 优先级</span></span><br><span class="line">  <span class="keyword">uint32_t</span> DMA_M2M;                <span class="comment">// 是否存储器=&gt;存储器</span></span><br><span class="line">&#125;DMA_InitTypeDef;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DMA_Init</span><span class="params">(DMA_Channel_TypeDef* DMAy_Channelx, DMA_InitTypeDef* DMA_InitStruct)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><h2 id="串口DMA发送实验"><a href="#串口DMA发送实验" class="headerlink" title="串口DMA发送实验"></a>串口DMA发送实验</h2><h3 id="标准库的DMA配置过程"><a href="#标准库的DMA配置过程" class="headerlink" title="标准库的DMA配置过程"></a>标准库的DMA配置过程</h3><ul><li>使能<code>DMA/串口</code>时钟<code>RCC_AHBPeriphClockCmd();</code></li><li>初始化<code>DMA</code>通道参数<code>DMA_Init();</code></li><li>使能串口<code>DMA</code>发送,串口<code>DMA</code>使能函数<code>USART_DMACmd();</code></li><li>使能<code>DMA1</code>通道,启动传输。<code>DMA_Cmd();</code></li><li>查询<code>DMA</code>传输状态<code>DMA_GetFlagStatus();</code></li><li>获取/设置通道当前剩余数据量：<ul><li><code>DMA_GetCurrDataCounter();</code></li><li><code>DMA_SetCurrDataCounter();</code></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32-F103ZET6-12-SPI</title>
      <link href="/2022/04/18/Embedded-System-00/STM32-F103ZET6-12-SPI/"/>
      <url>/2022/04/18/Embedded-System-00/STM32-F103ZET6-12-SPI/</url>
      
        <content type="html"><![CDATA[<h1 id="SPI接口简介"><a href="#SPI接口简介" class="headerlink" title="SPI接口简介"></a>SPI接口简介</h1><p><code>SPI</code>(<code>Serial Peripheral interface</code>)是<strong>串行外围设备接口</strong>,是<code>Motorola</code>首先在其<code>MC68HCXX</code>系列<strong>处理器上定义</strong>的。</p><p><code>SPI</code>是一种<strong>高速的、全双工、同步的</strong>通信总线,并且在芯片的管脚上<strong>只占用四根线</strong>,节约了芯片的管脚,同时为<code>PCB</code>的布局上节省空间,提供方便,主要应用在 <code>EEPROM</code>、<code>FLASH</code>、实时时钟、<code>AD</code>转换器,还有<strong>数字信号处理器</strong>和<strong>数字信号解码器</strong>之间。</p><blockquote><p>发送引脚、接收引脚、时钟引脚和片选引脚,片选引脚用作多个<code>SPI</code>设备</p></blockquote><h2 id="SPI内部结构简明图"><a href="#SPI内部结构简明图" class="headerlink" title="SPI内部结构简明图"></a><strong>SPI</strong>内部结构简明图</h2><p><img src="/images/SPI-Frame.png" alt="SPI框图"></p><ul><li><code>SPI</code>接口一般使用<code>4</code>条线<strong>通信</strong>:<ul><li><code>MISO</code><strong>主设备数据输入</strong>,<strong>从设备数据输出</strong></li><li><code>MOSI</code><strong>主设备数据输出</strong>,<strong>从设备数据输入</strong></li><li><code>SCLK</code><strong>时钟信号</strong>,<strong>由主设备产生</strong></li><li><code>CS</code><strong>从设备片选信号</strong>,<strong>由主设备控制</strong></li></ul></li></ul><h2 id="SPI工作原理总结"><a href="#SPI工作原理总结" class="headerlink" title="SPI工作原理总结"></a><strong>SPI</strong>工作原理总结</h2><ul><li>硬件上为<code>4</code>根线</li><li>主机和从机都有一个<strong>串行移位寄存器</strong>,主机通过向它的<code>SPI</code><strong>串行寄存器</strong>写入<strong>一个字节</strong>来<strong>发起一次传输</strong></li><li><strong>串行移位寄存器</strong>通过<code>MOSI</code>信号线<strong>将字节传送给从机</strong>,<strong>从机</strong>也将自己的<strong>串行移位寄存器中的内容</strong>通过<code>MISO</code>信号线<strong>返回给主机</strong>。这样,<strong>两个移位寄存器中的内容就被交换</strong></li><li>外设的<strong>写操作和读操作</strong>是<strong>同步完成的</strong>,如果<strong>只进行写操作</strong>,主机只需忽略接收到的字节;反之,若主机<strong>要读取从机的一个字节</strong>,就必须<strong>发送一个空字节来引发从机的传输</strong></li></ul><p><img src="/images/SPI_shifRegister.png" alt="SPI移位寄存器"></p><h2 id="STM32’s-SPI的特点"><a href="#STM32’s-SPI的特点" class="headerlink" title="STM32’s SPI的特点"></a>STM32’s SPI的特点</h2><p><code>STM32 SPI</code>接口可配置为支持<code>SPI</code>协议或者支持<code>I2S</code>音频协议,默认是<code>SPI</code>模式。可以通过<strong>软件</strong>切换到<code>I2S</code>方式</p><ul><li><code>3</code>线全双工同步传输</li><li>带或不带第三根双向数据线的双线单工同步传输</li><li><code>8</code>或<code>16</code>位<strong>传输帧格式</strong>选择,<strong>由</strong>寄存器<code>SPI_CR1</code>的<code>bit[11](DFF)</code>决定<ul><li><code>0</code>：使用<code>8</code>位<strong>数据帧格式进行发送/接收</strong> </li><li><code>1</code>：使用<code>16</code>位<strong>数据帧格式进行发送/接收</strong></li></ul></li><li>主或从操作</li><li>支持多主模式</li><li><code>8</code>个主模式波特率预分频系数(最大为$f_{PCLK}/2$)</li><li>从模式频率 (最大为$f_{PCLK}/2$)</li><li>主模式和从模式的快速通信</li><li>主模式和从模式下均可以<strong>由软件或硬件</strong>进行<code>NSS</code>管理：主/从操作模式的动态改变<ul><li><strong>软件层面</strong>对<code>NSS</code>管理:如<code>SPI</code>框图右图所示,可以指定<code>PA0、PA1、PA2</code>为<code>STM32</code>的片选引脚,分别与相应的<code>SPI</code>设备的片选引脚相连,通过<strong>代码来指定引脚的下拉状态</strong>实现与哪个<code>SPI</code>设备通信</li><li><strong>硬件层面</strong>对<code>NSS</code>管理:通过<code>SPI</code>指定的片选引脚与硬件指定<code>SPI</code>设备相连</li></ul></li><li>可编程的<strong>时钟极性</strong>和<strong>相位</strong> <code>参考STM32中文参考手册-23.5.1 SPI控制寄存器1</code><ul><li>寄存器<code>SPI_CR1</code>的<code>bit[1](CPOL)</code>：时钟极性<code>(Clock polarity)</code><ul><li><code>0</code>： 空闲状态时,<code>SCK</code>保持<strong>低电平</strong> </li><li><code>1</code>： 空闲状态时,<code>SCK</code>保持<strong>高电平</strong></li></ul></li><li>寄存器<code>SPI_CR1</code>的<code>bit[0](CPHA)</code>：时钟相位<code>(Clock phase)</code> <ul><li><code>0</code>： <strong>数据采样</strong>从<strong>第一个时钟边沿</strong>开始</li><li><code>1</code>： <strong>数据采样</strong>从<strong>第二个时钟边沿</strong>开始</li></ul></li><li><code>SPI</code>的<strong>时钟极性</strong>和<strong>相位</strong>以<code>SPI</code>从机<strong>要求为准</strong></li></ul></li></ul><p><img src="/images/SPI时钟序.png" alt="SPI时钟序"></p><ul><li>可编程的<strong>数据顺序</strong>,<code>MSB</code>在前或<code>LSB</code>在前<strong>由</strong>寄存器<code>SPI_CR1</code>的<code>bit[7](LSBFIRST)</code>决定<ul><li><code>0</code>：先发送<code>MSB</code> </li><li><code>1</code>：先发送<code>LSB</code></li></ul></li><li>可触发中断的专用发送和接收标志<br><img src="/images/SPI中断.png" alt="SPI中断"></li><li><code>SPI</code>总线<strong>状态标志</strong><ul><li>忙标识<code>BSY</code></li><li>发送缓存空标志位(<code>TXE</code>) </li><li>接收缓存非空标志位(<code>RXNE</code>) </li><li>声道标志位(<code>CHSIDE</code>) </li></ul></li><li>支持可靠通信的硬件<code>CRC</code><br>─ 在发送模式下,<code>CRC</code>值可以被作为最后一个字节发送<br>─ 在全双工模式中对接收到的最后一个字节自动进行CRC校验 </li><li>可触发中断的主模式故障、过载以及CRC错误标志</li><li>支持<code>DMA</code>功能的1字节发送和接收缓冲器：产生发送和接受请求</li></ul><h2 id="SPI引脚"><a href="#SPI引脚" class="headerlink" title="SPI引脚"></a>SPI引脚</h2><h3 id="SPI引脚号"><a href="#SPI引脚号" class="headerlink" title="SPI引脚号"></a>SPI引脚号</h3><p>多达<code>3</code>个<code>SPI</code>接口(<code>18M</code>位/秒)<br>在<code>STM32中文数据手册-STM32F103xCDE_DS_CH_V5.pdf</code>中搜<code>SPI2</code>可知<br><img src="/images/SPI2引脚.png" alt="SPI2引脚"></p><h3 id="SPI引脚模式配置"><a href="#SPI引脚模式配置" class="headerlink" title="SPI引脚模式配置"></a>SPI引脚模式配置</h3><p>在<code>STM32中文参考手册-8.1.11 外设的GPIO配置</code>中查看<br><img src="/images/SPI引脚模式配置.png" alt="SPI引脚模式配置"></p><h1 id="SPI-amp-代码"><a href="#SPI-amp-代码" class="headerlink" title="SPI &amp; 代码"></a>SPI &amp; 代码</h1><h2 id="标准库函数"><a href="#标准库函数" class="headerlink" title="标准库函数"></a>标准库函数</h2><h2 id="HAL"><a href="#HAL" class="headerlink" title="HAL"></a>HAL</h2><h2 id="SPI配置过程"><a href="#SPI配置过程" class="headerlink" title="SPI配置过程"></a>SPI配置过程</h2><ul><li>配置相关引脚的复用功能,使能<code>SPIx</code>时钟<ul><li>时钟配置</li><li>IO口配置：<code>void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct);</code></li></ul></li><li>初始化<code>SPIx</code>,设置<code>SPIx</code>工作模式<code>void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct);</code></li><li>使能<code>SPIx</code>,<code>void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState);</code></li><li><code>SPI</code>传输数据<ul><li><code>void SPI_I2S_SendData(SPI_TypeDef* SPIx, uint16_t Data);</code></li><li><code>uint16_t SPI_I2S_ReceiveData(SPI_TypeDef* SPIx) ;</code></li></ul></li><li>查看<code>SPI</code>传输状态<code>SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_RXNE);</code></li></ul><h1 id="SPI实验"><a href="#SPI实验" class="headerlink" title="SPI实验"></a>SPI实验</h1><h2 id="FLASH"><a href="#FLASH" class="headerlink" title="FLASH"></a>FLASH</h2><h3 id="硬件原理图"><a href="#硬件原理图" class="headerlink" title="硬件原理图"></a>硬件原理图</h3><p><img src="/images/SPI_FLASH.png" alt="SPI_FLASH.png"><br>使用软件控制<code>PB12</code>引脚是否为低电平,来选择<code>SPI2</code>与<code>FLASH-W25Q128</code>进行通信<br><img src="/images/SPI2_DATASHEET.png" alt="SPI2_DATASHEET.png"></p><h3 id="STM32CubeMX配置"><a href="#STM32CubeMX配置" class="headerlink" title="STM32CubeMX配置"></a>STM32CubeMX配置</h3><ul><li>配置<code>PB12</code>引脚为<strong>片选引脚</strong></li></ul><p><img src="/images/SPI2_W25Q128/1.png" alt="片选引脚配置"></p><ul><li><code>SPI2</code>配置</li></ul><p><img src="/images/SPI2_W25Q128/2.png" alt="SPI2配置"></p><h3 id="W25Q128内存布局"><a href="#W25Q128内存布局" class="headerlink" title="W25Q128内存布局"></a>W25Q128内存布局</h3><p><img src="/images/SPI2_W25Q128/w25q128_block_diagram.png" alt="w25q128_block_diagram"></p><h3 id="W25Q128"><a href="#W25Q128" class="headerlink" title="W25Q128"></a>W25Q128</h3><p><a href="https://github.com/nimaltd/w25qxx">W25QXX SPI FLASH Library for STM32</a></p><ul><li>修改<code>w25qxxConf.h</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;main.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _W25QXX_SPI hspi2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _W25QXX_CS_GPIO W25Q128_CHIP_SELECT_GPIO_Port</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _W25QXX_CS_PIN W25Q128_CHIP_SELECT_Pin</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _W25QXX_USE_FREERTOS 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _W25QXX_DEBUG 0</span></span><br></pre></td></tr></table></figure><ul><li>获取<code>W25Q128</code>的信息</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">W25qxx_Info</span><span class="params">(<span class="keyword">const</span> <span class="keyword">w25qxx_t</span> *pTw25qxx)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\r\n-------------------%7s------------------\r\n&quot;</span>, <span class="string">&quot;-------&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;           %7s&#x27;s info     \r\n&quot;</span>, pTw25qxx-&gt;ID == W25Q128 ? <span class="string">&quot;W25Q128&quot;</span> : <span class="string">&quot;w25qxx&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-----------------------%7s--------------\r\n&quot;</span>, <span class="string">&quot;-------&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;            UniqID : %02X-%02X-%02X-%02X-%02X-%02X-%02X-%02X\r\n&quot;</span>, pTw25qxx-&gt;UniqID[<span class="number">0</span>],</span><br><span class="line">           pTw25qxx-&gt;UniqID[<span class="number">1</span>],</span><br><span class="line">           pTw25qxx-&gt;UniqID[<span class="number">2</span>],</span><br><span class="line">           pTw25qxx-&gt;UniqID[<span class="number">3</span>],</span><br><span class="line">           pTw25qxx-&gt;UniqID[<span class="number">4</span>],</span><br><span class="line">           pTw25qxx-&gt;UniqID[<span class="number">5</span>],</span><br><span class="line">           pTw25qxx-&gt;UniqID[<span class="number">6</span>],</span><br><span class="line">           pTw25qxx-&gt;UniqID[<span class="number">7</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;          PageSize : %5u bytes\r\n&quot;</span>, pTw25qxx-&gt;PageSize);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;         PageCount : %5lu \r\n&quot;</span>, pTw25qxx-&gt;PageCount);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;        SectorSize : %5lu bytes\r\n&quot;</span>, pTw25qxx-&gt;SectorSize);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;       SectorCount : %5lu \r\n&quot;</span>, pTw25qxx-&gt;SectorCount);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;         BlockSize : %5lu bytes\r\n&quot;</span>, pTw25qxx-&gt;BlockSize);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;        BlockCount : %5lu \r\n&quot;</span>, pTw25qxx-&gt;BlockCount);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;CapacityInKiloByte : %5lu \r\n&quot;</span>, pTw25qxx-&gt;CapacityInKiloByte);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;   StatusRegister1 : %5X \r\n&quot;</span>, pTw25qxx-&gt;StatusRegister1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;   StatusRegister2 : %5X \r\n&quot;</span>, pTw25qxx-&gt;StatusRegister2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;   StatusRegister3 : %5X \r\n&quot;</span>, pTw25qxx-&gt;StatusRegister3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;              Lock : %5u \r\n&quot;</span>, pTw25qxx-&gt;Lock);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--------%7s-----------------------------\r\n\r\n&quot;</span>, <span class="string">&quot;-------&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">--------------------------------------------</span><br><span class="line">           W25Q128<span class="number">&#x27;</span>s info</span><br><span class="line">--------------------------------------------</span><br><span class="line">            UniqID : D2<span class="number">-66</span><span class="number">-94</span><span class="number">-44</span>-DF<span class="number">-34</span><span class="number">-2</span>A<span class="number">-34</span></span><br><span class="line">          PageSize :   <span class="number">256</span> bytes</span><br><span class="line">         PageCount : <span class="number">65536</span></span><br><span class="line">        SectorSize :  <span class="number">4096</span> bytes</span><br><span class="line">       SectorCount :  <span class="number">4096</span></span><br><span class="line">         BlockSize : <span class="number">65536</span> bytes</span><br><span class="line">        BlockCount :   <span class="number">256</span></span><br><span class="line">CapacityInKiloByte : <span class="number">16384</span></span><br><span class="line">   StatusRegister1 :     <span class="number">0</span></span><br><span class="line">   StatusRegister2 :     <span class="number">0</span></span><br><span class="line">   StatusRegister3 :    <span class="number">60</span></span><br><span class="line">              Lock :     <span class="number">0</span></span><br><span class="line">--------------------------------------------</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32-F103ZET6-11-Timer</title>
      <link href="/2022/04/05/Embedded-System-00/STM32-F103ZET6-11-Timer/"/>
      <url>/2022/04/05/Embedded-System-00/STM32-F103ZET6-11-Timer/</url>
      
        <content type="html"><![CDATA[<h1 id="通用定时器概述"><a href="#通用定时器概述" class="headerlink" title="通用定时器概述"></a>通用定时器概述</h1><p><code>STM32F10x</code>系列<strong>总共</strong>最多有<code>8</code>个<strong>定时器</strong>(查看选型手册):<code>4</code>个<strong>通用定时器</strong>+<code>2</code>个<strong>高级定时器</strong>+<code>2</code>个<strong>基本定时器</strong></p><h2 id="定时器分类"><a href="#定时器分类" class="headerlink" title="定时器分类"></a>定时器分类</h2><div class="table-container"><table><thead><tr><th style="text-align:center">定时器种类</th><th style="text-align:center">位数</th><th style="text-align:center">计数器模式</th><th style="text-align:center">产生<code>DMA</code>请求</th><th style="text-align:center">捕获/比较通道</th><th style="text-align:center">互补输出</th><th style="text-align:center">特殊应用场景</th></tr></thead><tbody><tr><td style="text-align:center">高级定时器<code>TIM1,TIM8</code></td><td style="text-align:center"><code>16</code></td><td style="text-align:center">向上,向下,向上/下</td><td style="text-align:center">可以</td><td style="text-align:center"><code>4</code></td><td style="text-align:center">有</td><td style="text-align:center">带死区控制盒紧急刹车,可应用于<code>PWM</code>电机控制</td></tr><tr><td style="text-align:center">通用定时器<code>TIM2-TIM5</code></td><td style="text-align:center"><code>16</code></td><td style="text-align:center">向上,向下,向上/下</td><td style="text-align:center">可以</td><td style="text-align:center"><code>4</code></td><td style="text-align:center">无</td><td style="text-align:center">通用,定时计数,<code>PWM</code>输出,输入捕获,输出比较</td></tr><tr><td style="text-align:center">基本定时器<code>TIM6,TIM7</code></td><td style="text-align:center"><code>16</code></td><td style="text-align:center">向上,向下,向上/下</td><td style="text-align:center">可以</td><td style="text-align:center"><code>0</code></td><td style="text-align:center">无</td><td style="text-align:center">主要应用于驱动<code>DAC</code></td></tr></tbody></table></div><h2 id="通用定时器特点"><a href="#通用定时器特点" class="headerlink" title="通用定时器特点"></a>通用定时器特点</h2><p><code>STM32</code>的通用<code>TIMx</code>(<code>TIM2、TIM3、TIM4</code>和<code>TIM5</code>)<strong>定时器功能特点</strong>包括:</p><ul><li><strong>时钟可以来源于低速</strong>的<code>APB1</code>总线上(<code>APB1</code>)</li><li><code>16</code>位<strong>向上、向下、向上/向下</strong>(中心对齐)<strong>计数模式</strong>,<strong>自动装载计数器</strong><code>TIMx_CNT</code></li><li><code>16</code>位<strong>可编程(可以实时修改)预分频器</strong>(<code>TIMx_PSC</code>),<strong>计数器时钟频率的分频系数</strong> 为<code>1～65535</code>之间的<strong>任意数值</strong></li><li><code>4</code>个<strong>独立通道</strong>(<code>TIMx_CH1~4</code>),这些<strong>通道可以用来作为</strong>(定时器之间互不影响,通道之间互不影响)<ul><li><strong>输入捕获</strong></li><li><strong>输出比较</strong></li><li><code>PWM</code>生成(边缘或中间对齐模式)</li><li><strong>单脉冲模式</strong>输出</li></ul></li><li><strong>可使用外部信号</strong>(<code>TIMx_ETR</code>)<strong>控制定时器</strong>和<strong>定时器互连</strong>(可以用<code>1</code>个定时器<strong>控制</strong>另外一个定时器)的同步电路</li><li>如下<strong>事件发生</strong>时<strong>产生中断</strong>/<code>DMA</code>(<code>6</code>个<strong>独立</strong>的<code>IRQ/DMA</code>请求生成器）：<ul><li><strong>更新</strong>：计数器向上溢出/向下溢出，计数器初始化(通过软件或者内部/外部触发)</li><li><strong>触发事件</strong>(计数器启动、停止、初始化或者由内部/外部触发计数)</li><li><strong>输入捕获</strong></li><li><strong>输出比较</strong></li><li><strong>支持针对定位的增量(正交)编码器和霍尔传感器电路</strong></li><li><strong>触发输入</strong>作为<strong>外部时钟</strong>或者按<strong>周期的电流管理</strong></li></ul></li><li><code>STM32</code>的<strong>通用定时器</strong>可以被用于：<strong>测量输入信号的脉冲长度</strong>(输入捕获)或者<strong>产生输出波形</strong>(<strong>输出比较和PWM</strong>)等</li><li>使用<strong>定时器预分频器</strong>和<code>RCC</code>时钟控制器预分频器,<strong>脉冲长度</strong>和<strong>波形周期</strong>可以在<strong>几个微秒到几个毫秒间调整</strong>。<code>STM32</code>的每个<strong>通用定时器都是完全独立</strong>的,<strong>没有互相共享的任何资源</strong></li></ul><h2 id="计算器模式"><a href="#计算器模式" class="headerlink" title="计算器模式"></a>计算器模式</h2><p><strong>通用定时器</strong>可以<strong>向上计数</strong>、<strong>向下计数</strong>、<strong>向上向下双向</strong>计数模式。</p><ul><li><strong>向上计数模式</strong>：计数器<strong>从</strong><code>0</code><strong>计数</strong>到<strong>自动加载值</strong>(<code>TIMx_ARR</code>),然后<strong>重新</strong>从<code>0</code><strong>开始计数</strong>并且<strong>产生一个计数器溢出事件</strong></li><li><strong>向下计数模式</strong>：计数器<strong>从自动装入的值</strong>(<code>TIMx_ARR</code>)开始<strong>向下计数</strong>到<code>0</code>,然后从<strong>自动装入的值</strong>重新开始,并<strong>产生一个计数器向下溢出事件</strong></li><li><strong>中央对齐模式</strong>(向上/向下计数)：计数器<strong>从</strong><code>0</code>开始计数到<strong>自动装入的值</strong><code>-1</code>,产生一个<strong>计数器溢出事件</strong>,然后<strong>向下计数</strong>到<code>1</code>并且<strong>产生一个计数器溢出事件</strong>;然后再<strong>从</strong><code>0</code><strong>开始重新计数</strong><br><img src="/images/通用定时器计数模式.png" alt="通用定时器计数模式"></li></ul><h2 id="定时器框图"><a href="#定时器框图" class="headerlink" title="定时器框图"></a>定时器框图</h2><p><img src="/images/STM32F1定时器框图.png" alt="STM32F1定时器框图"></p><p>&#x1F308;引脚查看:查看芯片资料:<code>STM32F103ZET6.pdf</code>,搜索<code>ETR、TIM1_CH1</code>可以看到对应的外部引脚号<br><img src="/images/定时器引脚查看.png" alt="定时器引脚查看"></p><h3 id="时钟源选择与时基单元"><a href="#时钟源选择与时基单元" class="headerlink" title="时钟源选择与时基单元"></a>时钟源选择与时基单元</h3><ul><li>以下来源可以作为<code>CK_PSC</code><strong>时钟来源</strong><ul><li>1、来源于<code>APB1</code>,经过触发控制器得到(默认)</li><li>2、<code>TIMx_ETR</code>引脚输入(查看芯片资料:<code>STM32F103ZET6.pdf</code>,搜索<code>ETR</code>可以查看每个定时器的<code>ETR</code>对应的引脚),该引脚只有定时器<code>2、3、4</code>有该引脚</li><li>3、其它定时器<code>ITR0-3</code>,定时器时钟也可以通过<code>TRGO</code>引脚作为其它定时器时钟输入</li><li>4、<code>TI1</code>的边沿检测器(<code>TI1F_ED</code>)</li><li>5、<code>TI1FP1-2</code></li></ul></li></ul><p>&#x1F308;<code>CK_PSC</code>时钟经过<code>PSC</code>预分频器得到<code>CK_CNT</code>时钟,该时钟才是<strong>定时器的时钟</strong>;通过配置触发控制器,来配置计数器模式(向上/向下)</p><p><img src="/images/通用定时器时钟选择.png" alt="通用定时器时钟选择"><br>&#x1F308;除非<code>APB1</code>的<strong>分频系数</strong>(<code>APB1 Prescaler</code>)是<code>1</code>,否则<strong>通用定时器的时钟</strong>(<code>CK_INT</code>)等于<code>APB1</code>时钟的<code>2</code>倍<br><strong>例如:</strong>默认调用<code>SystemInit</code>函数情况下,<code>SYSCLK=72M</code>,<code>AHB</code>时钟<code>=72M</code>,<code>APB1</code>时钟<code>=36M</code><br>;所以<code>APB1</code>的<strong>分频系数</strong><code>=AHB/APB1</code>时钟<code>=2</code>,则通用定时器时钟<code>CK_INT=2*36M=72M</code><br>&#x1F308;其中的<code>N</code>为<code>PSC[15:0]+1</code><br><img src="/images/定时器向上计数器.png" alt="定时器向上计数器"></p><p><strong>常用寄存器</strong></p><ul><li><strong>计数器</strong><code>TIMx_CNT</code>:<code>16</code>位,计算器的值,对应<strong>定时器框图</strong>中的<code>+/-CNT计数器</code></li><li><strong>预分频寄存器</strong><code>TIMx_PSC</code>:<code>16</code>位，$\frac{Fre_{CK\_PSC}}{PSC[0:15]+1}=Fre_{CK\_CNT}$,对应<strong>定时器框图</strong>中的<code>PSC预分频器</code></li><li><strong>自动重装载寄存器</strong><code>TIMx_ARR</code>：<code>16</code>位,对应<strong>定时器框图</strong>中的<code>自动重装载寄存器</code></li><li><strong>控制寄存器1</strong><code>TIMx_CR1</code>:<code>16</code>位<ul><li>位<code>4</code>:控制方向(计数器向上计数/计数器向下计数)</li><li>位<code>0</code>:使能计数器</li></ul></li><li><code>DMA</code>中断使能寄存器<code>TIMx_DIER</code>:<code>16</code>位<ul><li>位<code>0</code>-<code>UIE</code>:允许更新中断</li></ul></li></ul><h3 id="输入捕获"><a href="#输入捕获" class="headerlink" title="输入捕获"></a>输入捕获</h3><ul><li><strong>输入捕获过程</strong><br>通过检测<code>TIMx_CHx</code>上的边沿信号,在<strong>边沿信号发生跳变</strong>(比如上升沿/下降沿)的时候,将当前定时器的值(<code>TIMx_CNT</code>)存放到对应的捕获/比较寄存器(<code>TIMx_CCRx</code>)里面,完成一次捕获。<br><img src="/images/捕获通道.png" alt="捕获通道"><ul><li>步骤<code>1</code>:设置<strong>输入捕获滤波器</strong>(以通道<code>1</code>为例)<ul><li><ul><li>频率$f_{DTS}$与<code>TIMx_CR1</code>寄存器中的<code>bit[8:9](CKD[1:0])</code>有关(<code>参考STM32中文参考手册-14.4.1、控制寄存器1(TIMx_CR1)</code>),当<code>CKD[1:0]</code>为<code>00</code>时表明 $f_{DTS}=f_{CK\_INT}$, 其中为$f_{CK_INT}$为内部时钟<code>CK_INT</code></li></ul></li><li><ul><li>采样频率$f_{sampling}$和滤波器长度<code>N</code>与<code>TIMx_CCMR1</code>寄存器中的<code>bit[4:7](CI1F[3:0])</code>有关(<code>参考14.4.7、捕获/比较模式寄存器1(TIMx_CCMR1)</code>),当<code>CI1F[3:0]</code>为<code>0011</code>,则以采样频率$f_{sampling}=f_{CK\_INT}$,滤波器长度<code>N</code>为<code>8</code></li></ul></li><li><ul><li><strong>滤波器</strong>会以$f_{sampling}$进行采样,当采样到上升沿,通过连续判断<code>8</code>次<strong>是不是</strong>高电平<strong>来防抖</strong>,从而触发输出<code>TI1F</code></li></ul></li></ul></li><li>步骤<code>2</code>:设置<strong>输入捕获极性</strong>(以通道<code>1</code>为例),捕获上升沿还是下降沿(<code>参考STM32中文参考手册-14.4.9、捕获/比较使能寄存器(TIMx_CCER)</code>)<ul><li><code>1</code>：反相：捕获发生在<code>IC1</code>的下降沿</li><li><code>0</code>：不反相：捕获发生在<code>IC1</code>的上升沿</li></ul></li><li>步骤<code>3</code>:设置<strong>输入捕获映射通道</strong>(以通道<code>1</code>为例),通过设置<code>TIMx_CCMR</code>寄存器中的<code>CC1S[1:0]</code>来指定<code>TI1FP1</code>、<code>TI2FP1</code>、<code>TRC</code>中的哪一个作为<code>IC1</code>的输入,参考(<code>参考STM32中文参考手册- 捕获/比较模式寄存器1(TIMx_CCMR1)</code>)</li><li>步骤<code>4</code>:设置<strong>输入捕获分频器</strong>(以通道<code>1</code>为例),通过设置<code>TIMx_CCMR</code>寄存器中的<code>IC1PSC[1:0]</code>来配置分频器,是每个事件后送入后续流程还是过滤</li><li>步骤<code>5</code>:设置<strong>计数器的值是否能捕获入TIMx_CCR1寄存器</strong>(<code>参考STM32中文参考手册-14.4.9 捕获/比较使能寄存器(TIMx_CCER)</code>)</li><li>步骤<code>6</code>:设置<strong>捕获到有效信号可以开启中断</strong>(<code>参考STM32中文参考手册-14.4.4 DMA/中断使能寄存器(TIMx_DIER)</code>),通过设置<code>TIMx_DIER</code>寄存器中的<code>CC1IE</code>使能中断</li></ul></li></ul><h3 id="输出比较"><a href="#输出比较" class="headerlink" title="输出比较"></a>输出比较</h3><ul><li><p><strong>比较过程</strong><br><img src="/images/PWM.png" alt="PWM"><br><code>PWM</code>的<strong>周期时长/频率</strong>由寄存器<code>TIMx_ARR</code>决定,脉宽宽度由<code>TIMx_CCR1(捕获比较寄存器-通道1的比较值)</code>与<code>TIMx_ARR</code>决定</p></li><li><p><code>PWM</code><strong>工作过程</strong><br>   <img src="/images/PWM工作过程.png" alt="PWM工作过程"></p><ul><li>图中的<code>CCR1</code>即<code>TIMx_CCR1</code>寄存器(<code>16位寄存器</code>),<code>CNT</code>即为计数器<code>TIMx_CNT</code></li><li>寄存器<code>TIMx_CCMR1</code>的<code>OC1M[2:0]</code>用作<strong>配置输出模式控制器</strong>,查看<code>STM32中文参考手册_V10.pdf-14.4.7、捕获/比较模式寄存器1(TIMx_CCMR1)</code>;<ul><li><code>OC1M[2:0]=110</code>对应<code>PWM</code>模式<code>1</code>,计数器<code>TIMx_CNT</code>$&lt;$<code>TIMx_CCRy</code>时有效</li><li><code>OC1M[2:0]=111</code>对应<code>PWM</code>模式<code>2</code>,计数器<code>TIMx_CNT</code>$&gt;$<code>TIMx_CCRy</code>时有效</li></ul></li><li><strong>捕获/比较使能寄存器</strong>(<code>TIMx_CCER</code>)的<code>CCxP(x表示通道1-4)</code>在输出时 <ul><li><code>0-OCx</code>高电平有效</li><li><code>1-OCx</code>低电平有效</li></ul></li><li><strong>捕获/比较使能寄存器</strong>(<code>TIMx_CCER</code>)的<code>CCxE(x表示通道1-4)</code>在输出时<ul><li><code>0-OCx</code>禁止输出</li><li><code>1-OCx</code>表示<code>OCx</code>信号输出到对应的输出引脚</li></ul></li></ul></li></ul><blockquote><p>所以要获得图<code>PWM</code>所示的<code>PWM</code>,则应该配置<code>PWM</code>模式<code>2</code>(<code>OC1M[2:0]=111</code>)<strong>且</strong>高电平有效(<code>CCxP=0</code>)<strong>且</strong>使能输出(<code>CCxE=1</code>)</p></blockquote><ul><li><p><strong>影子寄存器</strong></p><ul><li>在图<code>STM32F1 定时器框图</code>中有几个方框<strong>有阴影</strong>(<code>PSC</code>预分频器,自动重装载寄存器,<code>CNT</code>计数器,捕获/比较<code>1-4</code>寄存器),这说明这些寄存器都有一个对应的影子寄存器;</li><li><strong>影子寄存器的作用</strong>,这几个寄存器都是经常用到的,而且<strong><em>存在定时器工作过程中修改他们的可能性</em></strong>。在<strong>定时器工作过程中修改他们的值,就会出现一个问题</strong>了:<ul><li>如果上次<code>TIMx_ARR</code>的值是<code>200</code>,<strong>通道1</strong>的比较寄存器<code>TIMx_CCR1</code>值是<code>100</code>,产生<strong>占空比</strong>为<code>50%</code>的<code>PWM</code>。</li><li>这个时候我要改变<code>PWM</code>的<strong>频率</strong>,我把<code>TIMx_ARR</code>的值改为<code>100</code>,<code>TIMx_CCR1</code>的值<strong>还没来得及更改</strong>,那么<strong>占空比肯定就会出问题</strong>,所以<strong>我就需要让他们(TIMx_ARR和TIMx_CCR1)同步修改</strong>。以前<code>TIMx_ARR=200,TIMx_CCR1=100</code>,提高频率后<code>TIMx_ARR=100,TIMx_CCR1=50</code>,我需要这<strong>两个寄存器的值同步修改</strong>,最好<strong>还是让他们计数完一个周期后再修改</strong>,那么<strong>进入下一个周期</strong><code>TIMx_ARR</code>、<code>TIMx_CCR1</code><strong>同步修改过去</strong>,对<code>PWM</code>的<strong>占空比就没有一点影响了</strong></li><li>为了<strong>达到这个目的</strong>,就得先用一个<strong>寄存器A</strong>把修改的值保存好(<code>ARR_A=100，CCR1_A=50</code>),一旦<strong>上一个周期结束</strong>,给一个信号,立即就把<strong>寄存器A的值赋值过去</strong>,<strong>立即生效</strong>,这样就<strong>完成了最理想的在定时器运行中修改寄存器的过程</strong></li></ul></li><li>有<strong>影子寄存器的寄存器</strong>实际上<strong>对应了两个寄存器</strong>:<ul><li>一个是<strong>用户可以写入或读出数据的寄存器</strong>,称为<code>preload register</code>(<strong>预装载寄存器</strong>)</li><li>一个是<strong>用户看不见的,但在操作中真正起作用的寄存器</strong>,称为<code>shadow register</code>(<strong>影子寄存器</strong>)</li><li>修改的<strong>定时器周期</strong>、<strong>预分频系数</strong>、<strong>通道的比较值</strong>等,都是<strong>修改的表面那个预装载寄存器</strong>,要让<strong>这个修改起作用</strong>,就还要<strong>把预装载寄存器的值赋给影子寄存器</strong>才行</li></ul></li></ul></li><li><p><strong>典型的影子寄存器</strong> </p><ul><li><code>TIMx_ARR</code>-影子寄存器的<strong>两种更新方式</strong>,通过<code>void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState);</code>配置<ul><li><code>TIMx_CR1.bit[7]=0</code>:<code>TIMx_ARR</code>寄存器<strong>没有缓冲</strong>(同时马上更新影子寄存器的值)</li><li><code>TIMx_CR1.bit[7]=1</code>:<code>TIMx_ARR</code>寄存器<strong>有缓冲</strong>(必须在下一次事件<code>UEV</code>发生后才能更新影子寄存器的值)</li></ul></li><li><code>TIMx_CCR1</code>-影子寄存器的<strong>两种更新方式</strong>,通过<code>oid TIM_OCxPreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)</code>配置通道<code>x</code><ul><li><code>TIMx_CCMR1.bit[3]=0</code>：禁止<code>TIMx_CCR1</code>寄存器的预装载功能,可随时写入<code>TIMx_CCR1</code>寄存器,并且新写入的数值<strong>立即起作用</strong></li><li><code>TIMx_CCMR1.bit[3]=1</code>：开启<code>TIMx_CCR1</code>寄存器的预装载功能,读写操作仅对<strong>预装载寄存器</strong>操作,<code>TIMx_CCR1</code>的预装载值<strong>在更新事件到来时</strong>被传送至当前<strong>寄存器</strong>(对应的影子寄存器)中。</li></ul></li></ul></li></ul><p><img src="/images/ARPE.png" alt="ARPE"></p><p>&#x1F308;<strong>参考</strong><a href="https://blog.csdn.net/qlexcel/article/details/96972555?spm=1001.2101.3001.6650.4&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-4.pc_relevant_paycolumn_v3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-4.pc_relevant_paycolumn_v3&amp;utm_relevant_index=5">影子寄存器</a><br>&#x1F308;<strong>参考</strong><code>STM32中文参考手册-15.3.1 时基单元</code></p><ul><li>通道&amp;引脚<br>&#x1F308;<strong>在数据手册datasheet</strong><code>STM32F103xCDE_DS_CH_V5.pdf</code>中搜<code>TIM1</code>可查看相应的<strong>引脚</strong><br><img src="/images/定时器引脚.png" alt="定时器引脚"></li></ul><h2 id="常用标准库函数"><a href="#常用标准库函数" class="headerlink" title="常用标准库函数"></a><strong>常用标准库函数</strong></h2><h3 id="定时器初始化-中断配置"><a href="#定时器初始化-中断配置" class="headerlink" title="定时器初始化/中断配置"></a>定时器初始化/中断配置</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_TimeBaseInit</span><span class="params">(TIM_TypeDef* TIMx, </span></span></span><br><span class="line"><span class="params"><span class="function">  TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)</span></span>;</span><br><span class="line"></span><br><span class="line">TIM_TimeBaseStructure.TIM_Period = <span class="number">4999</span>;<span class="comment">//装载值</span></span><br><span class="line">TIM_TimeBaseStructure.TIM_Prescaler =<span class="number">7199</span>; <span class="comment">// 分频系数</span></span><br><span class="line">TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1; </span><br><span class="line">TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up; <span class="comment">// 向上计数模式</span></span><br><span class="line">TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseStructure); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器使能函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_Cmd</span><span class="params">(TIM_TypeDef* TIMx, FunctionalState NewState)</span></span>;</span><br><span class="line"><span class="comment">// 定时器中断使能函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_ITConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_IT, FunctionalState NewState)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态标志位获取和清除</span></span><br><span class="line"><span class="function">FlagStatus <span class="title">TIM_GetFlagStatus</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_FLAG)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_ClearFlag</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_FLAG)</span></span>;</span><br><span class="line"><span class="function">ITStatus <span class="title">TIM_GetITStatus</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_IT)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_ClearITPendingBit</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_IT)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="输出比较-1"><a href="#输出比较-1" class="headerlink" title="输出比较"></a>输出比较</h3><ul><li><p>影子寄存器<strong>更新方式配置</strong><code>x=1-4</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_OCxPreloadConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_OCPreload)</span></span>;<span class="comment">// TIMx_CCR2的影子寄存器更新策略配置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_ARRPreloadConfig</span><span class="params">(TIM_TypeDef* TIMx, FunctionalState NewState)</span></span>;<span class="comment">// TIMx_ARR 的影子寄存器更新策略配置</span></span><br></pre></td></tr></table></figure></li><li><p>输出PWM的配置函数<code>x=1-4</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">uint16_t</span> TIM_OCMode;   <span class="comment">// PWM模式1或者模式2    </span></span><br><span class="line">  <span class="keyword">uint16_t</span> TIM_OutputState;  <span class="comment">// 输出使能 OR失能</span></span><br><span class="line">  <span class="keyword">uint16_t</span> TIM_OutputNState;  </span><br><span class="line">  <span class="keyword">uint16_t</span> TIM_Pulse;        <span class="comment">// 比较值，写CCRx</span></span><br><span class="line">  <span class="keyword">uint16_t</span> TIM_OCPolarity;   <span class="comment">// 比较输出极性</span></span><br><span class="line">  <span class="keyword">uint16_t</span> TIM_OCNPolarity;   </span><br><span class="line">  <span class="keyword">uint16_t</span> TIM_OCIdleState;   </span><br><span class="line">  <span class="keyword">uint16_t</span> TIM_OCNIdleState;  </span><br><span class="line">&#125; TIM_OCInitTypeDef;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_OCxInit</span><span class="params">(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>设置比较值函数<code>x=1-4</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_SetComparex</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> Compare1)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="输入捕获-1"><a href="#输入捕获-1" class="headerlink" title="输入捕获"></a>输入捕获</h3><ul><li><p><strong>输入捕获初始化</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">uint16_t</span> TIM_Channel;    <span class="comment">// 通道1-4</span></span><br><span class="line">  <span class="keyword">uint16_t</span> TIM_ICPolarity;  <span class="comment">// 极性</span></span><br><span class="line">  <span class="keyword">uint16_t</span> TIM_ICSelection;  <span class="comment">// 映射关系</span></span><br><span class="line">  <span class="keyword">uint16_t</span> TIM_ICPrescaler;  <span class="comment">// 预分频</span></span><br><span class="line">  <span class="keyword">uint16_t</span> TIM_ICFilter;     <span class="comment">//滤波器</span></span><br><span class="line">&#125; TIM_ICInitTypeDef;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_ICInit</span><span class="params">(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>通道极性设置独立函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM_OCxPolarityConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="keyword">uint16_t</span> TIM_OCPolarity)</span>；</span></span><br></pre></td></tr></table></figure></li><li><p><strong>获取通道捕获值</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">TIM_GetCapture1</span><span class="params">(TIM_TypeDef* TIMx)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="HAL库"><a href="#HAL库" class="headerlink" title="HAL库"></a>HAL库</h2><h3 id="中断流程"><a href="#中断流程" class="headerlink" title="中断流程"></a>中断流程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIM2_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">=&gt; HAL_TIM_IRQHandler(&amp;htim2);</span><br></pre></td></tr></table></figure><p>在<code>HAL_TIM_IRQHandler</code>处理各种中断类型(<code>Capture compare</code>、<code>TIM Update event</code>、<code>TIM Break input event</code>、<code>TIM Trigger detection event</code>、<code>TIM commutation event</code>)<br><img src="/images/STM32CubeMX_TIMER_UPDATE_IT/HAL_TIM_IRQHandler.png" alt="HAL_TIM_IRQHandler"></p><p><strong>更新事件</strong>的中断函数<code>HAL_TIM_PeriodElapsedCallback</code>被定义为<code>weak</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__weak <span class="keyword">void</span> <span class="title">HAL_TIM_PeriodElapsedCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span>;</span><br></pre></td></tr></table></figure></p><h3 id="PWM"><a href="#PWM" class="headerlink" title="PWM"></a>PWM</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HAL_TIM_PWM_Start(&amp;htim3, TIM_CHANNEL_2);<span class="comment">// PWM初始化后开始PWM输出</span></span><br><span class="line">__HAL_TIM_SET_COMPARE(&amp;htim3, TIM_CHANNEL_2, dutyCycle); <span class="comment">// 宏,设置占空比</span></span><br></pre></td></tr></table></figure><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><h2 id="定时器中断实验"><a href="#定时器中断实验" class="headerlink" title="定时器中断实验"></a>定时器中断实验</h2><h3 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a><strong>实验要求</strong></h3><p> 通过定时器中断配置,每<code>500ms</code>中断一次,然后中断服务函数中控制<code>LED</code>实现<code>LED</code>状态取反（闪烁）</p><h3 id="定时器中断实现步骤"><a href="#定时器中断实现步骤" class="headerlink" title="定时器中断实现步骤"></a>定时器中断实现步骤</h3><ul><li>1、能定时器时钟<code>RCC_APB1PeriphClockCmd();</code></li><li>2、初始化定时器，配置<code>ARR,PSC</code>。<code>TIM_TimeBaseInit();</code></li><li>3、开启定时器中断，配置<code>NVIC</code>。<ul><li><code>void TIM_ITConfig();</code></li><li><code>NVIC_Init();</code></li></ul></li><li>4、使能定时器。<ul><li><code>TIM_Cmd();</code></li></ul></li><li>5、编写中断服务函数。<ul><li><code>TIMx_IRQHandler();</code></li></ul></li></ul><h3 id="STM32CubeMX配置"><a href="#STM32CubeMX配置" class="headerlink" title="STM32CubeMX配置"></a>STM32CubeMX配置</h3><p><img src="/images/STM32CubeMX_TIMER_UPDATE_IT/clock.png" alt="配置时钟源"><br>可知<code>APB1</code>的时钟频率位<code>72MHz</code><br><img src="/images/STM32CubeMX_TIMER_UPDATE_IT/1.png" alt="配置LED0"><br><img src="/images/STM32CubeMX_TIMER_UPDATE_IT/2.png" alt="配置TIM2"></p><ul><li>根据配置可知<code>TIM2</code>的时钟频率为$\frac{72MHz}{7199+1}=10KHz$,此时装载值为<code>4999</code>;所以以计数器向上计数模式运行时,一个周期的时长为$\frac{4999+1}{10KHz}=0.5s$</li><li><code>auto-reload preload</code><ul><li><code>auto-reload preload=Disable</code>自动重载寄存器写入新值后,该计数值立刻生效,作为当前计数周期的溢出值(参考影子寄存器)</li><li><code>auto-reload preload=Enable</code>自动重载寄存器写入新值后,存放在预装载寄存器中,该值不会马上生效,计数器按照原来旧的溢出值进行计数。当计数溢出后,该计数值才会生效(由预装载寄存器转入影子寄存器),开始新的计数周期 </li></ul></li></ul><p><img src="/images/STM32CubeMX_TIMER_UPDATE_IT/3.png" alt="配置TIM2中断"></p><blockquote><p>可自定义<code>TIM2</code>中断的优先级(抢占和响应)</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main函数中添加</span></span><br><span class="line">HAL_TIM_Base_Start_IT(&amp;htim2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义weak </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HAL_TIM_PeriodElapsedCallback</span><span class="params">(TIM_HandleTypeDef *htim)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (htim == (&amp;htim2))&#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> current = HAL_GetTick();</span><br><span class="line">        LED_TurnoverBitBand();</span><br><span class="line">        Log(I, <span class="string">&quot;HAL_TIM_PeriodElapsedCallback::%d&quot;</span>, current - last);</span><br><span class="line">        last = current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>日志:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">、、、</span><br><span class="line">[ INFO ] : HAL_TIM_PeriodElapsedCallback::496</span><br><span class="line">[ INFO ] : HAL_TIM_PeriodElapsedCallback::496</span><br><span class="line">、、、</span><br></pre></td></tr></table></figure></p><blockquote><p>相邻两次中断的时长为<code>496ms</code></p></blockquote><h2 id="定时器PWM输出实验"><a href="#定时器PWM输出实验" class="headerlink" title="定时器PWM输出实验"></a>定时器PWM输出实验</h2><h3 id="实验要求-1"><a href="#实验要求-1" class="headerlink" title="实验要求"></a>实验要求</h3><p>使用定时器<code>3</code>的<code>PWM</code>功能,输出占空比可变的<code>PWM</code>波,用来驱动<code>LED</code>灯,从而达到<code>LED【PB5]</code>亮度由暗变亮,又从亮变暗,如此循环。</p><h3 id="PWM输出配置步骤"><a href="#PWM输出配置步骤" class="headerlink" title="PWM输出配置步骤"></a><code>PWM</code>输出配置步骤</h3><ul><li>1、使能定时器<code>3</code>和相关<code>IO</code>口时钟。<ul><li>1.1、使能定时器<code>3</code>时钟：<code>RCC_APB1PeriphClockCmd();</code></li><li>1.2、使能<code>GPIOB</code>时钟：<code>RCC_APB2PeriphClockCmd();</code></li></ul></li><li>2、初始化<code>IO</code>口为<strong>复用功能输出</strong>。<ul><li>2.1、<code>GPIO_Init();</code></li><li>2.2、<code>GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;</code></li></ul></li><li>3、这里我们是要把<code>PB5</code>用作定时器的<code>PWM</code>输出引脚,所以要重映射配置,所以需要开启<code>AFIO</code>时钟。同时设置重映射。<ul><li>3.1、<code>RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);</code></li><li>3.2、<code>GPIO_PinRemapConfig(GPIO_PartialRemap_TIM3, ENABLE);</code></li></ul></li><li>4、初始化定时器：<code>ARR,PSC</code>等：<code>TIM_TimeBaseInit();</code></li><li>5、初始化输出比较参数:<code>TIM_OC2Init();</code></li><li>6、使能预装载寄存器： <code>TIM_OC2PreloadConfig(TIM3, TIM_OCPreload_Enable);</code></li><li>7、使能定时器:<code>TIM_Cmd();</code></li><li>8、不断改变比较值<code>CCRx</code>,达到不同的占空比效果:<code>TIM_SetCompare2()</code>;</li></ul><h3 id="STM32CubeMX配置-1"><a href="#STM32CubeMX配置-1" class="headerlink" title="STM32CubeMX配置"></a>STM32CubeMX配置</h3><p>首先需要配置时钟系统,参照<strong>定时器中断实验</strong><br><img src="/images/timer_pwm.png" alt="timer_pwm"></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COUNT_MAX (499 + 1)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> <span class="title">Direction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Direction_Down,</span><br><span class="line">  Direction_Up</span><br><span class="line">&#125; Direction;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDutyCycle</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">uint16_t</span> dutyCycle = COUNT_MAX;</span><br><span class="line">  <span class="keyword">static</span> Direction direction = Direction_Down;</span><br><span class="line">  <span class="keyword">if</span> (COUNT_MAX == dutyCycle)</span><br><span class="line">  &#123;</span><br><span class="line">    direction = Direction_Down;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> == dutyCycle)</span><br><span class="line">  &#123;</span><br><span class="line">    direction = Direction_Up;</span><br><span class="line">  &#125;</span><br><span class="line">  direction == Direction_Down ? (dutyCycle--) : (dutyCycle++);</span><br><span class="line">  __HAL_TIM_SET_COMPARE(&amp;htim3, TIM_CHANNEL_2, dutyCycle); <span class="comment">// 周期位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  HAL_Init();</span><br><span class="line">  SystemClock_Config();</span><br><span class="line">  MX_GPIO_Init();</span><br><span class="line">  MX_TIM3_Init();</span><br><span class="line">  MX_USART1_UART_Init();</span><br><span class="line">  HAL_TIM_PWM_Start(&amp;htim3, TIM_CHANNEL_2);</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    setDutyCycle();</span><br><span class="line">    HAL_Delay(<span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输入捕获-2"><a href="#输入捕获-2" class="headerlink" title="输入捕获"></a>输入捕获</h2><h3 id="实验要求-2"><a href="#实验要求-2" class="headerlink" title="实验要求"></a>实验要求</h3><p>测量<code>PA0</code>的脉冲宽度</p><h3 id="输入配置步骤"><a href="#输入配置步骤" class="headerlink" title="输入配置步骤"></a>输入配置步骤</h3><ul><li>初始化定时器和通道对应IO的时钟。</li><li>初始化IO口，模式为输入：<ul><li><code>GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD; //PA0 输入</code></li><li><code>GPIO_Init();</code></li></ul></li><li>初始化定时器<code>ARR,PSC</code>(确定定时器的时钟周期),<code>TIM_TimeBaseInit();</code></li><li>初始化输入捕获通道<code>TIM_ICInit();</code></li><li>如果要开启捕获中断，<ul><li><code>TIM_ITConfig();</code></li><li><code>NVIC_Init();</code></li></ul></li><li>使能定时器：<code>TIM_Cmd();</code></li><li>编写中断服务函数：<code>TIMx_IRQHandler();</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LVGL_00_模拟器搭建</title>
      <link href="/2022/04/01/LVGL_ws/LVGL-00-%E6%A8%A1%E6%8B%9F%E5%99%A8%E6%90%AD%E5%BB%BA/"/>
      <url>/2022/04/01/LVGL_ws/LVGL-00-%E6%A8%A1%E6%8B%9F%E5%99%A8%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="LVGL介绍"><a href="#LVGL介绍" class="headerlink" title="LVGL介绍"></a>LVGL介绍</h1><p>废话不多说</p><h1 id="资料准备"><a href="#资料准备" class="headerlink" title="资料准备"></a>资料准备</h1><p><code>windows</code>中使用<code>vscode</code>搭建<code>LVGL</code><strong>模拟器</strong>基于<a href="https://docs.lvgl.io/master/index.html">官方教程</a>中的<a href="https://github.com/lvgl/lv_port_win_codeblocks">CodeBlocks教程</a></p><ul><li>下载<a href="https://github.com/lvgl/lv_port_win_codeblocks">lv_port_win_codeblocks</a></li><li>单独下载其中的<code>lv_demos</code>,<code>lv_drivers</code>,<code>lvgl</code></li></ul><p><img src="/images/lvgl_git.png" alt="lvgl_git"></p><blockquote><p><strong>所有文件如上图所示</strong>,其中<code>CMakeLists.txt</code>是自己创建的</p></blockquote><h1 id="CMakeLists编写"><a href="#CMakeLists编写" class="headerlink" title="CMakeLists编写"></a>CMakeLists编写</h1><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.18</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(lv_sim_code)</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD_DEFINITIONS</span>(-DLV_CONF_INCLUDE_SIMPLE=<span class="number">1</span> -DWINVER=<span class="number">0</span>x0601)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">include_directories</span>(./)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_subdirectory</span>(lv_demos)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_subdirectory</span>(lvgl)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_subdirectory</span>(lv_drivers)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(main main.c)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(main lv_examples lvgl lv_drivers)</span><br></pre></td></tr></table></figure><blockquote><p><strong>需要事先</strong>安装<code>Cmake</code>和<code>mingw</code>,<code>vscode</code>中需要安装<code>cmake</code>相关<strong>插件</strong>,<kbd>ctrl</kbd>+<kbd>s</kbd>后会自动生成<code>build</code>文件夹,进入<code>build</code>文件夹执行<code>make</code>即可</p></blockquote><p><img src="/images/lvgl_main.png" alt="lvgl_main"></p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LVGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32-F103ZET6-10-WatchDog</title>
      <link href="/2022/03/29/Embedded-System-00/STM32-F103ZET6-10-WatchDog/"/>
      <url>/2022/03/29/Embedded-System-00/STM32-F103ZET6-10-WatchDog/</url>
      
        <content type="html"><![CDATA[<h1 id="看门狗概述"><a href="#看门狗概述" class="headerlink" title="看门狗概述"></a>看门狗概述</h1><h2 id="为什么要看门狗？"><a href="#为什么要看门狗？" class="headerlink" title="为什么要看门狗？"></a>为什么要看门狗？</h2><p>在由单片机构成的微型计算机系统中,由于单片机的工作常常会受到来自<strong>外界电磁场的干扰</strong>,造成程序的<strong>跑飞</strong>,而<strong>陷入死循环</strong>,<strong>程序的正常运行被打断,由单片机控制的系统无法继续工作,会造成整个系统的陷入停滞状态,发生不可预料的后果,所以出于对单片机运行状态进行实时监测的考虑,便产生了一种专门用于监测单片机程序运行状态的模块或者芯片,俗称“看门狗”(watchdog)</strong> 。</p><h2 id="看门狗解决的问题是什么？"><a href="#看门狗解决的问题是什么？" class="headerlink" title="看门狗解决的问题是什么？"></a>看门狗解决的问题是什么？</h2><ul><li>在<strong>启动正常运行的时候，系统不能复位</strong>。</li><li>在<strong>系统跑飞(程序异常执行)的情况,系统复位,程序重新执行。</strong></li></ul><h2 id="STM32的看门狗"><a href="#STM32的看门狗" class="headerlink" title="STM32的看门狗"></a>STM32的看门狗</h2><ul><li><p><code>STM32</code><strong>内置两个看门狗</strong>,提供了<strong>更高的安全性</strong>,<strong>时间的精确性</strong>和<strong>使用的灵活性</strong>。两个<strong>看门狗设备(独立看门狗/窗口看门狗)</strong>可以用来<strong>检测和解决由软件错误引起的故障</strong>。</p><blockquote><p>当<strong>计数器</strong>达到<strong>给定的超时值</strong>时,<strong>触发一个中断(仅适用窗口看门狗)或者产生系统复位</strong>。</p></blockquote></li><li><p><strong>独立看门狗</strong>(<code>IWDG</code>)由专用的<strong>低速时钟</strong>(<code>LSI</code>)驱动,<strong>即使主时钟发生故障它仍有效</strong>。<strong>独立看门狗</strong>适合应用于需要<strong>看门狗作为一个在主程序之外能够完全独立工作</strong>,并且<strong>对时间精度要求低的场合</strong>。</p></li><li><strong>窗口看门狗</strong>由从<code>APB1</code><strong>时钟分频后得到时钟驱动</strong>。通过可配置的<strong>时间窗口</strong>来<strong>检测应用程序非正常的过迟或过早操作</strong>。<strong>窗口看门狗</strong>最适合那些<strong>要求看门狗在精确计时窗口起作用的程序</strong>。</li></ul><h1 id="独立看门狗"><a href="#独立看门狗" class="headerlink" title="独立看门狗"></a>独立看门狗</h1><h2 id="独立看门狗原理"><a href="#独立看门狗原理" class="headerlink" title="独立看门狗原理"></a>独立看门狗原理</h2><ul><li>在<strong>键值寄存器</strong>(<code>IWDG_KR</code>)中写入<code>0xCCCC</code>,开始<strong>启用独立看门狗</strong>。</li><li>此时<strong>计数器</strong>开始<strong>从其复位值</strong><code>0xFFF</code><strong>递减</strong>,当<strong>计数器值</strong>计数到<strong>尾值</strong><code>0x000</code>时<strong>会产生一个复位信号</strong>(<code>IWDG_RESET</code>)。</li><li>无论何时,只要在<strong>键值寄存器</strong><code>IWDG_KR</code>中<strong>写入</strong><code>0xAAAA</code>(通常说的<strong>喂狗</strong>),自动<strong>重装载寄存器</strong><code>IWDG_RLR</code>的值就会<strong>重新加载</strong>到<strong>计数器</strong>,从而<strong>避免看门狗复位</strong>。</li><li>如果<strong>程序异常</strong>,就<strong>无法正常喂狗</strong>,从而<strong>系统复位</strong>。</li></ul><p>&#x1F349;参考<code>STM32中文参考手册_V10.pdf - 17 独立看门狗(IWDG) 图157-独立看门狗框图</code><br><img src="/images/独立看门狗.png" alt="独立看门狗原理"></p><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><ul><li><strong>键值寄存器</strong><code>IWDG_KR</code>:<code>0~15</code>位有效 - <strong>开启0XCCCC/喂狗0XAAAA</strong></li><li><strong>预分频寄存器</strong><code>IWDG_PR</code>：<code>0~2</code>位有效。<strong>具有写保护功能,要操作先取消写保护</strong> - <strong>时钟频率配置</strong></li><li><strong>重装载寄存器</strong><code>IWDG_RLR</code>：<code>0~11</code>位有效。<strong>具有写保护功能，要操作先取消写保护</strong> - <strong>转载值配置</strong></li><li><strong>状态寄存器</strong><code>IWDG_SR</code>：<code>0~1</code>位有效</li></ul><h3 id="键值寄存器"><a href="#键值寄存器" class="headerlink" title="键值寄存器"></a>键值寄存器</h3><p><strong>键值寄存器</strong><code>IWDG_KR</code>:<code>0~15</code>位有效 - <strong>开启0XCCCC/喂狗0XAAAA</strong></p><blockquote><p>写入<code>0x5555</code>表示<strong>允许访问</strong><code>IWDG_PR</code>和<code>IWDG_RLR</code>寄存器</p></blockquote><h3 id="溢出时间计算"><a href="#溢出时间计算" class="headerlink" title="溢出时间计算"></a>溢出时间计算</h3><p><img src="/images/独立看门狗_时钟频率.png" alt="独立看门狗_时钟频率"><br>时钟频率<code>LSI=40K</code>,则</p><script type="math/tex; mode=display">Tout=\frac{4\times 2^{PR[0:2]}}{Fre_{LSI}}\times (IWDG\_RLR+1)</script><p>譬如:当<code>PR[0:2]=010</code>,则<strong>最大溢出时长</strong></p><script type="math/tex; mode=display">Tout=\frac{4\times 2^2}{40\times10^3}\times (FFF_{hex}+1)=1638.4 ms</script><p><strong>最小时间长度</strong>为:</p><script type="math/tex; mode=display">Tout=\frac{4\times 2^2}{40\times10^3} = 0.4 ms</script><h2 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h2><h3 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IWDG_WriteAccessCmd</span><span class="params">(<span class="keyword">uint16_t</span> IWDG_WriteAccess)</span></span>;<span class="comment">//取消写保护：0x5555使能</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IWDG_SetPrescaler</span><span class="params">(<span class="keyword">uint8_t</span> IWDG_Prescaler)</span></span>;<span class="comment">//设置预分频系数：写PR</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IWDG_SetReload</span><span class="params">(<span class="keyword">uint16_t</span> Reload)</span></span>;<span class="comment">//设置重装载值：写RLR</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IWDG_ReloadCounter</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//喂狗：写0xAAAA到KR</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IWDG_Enable</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//使能看门狗：写0xCCCC到KR</span></span><br><span class="line"><span class="function">FlagStatus <span class="title">IWDG_GetFlagStatus</span><span class="params">(<span class="keyword">uint16_t</span> IWDG_FLAG)</span></span>;<span class="comment">//状态：重装载/预分频 更新</span></span><br></pre></td></tr></table></figure><h3 id="HAL库"><a href="#HAL库" class="headerlink" title="HAL库"></a>HAL库</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MX_IWDG_Init();<span class="comment">// 初始化</span></span><br><span class="line">HAL_IWDG_Refresh(&amp;hiwdg);<span class="comment">// 喂狗</span></span><br></pre></td></tr></table></figure><h2 id="独立看门狗配置流程"><a href="#独立看门狗配置流程" class="headerlink" title="独立看门狗配置流程"></a>独立看门狗配置流程</h2><ul><li>1、<strong>取消寄存器写保护</strong><code>IWDG_WriteAccessCmd();</code></li><li>2、设置<strong>独立看门狗的预分频系数</strong>,确定时钟 <code>IWDG_SetPrescaler();</code></li><li>3、设置<strong>看门狗重装载值</strong>,确定溢出时间<code>IWDG_SetReload();</code></li><li>4、<strong>使能看门狗</strong><code>IWDG_Enable();</code></li><li>5、应用程序<strong>喂狗</strong><code>IWDG_ReloadCounter();</code></li></ul><h2 id="STM32CubeMX配置IDWG"><a href="#STM32CubeMX配置IDWG" class="headerlink" title="STM32CubeMX配置IDWG"></a>STM32CubeMX配置IDWG</h2><p><img src="/images/STM32CubeMX_IWDG/IWDG_config.png" alt="IWDG_config"></p><h2 id="独立看门狗实验"><a href="#独立看门狗实验" class="headerlink" title="独立看门狗实验"></a>独立看门狗实验</h2><h3 id="验证超时后的复位时间"><a href="#验证超时后的复位时间" class="headerlink" title="验证超时后的复位时间"></a><strong>验证超时后的复位时间</strong></h3><ul><li><strong>独立看门狗配置</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 独立看门狗配置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MX_IWDG_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  hiwdg.Instance = IWDG;</span><br><span class="line">  hiwdg.Init.Prescaler = IWDG_PRESCALER_8;</span><br><span class="line">  hiwdg.Init.Reload = <span class="number">4095</span>;</span><br><span class="line">  <span class="keyword">if</span> (HAL_IWDG_Init(&amp;hiwdg) != HAL_OK)</span><br><span class="line">  &#123;</span><br><span class="line">    Error_Handler();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>可知<strong>溢出时间</strong>为$\frac{8*4096}{40000}=0.8192 s = 819.2 ms$<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  HAL_Init();</span><br><span class="line">  SystemClock_Config();</span><br><span class="line">  MX_GPIO_Init();</span><br><span class="line">  MX_USART1_UART_Init();</span><br><span class="line">  MX_IWDG_Init();</span><br><span class="line">  Log(I, <span class="string">&quot;just feed dog ...&quot;</span>);</span><br><span class="line">  <span class="keyword">uint32_t</span> tickstart = HAL_GetTick();</span><br><span class="line">  readyRecv_IT(<span class="keyword">sizeof</span>(MessageSerial_t));</span><br><span class="line">  initCallback();</span><br><span class="line">  <span class="keyword">uint32_t</span> tickend = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">uint32_t</span> idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (isGetNewFrame)</span><br><span class="line">    &#123;</span><br><span class="line">      messageProceccRun(&amp;message, &amp;board_message);</span><br><span class="line">      isGetNewFrame = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    HAL_Delay(<span class="number">50</span>);</span><br><span class="line">    tickend = HAL_GetTick();</span><br><span class="line">    Log(I, <span class="string">&quot;[ %03d ]  use time %lu&quot;</span>, idx++, tickend - tickstart);</span><br><span class="line">    tickstart = tickend;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>串口日志</strong><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[ INFO ] : just feed dog ...</span><br><span class="line">[ INFO ] : [ 000 ]  use time 51</span><br><span class="line">[ INFO ] : [ 001 ]  use time 55</span><br><span class="line">[ INFO ] : [ 002 ]  use time 55</span><br><span class="line">[ INFO ] : [ 003 ]  use time 55</span><br><span class="line">[ INFO ] : [ 004 ]  use time 55</span><br><span class="line">[ INFO ] : [ 005 ]  use time 55</span><br><span class="line">[ INFO ] : [ 006 ]  use time 55</span><br><span class="line">[ INFO ] : [ 007 ]  use time 55</span><br><span class="line">[ INFO ] : [ 008 ]  use time 55</span><br><span class="line">[ INFO ] : [ 009 ]  use time 55</span><br><span class="line">[ INFO ] : [ 010 ]  use time 55</span><br><span class="line">[ INFO ] : [ 011 ]  use time 55</span><br><span class="line">[ INFO ] : [ 012 ]  use time 55</span><br><span class="line">[ INFO ] : [ 013 ]  use time 55</span><br><span class="line">[ INFO ] : [ 014 ]  use time 55</span><br><span class="line">[ INFO ] : just feed dog ...</span><br></pre></td></tr></table></figure><blockquote><p>由日志可知:实际溢出时长为$55*14+51=821ms$</p></blockquote></li></ul><h3 id="独立看门狗如何配置"><a href="#独立看门狗如何配置" class="headerlink" title="独立看门狗如何配置"></a>独立看门狗如何配置</h3><p>由上面可知:主循环使用了约<code>55 ms</code>,分配<code>70 ms</code>,则使用<code>8</code>分频的情况下,应该设置<strong>重装载寄存器</strong>为</p><script type="math/tex; mode=display">IWDG\_RLR=\frac{70}{\frac{8}{40000}*1000}=350</script><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 不在复位</span><br><span class="line">[ INFO ] : [ 6584 ]  use time 55</span><br><span class="line">[ INFO ] : [ 6585 ]  use time 55</span><br><span class="line">[ INFO ] : [ 6586 ]  use time 55</span><br><span class="line">[ INFO ] : [ 6587 ]  use time 55</span><br></pre></td></tr></table></figure><h1 id="窗口看门狗"><a href="#窗口看门狗" class="headerlink" title="窗口看门狗"></a>窗口看门狗</h1><h2 id="窗口看门狗概述"><a href="#窗口看门狗概述" class="headerlink" title="窗口看门狗概述"></a>窗口看门狗概述</h2><p>之所以称为<strong>窗口</strong>就是因为其<strong>喂狗时间是一个有上下限的范围</strong>内(<strong>窗口</strong>),你可以通过设定相关寄存器,设定其<strong>上限时间(下限固定)</strong>。喂狗的时间不能<strong>过早</strong>也不能<strong>过晚</strong></p><ul><li><strong>喂狗时间</strong>只能在<code>W[6:0]-&gt;3F</code>对应的<strong>时间区间</strong>(刷新窗口)内,<strong>否则就会复位</strong>;</li><li><code>3F</code>对应<code>0011 1111</code>,<code>CNT</code>计算器是上一个值为<code>0100 0000</code>,所以<code>CNT</code>计算器从<code>0100 0000</code>到<code>0011 1111</code>时,<code>CNT</code>的<code>T[6]</code>刚好从<code>1-&gt;0</code><br><img src="/images/窗口看门狗.png" alt="窗口看门狗"></li></ul><h2 id="窗口看门狗框图"><a href="#窗口看门狗框图" class="headerlink" title="窗口看门狗框图"></a>窗口看门狗框图</h2><p><img src="/images/窗口看门狗框图.png" alt="窗口看门狗框图"></p><blockquote><p>图中<strong>梯形</strong>表示<strong>比较运算</strong>; <code>A</code>和<code>C</code>是与运算,<code>B</code>或运算;</p></blockquote><p>由此可知,在使能了<strong>窗口看门狗</strong>后(即<code>WWDG_CR</code>寄存器的位<code>7</code>被置<code>1</code>后),<strong>与</strong>运算<code>C</code>的一个输入是<code>1</code>;则<strong>或运算</strong><code>B</code>的两个输入中一个为<code>1</code>就会触发<code>RESET</code>：</p><ul><li>1、当<code>CNT</code>递减计算器从<code>0100 0000</code>到<code>0011 1111</code>时,<code>CNT</code>的<code>T[6]</code>刚好从<code>1-&gt;0</code>,经过取反后,触发<code>RESET</code></li><li>2、当<code>CNT</code>递减计算器-<code>T6:0</code><strong>大于</strong>窗口看门狗配置的<code>W6:0</code>时,且喂狗(写入 <code>WWDG_CR</code>)<blockquote><p><strong>前一种</strong>情况是计算器递减到<code>0011 1111 - 3F</code>;<strong>后一种</strong>情况是过早喂狗</p></blockquote></li></ul><p>如果<strong>启动了看门狗</strong>并且<strong>允许中断</strong>,当<strong>递减计数器</strong>等于<code>0x40</code>时<strong>产生早期唤醒中断</strong>(<code>EWI</code>),它可以<strong>用于喂狗</strong>以避免<code>WWDG</code>复位</p><h2 id="窗口看门狗超时时间"><a href="#窗口看门狗超时时间" class="headerlink" title="窗口看门狗超时时间"></a>窗口看门狗超时时间</h2><p><img src="/images/窗口看门狗CFR.png" alt="窗口看门狗CFR"></p><script type="math/tex; mode=display">\begin{equation}\begin{split}T_{out} &= \frac{1}{\frac{Fre_{PCLK1}}{4096\times2^{WDGTB[1:0]}}} \times (W[6:0] + 1)\\\\&= \frac{(W[6:0]+1) \times 4096\times2^{WDGTB[1:0]}}{Fre_{PCLK1}}\end{split}\end{equation}</script><h2 id="为什么要窗口看门狗"><a href="#为什么要窗口看门狗" class="headerlink" title="为什么要窗口看门狗"></a>为什么要窗口看门狗</h2><ul><li>对于一般的看门狗,程序可以在它产生<strong>复位前的任意时刻刷新看门狗</strong>,但这有一个<strong>隐患</strong>,有<strong>可能程序跑乱了又跑回到正常的地方</strong>,或<strong>跑乱的程序正好执行了刷新看门狗操作</strong>,这样的情况下<strong>一般的看门狗就检测</strong>不出来了;</li><li>如果<strong>使用窗口看门狗</strong>,<strong>程序员</strong>可以根据<strong>程序正常执行的时间</strong>设置<strong>刷新看门狗的一个时间窗口</strong>,保证<strong>不会提前刷新看门狗也不会滞后刷新看门狗</strong>,这样可以<strong>检测出程序没有按照正常的路径运行非正常地跳过了某些程序段</strong>的情况。</li></ul><p>窗口看门狗其他注意事项:</p><ul><li><strong>上窗口值</strong><code>W[6:0]</code>必须<strong>大于下窗口值</strong><code>0x40</code>。否则就<strong>无窗口了</strong>。</li><li>窗口看门狗<strong>时钟来源</strong><code>PCLK1</code>(<code>APB1</code>总线时钟)分频后</li></ul><h2 id="常用库函数"><a href="#常用库函数" class="headerlink" title="常用库函数"></a>常用库函数</h2><h3 id="标准库-1"><a href="#标准库-1" class="headerlink" title="标准库"></a>标准库</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WWDG_Enable</span><span class="params">(<span class="keyword">uint8_t</span> Counter)</span></span>;<span class="comment">//启动并设置初始值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WWDG_SetCounter</span><span class="params">(<span class="keyword">uint8_t</span> Counter)</span></span>;<span class="comment">//喂狗</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WWDG_EnableIT</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">//使能提前唤醒中断</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WWDG_SetPrescaler</span><span class="params">(<span class="keyword">uint32_t</span> WWDG_Prescaler)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WWDG_SetWindowValue</span><span class="params">(<span class="keyword">uint8_t</span> WindowValue)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WWDG_ClearFlag</span><span class="params">()</span></span>;<span class="comment">//Çå³ýÌáÇ°»½ÐÑÖÐ¶Ï±êÖ¾Î» </span></span><br></pre></td></tr></table></figure><h2 id="配置流程"><a href="#配置流程" class="headerlink" title="配置流程"></a>配置流程</h2><h3 id="标准库配置流程"><a href="#标准库配置流程" class="headerlink" title="标准库配置流程"></a>标准库配置流程</h3><ul><li>1、<strong>使能</strong>看门狗时钟<code>RCC_APB1PeriphClockCmd();</code></li><li>2、设置<strong>分频系数</strong><code>WWDG_SetPrescaler();</code></li><li>3、设置<strong>上窗口值</strong><code>WWDG_SetWindowValue();</code></li><li>4、开启<strong>提前唤醒中断并分组</strong>(可选)：<ul><li><code>WWDG_EnableIT();</code></li><li><code>NVIC_Init();</code></li></ul></li><li>5、<strong>使能</strong>看门狗<code>WWDG_Enable();</code></li><li>6、<strong>喂狗</strong><code>WWDG_SetCounter();</code></li><li>7、编写<strong>中断服务函数</strong><code>WWDG_IRQHandler();</code></li></ul><h3 id="STM32CubeMX"><a href="#STM32CubeMX" class="headerlink" title="STM32CubeMX"></a>STM32CubeMX</h3><p><img src="/images/STM32CubeMX_WWDG/1.png" alt="WWDG配置过程"></p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32-F103ZET6-09-USART</title>
      <link href="/2022/03/09/Embedded-System-00/STM32-F103ZET6-09-USART/"/>
      <url>/2022/03/09/Embedded-System-00/STM32-F103ZET6-09-USART/</url>
      
        <content type="html"><![CDATA[<h1 id="通信接口背景知识"><a href="#通信接口背景知识" class="headerlink" title="通信接口背景知识"></a>通信接口背景知识</h1><h2 id="通信的两种方式"><a href="#通信的两种方式" class="headerlink" title="通信的两种方式"></a>通信的两种方式</h2><h3 id="并行通信"><a href="#并行通信" class="headerlink" title="并行通信"></a><strong>并行通信</strong></h3><ul><li><strong>传输原理</strong>：<strong>数据各个位同时传输</strong></li><li><strong>优点</strong>：<strong>速度快</strong></li><li><strong>缺点</strong>：<strong>占用引脚资源多</strong></li></ul><p><img src="/images/Parallel_Transmission.jpg" alt="Parallel_Transmission"></p><h3 id="串行通信"><a href="#串行通信" class="headerlink" title="串行通信"></a><strong>串行通信</strong></h3><ul><li><strong>传输原理</strong>：<strong>数据按位顺序传输</strong></li><li><strong>优点</strong>：<strong>占用引脚资源少</strong></li><li><strong>缺点</strong>：<strong>速度相对较慢</strong><br><img src="/images/serial_communication.png" alt="serial communication"></li></ul><p><strong>串行通信</strong>按照<strong>数据传送方向</strong>分为</p><ul><li><strong>单工</strong>:<strong>数据传输只支持数据在一个方向上传输</strong></li><li><strong>半双工</strong>：<strong>允许数据在两个方向上传输,但是,在某一时刻,只允许数据在一个方向上传输，它实际上是一种切换方向的单工通信</strong></li><li><strong>全双工</strong>：<strong>允许数据同时在两个方向上传输，因此，全双工通信是两个单工通信方式的结合，它要求发送设备和接收设备都有独立的接收和发送能力</strong>。<br><img src="/images/comDirection.png" alt="数据传输方向"></li></ul><p><strong>串行通信的通信方式</strong></p><ul><li><strong>同步通信</strong>：<strong>带时钟同步信号传输</strong>,<code>SPI</code>,<code>IIC</code>通信接口</li><li><strong>异步通信</strong>：<strong>不带时钟同步信号</strong>,<code>UART</code>(<strong>通用异步收发器</strong>),<strong>单总线</strong></li></ul><p><strong>常见的串行通信接口</strong></p><div class="table-container"><table><thead><tr><th>通信标准</th><th>引脚说明</th><th>方式</th><th>方向</th></tr></thead><tbody><tr><td><code>UART</code>(通用异步收发器)</td><td><code>TXD</code>:发送端 <code>RXD</code>:接受端 <code>GND</code>:公共地</td><td>异步</td><td>全双工</td></tr><tr><td>单总线(<code>1-wire</code>)</td><td><code>DQ</code>:发送/接受端</td><td>异步</td><td>半双工</td></tr><tr><td><code>SPI</code></td><td><code>SCK</code>:同步时钟 <code>MISO</code>:主机输入，从机输出 <code>MOSI</code>:主机输出，从机输入</td><td>同步</td><td>全双工</td></tr><tr><td><code>I2C</code></td><td><code>SCL</code>:同步时钟 <code>SDA</code>:数据输入/输出端</td><td>同步</td><td>半双工</td></tr></tbody></table></div><h1 id="STM32的串口通信接口"><a href="#STM32的串口通信接口" class="headerlink" title="STM32的串口通信接口"></a>STM32的串口通信接口</h1><ul><li><code>UART</code>:<strong>通用异步收发器</strong></li><li><code>USART</code>:<strong>通用同步异步收发器</strong><br>大容量<code>STM32F10x</code>系列<strong>芯片</strong>,包含<code>3</code>个<code>USART</code>和<code>2</code>个<code>UART</code></li></ul><h2 id="UART引脚连接方法"><a href="#UART引脚连接方法" class="headerlink" title="UART引脚连接方法"></a>UART引脚连接方法</h2><p><code>-RXD</code>:<strong>数据输入引脚</strong><br><code>-TXD</code>:<strong>数据发送引脚</strong></p><ul><li><strong>数据收发端</strong>都是<code>TTL</code>电平<br><img src="/images/USART.png" alt="UART-引脚都是TTL电平"></li><li>与<code>PC</code>的<code>DB9</code>相连<br><img src="/images/CH340G-MAX232-DB9.png" alt="CH340G-MAX232-DB9封装"></li></ul><h3 id="电平"><a href="#电平" class="headerlink" title="电平"></a><strong>电平</strong></h3><p><code>TTL</code><br><code>TTL</code>全名是<strong>晶体管-晶体管逻辑集成电路</strong>(<code>Transistor-Transistor Logic</code>)</p><ul><li><strong>输入高电平最小</strong><code>2V</code>,<strong>输出高电平</strong>最小<code>2.4V</code>,<strong>典型值</strong><code>3.4V</code></li><li><strong>输入低电平最大</strong><code>0.8V</code>,<strong>输出低电平</strong>最大<code>0.4V</code>,<strong>典型值</strong><code>0.2V</code></li></ul><p><code>RS-232</code><br><code>RS232</code></p><ul><li><strong>逻辑</strong><code>1</code>电平<code>(MARK)=-3V～-15V</code></li><li><strong>逻辑</strong><code>0</code>电平<code>(SPACE)=+3～+15V</code></li></ul><p><code>RS-485</code><br><code>RS485</code>是<strong>差分信号进行串行传输</strong></p><ul><li><strong>逻辑</strong><code>1</code>以<strong>两线间的电压差</strong>为<code>+(2~6)V</code>表示</li><li><strong>逻辑</strong><code>0</code>以<strong>两线间的电压差</strong>为<code>-(2~6)V</code>表示</li></ul><h3 id="电平转换"><a href="#电平转换" class="headerlink" title="电平转换"></a><strong>电平转换</strong></h3><p><code>STM32</code>的<code>UART</code>通信接口,电平逻辑为<code>TTL</code><br><code>PC</code>端的接口为<code>USB或者232</code>接口</p><ul><li><p><code>USB</code>转<code>TTL</code><br><code>PC</code>端的<code>USB</code>口,要想与<strong>单片机</strong>的<code>UART</code>通信,需要使用<code>USB&lt;-&gt;TTL</code>芯片,使用前需要安装<code>Windows</code>驱动,比如<code>CH340</code></p></li><li><p><code>TTL</code>转<code>232</code><br><code>PC</code>端的<code>DB9</code>接口,逻辑电平为<code>232</code>,要想与单片机<code>UART</code>进行通信,需要使用<code>TTL&lt;-&gt;232</code>芯片。<br><strong>常用芯片有</strong>：<code>MAX232</code>,<code>MAX232</code><strong>转换芯片</strong>,是<code>TTL</code>电平和<code>RS232</code>电平<strong>专用的双向转换芯片</strong></p></li><li><p><code>USB</code>转<code>232</code><br>如果想用<code>USB&lt;-&gt;232</code>怎么办？<br>可以使用上面两个芯片的结合,先使用<code>USB-&gt;TTL</code>,再使用<code>TTL-&gt;232</code>芯片！</p></li></ul><h2 id="STM32F103ZET6串口引脚"><a href="#STM32F103ZET6串口引脚" class="headerlink" title="STM32F103ZET6串口引脚"></a>STM32F103ZET6串口引脚</h2><p><code>参考-【正点原子】精英STM32F103开发板资料 资料盘(A盘)\7，硬件资料\7，硬件资料\2，芯片资料\STM32F103ZET6.pdf - Table 5.         High-density STM32F103xx pin definitions</code></p><div class="table-container"><table><thead><tr><th style="text-align:center">串口</th><th style="text-align:center"><code>RXD</code></th><th style="text-align:center"><code>TXD</code></th></tr></thead><tbody><tr><td style="text-align:center"><code>1</code></td><td style="text-align:center"><code>PA10</code></td><td style="text-align:center"><code>PA9</code></td></tr><tr><td style="text-align:center"><code>2</code></td><td style="text-align:center"><code>PA3</code></td><td style="text-align:center"><code>PA2</code></td></tr><tr><td style="text-align:center"><code>3</code></td><td style="text-align:center"><code>PB11</code></td><td style="text-align:center"><code>PB10</code></td></tr><tr><td style="text-align:center"><code>4</code></td><td style="text-align:center"><code>PC11</code></td><td style="text-align:center"><code>PC10</code></td></tr><tr><td style="text-align:center"><code>5</code></td><td style="text-align:center"><code>PD2</code></td><td style="text-align:center"><code>PC12</code></td></tr></tbody></table></div><h2 id="UART异步通信特点"><a href="#UART异步通信特点" class="headerlink" title="UART异步通信特点"></a>UART异步通信特点</h2><ul><li><strong>全双工异步</strong>通信</li><li>分数<strong>波特率发生器系统</strong>,提供精确的波特率<ul><li>发送和接受共用的可编程波特率，最高可达<code>4.5Mbits/s</code></li></ul></li><li>可<strong>编程的数据字</strong>长度(<code>8</code>位或者<code>9</code>位)</li><li>可<strong>配置的停止位</strong>(支持<code>1</code>或者<code>2</code>位停止位)</li><li>可<strong>配置</strong>的使用<code>DMA</code>多缓冲器通信</li><li>单独的<strong>发送器和接收器使能位</strong></li><li>检测标志：<strong>接受缓冲器、发送缓冲器空、传输结束标志</strong></li><li>多个<strong>带标志的中断源</strong>(触发中断)</li><li>其他：<strong>校验控制</strong>,四个错误检测标志。</li></ul><h2 id="STM32串口参数"><a href="#STM32串口参数" class="headerlink" title="STM32串口参数"></a>STM32串口参数</h2><ul><li>起始位</li><li>数据位(<code>8</code>位或者<code>9</code>位)</li><li>奇偶校验位(第<code>9</code>位)</li><li>停止位(<code>1,15,2</code>位)</li><li>波特率设置</li></ul><p><img src="/images/usart_数据.png" alt="STM32串口参数"></p><h2 id="STM32串口框架"><a href="#STM32串口框架" class="headerlink" title="STM32串口框架"></a>STM32串口框架</h2><p><img src="/images/USART_SEND_RECEIVE.png" alt="USART_SEND_RECEIVE"></p><p><code>参考-STM32中文参考手册-25.3、USART功能概述</code></p><h3 id="串口时钟来源"><a href="#串口时钟来源" class="headerlink" title="串口时钟来源"></a>串口时钟来源</h3><p><code>APB2ENR: ADC3、USART1、TIM8、SPI1、TIM1、ADC2、ADC1、GPIOA-E、AFIO</code>-<code>PCLK1</code><br><code>APB1ENR: DAC、电源、备份接口、CAN、USB、I2C2、I2C1、UART5、UART4、USART2、SPI3、SPI2、窗口看门狗、TIM7-2</code>-<code>PCLK2</code></p><h3 id="波特率计算"><a href="#波特率计算" class="headerlink" title="波特率计算"></a>波特率计算</h3><p><img src="/images/Baud.png" alt="Baud"></p><ul><li>波特率寄存器(<code>USART_BRR</code>)<ul><li><code>USART_BRR[4:15] =&gt; DIV_Mantissa[11:0]</code>:<code>USARTDIV</code>的整数部分</li><li><code>USART_BRR[0:3]  =&gt; DIV_Fracion[3:0]</code>:<code>USARTDIV</code>的小数部分</li></ul></li></ul><p><strong>波特率计算公式:</strong></p><script type="math/tex; mode=display">baudrate = \frac{f_{PCLK_x}}{16 \times USARTDIV}</script><p>以串口<code>1</code>为例,$f_PCLK1$为<code>72MHz</code>,要达到<code>115200</code>的波特率,则<code>USARTDIV</code>计算如下:</p><script type="math/tex; mode=display">USARTDIV = \frac{f_{PCLK_1}}{16 \times baudrate} = 39.0625</script><p>所以:<br><code>DIV_Fracion</code>  $  = 16\times 0.0625 = 1 = 0X01 $ (小数部分乘以<code>16</code>)<br><code>DIV_Mantissa</code>  $  = 39 = 0X27 $</p><h1 id="串口通信原理"><a href="#串口通信原理" class="headerlink" title="串口通信原理"></a>串口通信原理</h1><p>&#x1F4E3; <code>参考-STM32中文参考手册_V10.pdf-25.通用同步异步收发器</code></p><h2 id="串口通信基本原理"><a href="#串口通信基本原理" class="headerlink" title="串口通信基本原理"></a>串口通信基本原理</h2><h2 id="串口配置的一般步骤"><a href="#串口配置的一般步骤" class="headerlink" title="串口配置的一般步骤"></a>串口配置的一般步骤</h2><ul><li><strong>串口时钟使能</strong>,<strong>GPIO时钟使能</strong>:<code>RCC_APB2PeriphClockCmd()</code>;<ul><li>使能串口时钟<code>HAL_UART_MspInit/__HAL_RCC_USART1_CLK_ENABLE</code></li><li>使能串口对应的引脚所对应的时钟<code>HAL_UART_MspInit/__HAL_RCC_GPIOA_CLK_ENABLE</code></li></ul></li><li><strong>串口复位</strong>:<code>USART_DeInit()</code>;<strong> 这一步不是必须的</strong></li><li><code>GPIO</code><strong>端口模式设置</strong>:<code>GPIO_Init();</code> &#x1F4E3;参考<code>STM32中文参考手册_V10.pdf - 8.1.11 外设的GPIO配置 - 表 21 USART</code><ul><li><img src="/images/USART_GPIO_CONFIG.png" alt="USART_GPIO_CONFIG"></li></ul></li><li><strong>串口参数初始化</strong>:<code>USART_Init();</code><ul><li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span> BaudRate;                  </span><br><span class="line">  <span class="keyword">uint32_t</span> WordLength;                </span><br><span class="line">  <span class="keyword">uint32_t</span> StopBits;                 </span><br><span class="line">  <span class="keyword">uint32_t</span> Parity;                  </span><br><span class="line">  <span class="keyword">uint32_t</span> Mode;                      </span><br><span class="line">  <span class="keyword">uint32_t</span> HwFlowCtl;                </span><br><span class="line">  <span class="keyword">uint32_t</span> OverSampling;              </span><br><span class="line">&#125; UART_InitTypeDef;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li></ul></li><li><strong>开启中断并且初始化</strong><code>NVIC</code>(如果需要开启中断才需要这个步骤)<ul><li><code>NVIC_Init();</code></li><li><code>USART_ITConfig();</code></li></ul></li><li><strong>使能串口</strong>:<code>USART_Cmd();</code></li><li><strong>编写中断处理函数</strong>：<code>USARTx_IRQHandler();</code><ul><li>&#x1F4E3;<strong>如何查看中断函数名(没有返回参数,没有输入参数)</strong>:在启动文件中<code>startup_stm32f103xe.s</code>查找</li></ul></li><li><strong>串口数据收发</strong><ul><li><code>void USART_SendData();//发送数据到串口，DR</code></li><li><code>uint16_t USART_ReceiveData();//接受数据，从DR读取接受到的数据</code></li></ul></li><li><strong>串口传输状态获取</strong>：<ul><li><code>FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG);</code></li><li><code>void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT);</code></li></ul></li></ul><h2 id="重要的串口寄存器"><a href="#重要的串口寄存器" class="headerlink" title="重要的串口寄存器"></a>重要的串口寄存器</h2><p>&#x1F4E3; <code>参考-STM32中文参考手册_V10.pdf-25.通用同步异步收发器</code></p><ul><li>状态寄存器(USART_SR)<ul><li><code>bit[5]:RXNE</code>-读数据寄存器非空 <code>(Read data register not empty)</code></li></ul></li><li>数据寄存器(USART_DR)</li></ul><h1 id="CubeMX与串口"><a href="#CubeMX与串口" class="headerlink" title="CubeMX与串口"></a>CubeMX与串口</h1><p>&#x1F4E3;参考<a href="https://blog.csdn.net/qq_33728095/article/details/95809215">使用CubeMX配置串口</a>,参考<a href="https://blog.csdn.net/qq_33728095/article/details/95809215">串口接收中断</a></p><h2 id="使能中断"><a href="#使能中断" class="headerlink" title="使能中断"></a>使能中断</h2><p>&#x1F349;在完成串口函数初始化后,串口的接收状态标志位变为<code>huart-&gt;RxState = HAL_UART_STATE_READY</code></p><p>调用<code>HAL_UART_Receive_IT</code>函数<strong>配置中断使能</strong>, 即<strong>使能</strong><code>huart-&gt;RxXferCount = Size</code>字节<strong>中断</strong>;<br>&#x1F349;同时设置了<code>huart-&gt;ReceptionType = HAL_UART_RECEPTION_STANDARD;</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HAL_StatusTypeDef <span class="title">HAL_UART_Receive_IT</span><span class="params">(UART_HandleTypeDef *huart, <span class="keyword">uint8_t</span> *pData, <span class="keyword">uint16_t</span> Size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HAL_UART_Receive_IT 会调用 UART_Start_Receive_IT</span></span><br><span class="line"></span><br><span class="line">UART_Start_Receive_IT(huart, pData, Size)&#123;</span><br><span class="line">huart-&gt;pRxBuffPtr = pData;</span><br><span class="line">  huart-&gt;RxXferSize = Size;</span><br><span class="line">  huart-&gt;RxXferCount = Size;</span><br><span class="line"></span><br><span class="line">  huart-&gt;ErrorCode = HAL_UART_ERROR_NONE;</span><br><span class="line">  huart-&gt;RxState = HAL_UART_STATE_BUSY_RX;</span><br><span class="line">  <span class="comment">/* Process Unlocked */</span></span><br><span class="line">  __HAL_UNLOCK(huart);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Enable the UART Parity Error Interrupt */</span></span><br><span class="line">  __HAL_UART_ENABLE_IT(huart, UART_IT_PE);<span class="comment">// 使能奇偶校验错误中断</span></span><br><span class="line">  <span class="comment">/* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */</span></span><br><span class="line">  __HAL_UART_ENABLE_IT(huart, UART_IT_ERR);<span class="comment">// 错误中断使能</span></span><br><span class="line">  <span class="comment">/* Enable the UART Data Register not empty Interrupt */</span></span><br><span class="line">  __HAL_UART_ENABLE_IT(huart, UART_IT_RXNE);<span class="comment">// 接收缓冲区非空中断使能</span></span><br><span class="line">  <span class="keyword">return</span> HAL_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&#x1F349;注意<code>huart-&gt;RxState = HAL_UART_STATE_BUSY_RX;</code></p><h2 id="串口中断回调函数"><a href="#串口中断回调函数" class="headerlink" title="串口中断回调函数"></a>串口中断回调函数</h2><p>参考<a href="https://zhuanlan.zhihu.com/p/147414331">HAL库-串口中断回调函数背后的逻辑</a><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART1_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  HAL_UART_IRQHandler(&amp;huart1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HAL_UART_IRQHandler</span><span class="params">(UART_HandleTypeDef *huart)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> isrflags = READ_REG(huart-&gt;Instance-&gt;SR);</span><br><span class="line">  <span class="keyword">uint32_t</span> cr1its = READ_REG(huart-&gt;Instance-&gt;CR1);</span><br><span class="line">  <span class="keyword">uint32_t</span> cr3its = READ_REG(huart-&gt;Instance-&gt;CR3);</span><br><span class="line">  <span class="keyword">uint32_t</span> errorflags = <span class="number">0x00</span>U;</span><br><span class="line">  <span class="keyword">uint32_t</span> dmarequest = <span class="number">0x00</span>U;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>判断是否<strong>有奇偶校验错误</strong>、<strong>有帧错误</strong>、<strong>噪声错误</strong>、<strong>过载错误</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">errorflags = (isrflags &amp; (<span class="keyword">uint32_t</span>)(USART_SR_PE | USART_SR_FE | USART_SR_ORE | USART_SR_NE));</span><br><span class="line"><span class="keyword">if</span> (errorflags == RESET)</span><br><span class="line">&#123;<span class="comment">// 没有上述错误</span></span><br><span class="line">  <span class="comment">/* UART in mode Receiver -------------------------------------------------*/</span></span><br><span class="line">  <span class="keyword">if</span> (((isrflags &amp; USART_SR_RXNE) != RESET) &amp;&amp; ((cr1its &amp; USART_CR1_RXNEIE) != RESET))</span><br><span class="line">  &#123;<span class="comment">// 读数据寄存器非空 且 使能了 接收缓冲区非空中断使能</span></span><br><span class="line">    UART_Receive_IT(huart);<span class="comment">// 调用接收中断函数</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><code>UART_Receive_IT</code>串口<strong>接收中断函数</strong></li><li><code>UART_Receive_IT</code><br><code>UART_Receive_IT</code>当串口接收到的字节个数达到<code>huart-&gt;RxXferCount</code>后,调用<code>HAL_UART_RxCpltCallback(huart);</code>函数;而<code>HAL_UART_RxCpltCallback</code>被定义在文件<code>stm32f1xx_hal_uart.c</code>中,如下所示:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __weak   __attribute__((weak))</span></span><br><span class="line"><span class="function">__weak <span class="keyword">void</span> <span class="title">HAL_UART_RxCpltCallback</span><span class="params">(UART_HandleTypeDef *huart)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Prevent unused argument(s) compilation warning */</span></span><br><span class="line">  UNUSED(huart);</span><br><span class="line">  <span class="comment">/* <span class="doctag">NOTE:</span> This function should not be modified, when the callback is needed,</span></span><br><span class="line"><span class="comment">           the HAL_UART_RxCpltCallback could be implemented in the user file</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>&#x1F349;<code>HAL_UART_RxCpltCallback</code>被定义为<strong>弱符号</strong>,所以如果<strong>用户自定义</strong>了<code>HAL_UART_RxCpltCallback</code>就会<strong>调用用户定义</strong>的<code>HAL_UART_RxCpltCallback</code></li></ul><h2 id="串口回调函数的使用"><a href="#串口回调函数的使用" class="headerlink" title="串口回调函数的使用"></a>串口回调函数的使用</h2><p>开启一字节中断,参考以下代码:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> rDataBuffer[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">while</span>(HAL_UART_Receive_IT(&amp;huart1, rDataBuffer, <span class="number">1</span>) != HAL_OK);</span><br></pre></td></tr></table></figure></p><blockquote><p>&#x1F349;那为何在这里需要用<code>while</code>不断循环检测返回值呢？因为可能<code>RX</code>处于<strong>正忙状态</strong>。如果在<code>RX</code>正忙状态调用<code>HAL_UART_Receive_IT</code>,<strong>可能就会导致不是按预期执行的。</strong></p></blockquote><h1 id="串口接收和发送"><a href="#串口接收和发送" class="headerlink" title="串口接收和发送"></a>串口接收和发送</h1><h2 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h2><p>使用<code>STM32CubeMX</code>中的<code>Makefile</code>导出工程文件时,无法像<code>Keil uVision</code>一样使用<code>Use MicroLIB</code><br><img src="/images/Use_MicroLIB.png" alt="Use_MicroLIB"><br>&#x1F349;<strong>解决方案1</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *__format, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list <span class="built_in">list</span>;</span><br><span class="line">    va_start(<span class="built_in">list</span>, __format);</span><br><span class="line">    HAL_StatusTypeDef status = flushOut(__format, <span class="built_in">list</span>);</span><br><span class="line">    va_end(<span class="built_in">list</span>); <span class="comment">// 置空 args</span></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&#x1F349;<strong>解决方案2</strong><br>使用<code>STM32CubeMX</code>导出项目,但使用Makefile编译,编译器使用<code>arm-none-eabi-gcc</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _write(<span class="keyword">int</span> fd, <span class="keyword">unsigned</span> <span class="keyword">char</span> *pBuffer, <span class="keyword">int</span> size)</span><br><span class="line">&#123;</span><br><span class="line">  HAL_UART_Transmit(&amp;huart1, pBuffer, size, <span class="number">0xff</span>);</span><br><span class="line">  <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>为了能够打印浮点数在<code>Makefile</code>中添加<code>-u _printf_float</code><br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDFLAGS = <span class="variable">$(MCU)</span> -specs=nano.specs -T<span class="variable">$(LDSCRIPT)</span> <span class="variable">$(LIBDIR)</span> <span class="variable">$(LIBS)</span> -Wl,-Map=<span class="variable">$(BUILD_DIR)</span>/<span class="variable">$(TARGET)</span>.map,--cref -Wl,--gc-sections -u _printf_float</span><br></pre></td></tr></table></figure></p><p><strong>日志等级宏</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG(level, format, ...)                                              \</span></span><br><span class="line"><span class="meta">    &#123;                                                                        \</span></span><br><span class="line"><span class="meta">        switch (level)                                                       \</span></span><br><span class="line"><span class="meta">        &#123;                                                                    \</span></span><br><span class="line"><span class="meta">        case Log_Level_INFO:                                                 \</span></span><br><span class="line"><span class="meta">            printf(<span class="meta-string">&quot;[ \033[1m\033[32mINFO\033[0m ] : &quot;</span> format, __VA_ARGS__); \</span></span><br><span class="line"><span class="meta">            break;                                                           \</span></span><br><span class="line"><span class="meta">        case Log_Level_ERR:                                                  \</span></span><br><span class="line"><span class="meta">            printf(<span class="meta-string">&quot;[ \033[1m\033[31mERRO\033[0m ] : &quot;</span> format, __VA_ARGS__); \</span></span><br><span class="line"><span class="meta">            break;                                                           \</span></span><br><span class="line"><span class="meta">        case Log_Level_WARN:                                                 \</span></span><br><span class="line"><span class="meta">            printf(<span class="meta-string">&quot;[ \033[1m\033[33mWARN\033[0m ] : &quot;</span> format, __VA_ARGS__); \</span></span><br><span class="line"><span class="meta">            break;                                                           \</span></span><br><span class="line"><span class="meta">        default:                                                             \</span></span><br><span class="line"><span class="meta">            break;                                                           \</span></span><br><span class="line"><span class="meta">        &#125;                                                                    \</span></span><br><span class="line"><span class="meta">        printf(ENTER);                                                       \</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br></pre></td></tr></table></figure></p><h2 id="串口接收函数"><a href="#串口接收函数" class="headerlink" title="串口接收函数"></a>串口接收函数</h2><p>在使能串口中断后,用<code>HAL_UART_Receive_IT(&amp;huart1, rDataBuffer, size)</code>打开<code>size</code>字节中断<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readyRecv_IT</span><span class="params">(<span class="keyword">uint16_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (HAL_UART_Receive_IT(&amp;huart1, rDataBuffer, size) != HAL_OK)</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HAL_UART_RxCpltCallback</span><span class="params">(UART_HandleTypeDef *huart)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (huart == &amp;huart1)</span><br><span class="line">  &#123;</span><br><span class="line">    MessageSerial_t *pMessageSerial = (MessageSerial_t *)(rDataBuffer);</span><br><span class="line">    <span class="keyword">if</span> (checkFrame(pMessageSerial))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// Log(I, &quot;get new frame&quot;);</span></span><br><span class="line">      isGetNewFrame = <span class="literal">true</span>;</span><br><span class="line">      <span class="built_in">memcpy</span>(&amp;message, &amp;(pMessageSerial-&gt;message), <span class="keyword">sizeof</span>(Message_t));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// Log(W, &quot;frame error&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (HAL_UART_Receive_IT(&amp;huart1, rDataBuffer, <span class="keyword">sizeof</span>(MessageSerial_t)) != HAL_OK)</span><br><span class="line">      ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="使用STM32CubeMX配置USART"><a href="#使用STM32CubeMX配置USART" class="headerlink" title="使用STM32CubeMX配置USART"></a>使用STM32CubeMX配置USART</h1><p><img src="/images/STM32CubeMX_USART/1.png" alt="选择开发板"><br><img src="/images/STM32CubeMX_USART/2.png" alt="选外部高速晶振"><br><img src="/images/STM32CubeMX_USART/3.png" alt="配置时钟系统"><br><img src="/images/STM32CubeMX_USART/4.png" alt="配置串口和中断"><br><img src="/images/STM32CubeMX_USART/5.png" alt="配置中断优先级分组和中断的抢占/响应优先级"></p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux&amp;umask</title>
      <link href="/2022/03/09/Linux-umask/"/>
      <url>/2022/03/09/Linux-umask/</url>
      
        <content type="html"><![CDATA[<p> <code>Linux</code>是通过<strong>使用</strong><code>umask</code><strong>默认权限</strong>来<strong>给所有新建的文件</strong>和<strong>目录赋予初始权限的</strong></p><h1 id="查看umask"><a href="#查看umask" class="headerlink" title="查看umask"></a>查看umask</h1><p>通过<code>umask</code>命令即可,即可查看<code>umask</code>默认权限<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  temporary_ws <span class="built_in">umask</span> <span class="comment"># 普通用户默认是 0002</span></span><br><span class="line">002</span><br><span class="line">➜  temporary_ws su <span class="comment"># root用户默认是0022</span></span><br><span class="line">Password:</span><br><span class="line">root@tangshp-desktop:/home/tangshp/Code_ws/temporary_ws<span class="comment"># umask</span></span><br><span class="line">0022</span><br></pre></td></tr></table></figure></p><ul><li><code>umask</code><strong>默认权限</strong>确实由<code>4</code>个<strong>八进制数</strong>组成,但第<code>1</code>个<strong>数代表的是文件所具有的特殊权限</strong>(<code>SetUID、SetGID、Sticky BIT</code>)</li><li><code>后 3 位数字</code>分别对应<strong>拥有者</strong>、<strong>群组</strong>、<strong>其它组</strong></li></ul><h2 id="修改umask"><a href="#修改umask" class="headerlink" title="修改umask"></a>修改umask</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  temporary_ws <span class="built_in">umask</span> 077</span><br><span class="line">➜  temporary_ws <span class="built_in">umask</span></span><br><span class="line">077</span><br></pre></td></tr></table></figure><h1 id="初始权限计算"><a href="#初始权限计算" class="headerlink" title="初始权限计算"></a>初始权限计算</h1><center><font face="黑体" color="black" size="3">文件(或目录)的初始权限 = 文件(或目录)的最大默认权限 - umask权限</font></center><p>文件的<strong>最大默认权限</strong>是<code>666</code>,<strong>换算成字母</strong>就是<code>-rw-rw-rw-</code>,使用<strong>文件的任何用户</strong>都<strong>没有执行</strong>(<code>x</code>)<strong>权限</strong></p><blockquote><p><strong>原因很简单,执行权限是文件的最高权限,赋予时绝对要慎重,因此绝不能在新建文件的时候就默认赋予,只能通过用户手工赋予</strong></p></blockquote><h2 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h2><h3 id="普通用户"><a href="#普通用户" class="headerlink" title="普通用户"></a>普通用户</h3><ul><li><p>普通用户创建文件<br><code>-rw-rw-rw-</code> - 文件的<strong>最大默认权限</strong><br><code>-00-00-0w-</code> - <code>umask</code>的<strong>当前值</strong><br><code>-rw-rw-r0-</code> - <code>umask_002.txt</code>的权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  temporary_ws <span class="built_in">umask</span> 002</span><br><span class="line">➜  temporary_ws</span><br><span class="line">➜  temporary_ws</span><br><span class="line">➜  temporary_ws <span class="built_in">echo</span> <span class="string">&quot;umask is 002&quot;</span> &gt; umask_002.txt</span><br><span class="line">➜  temporary_ws ls -l</span><br><span class="line">-rw-rw-r-- 1 tangshp tangshp 13 3月   9 21:14 umask_002.txt</span><br></pre></td></tr></table></figure></li><li><p>减法<br><code>-rw0-rw0-rw0-</code> - 文件的<strong>最大默认权限</strong><br><code>-000-0wx-0wx-</code> - <code>umask</code>的<strong>当前值</strong><br><code>-rw0-r00-r00-</code> - <code>umask_002.txt</code>的权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  temporary_ws <span class="built_in">umask</span> 033</span><br><span class="line">➜  temporary_ws <span class="built_in">umask</span></span><br><span class="line">033</span><br><span class="line">➜  temporary_ws <span class="built_in">echo</span> <span class="string">&quot;umask is 033&quot;</span> &gt; umask_033.txt</span><br><span class="line">➜  temporary_ws ls -l *033*</span><br><span class="line">-rw-r--r-- 1 tangshp tangshp 13 3月   9 21:38 umask_033.txt</span><br></pre></td></tr></table></figure></li></ul><p>🔓 <strong>掩码计算的逻辑</strong><br>如果掩码为<code>033</code>,<br><code>0000 0011 0011</code>-<code>umask</code>对应的<strong>二进制</strong><br><code>1111 1100 1100</code>-<code>umask</code>对应的<strong>二进制反码</strong><br><code>0110 0110 0110</code>-文件的<strong>最大默认权限</strong><br><code>0110 0100 0100</code>-<code>umask</code>对应的<strong>二进制反码</strong> 与 文件的<strong>最大默认权限</strong>进行<strong>位与运算</strong>, 即为<code>644-rw-r-r-</code></p><blockquote><p><code>umask</code>取反后,与文件的<strong>最大默认权限</strong>进行<strong>位与运算</strong></p></blockquote><ul><li>修改<code>umask</code>后,<strong>创建文件</strong><br><code>-rw0-rw0-rw0-</code> - 文件的<strong>最大默认权限</strong><br><code>-000-rwx-rwx-</code> - <code>umask</code>的<strong>当前值</strong><br><code>-rw0-000-000-</code> - <code>umask_077.txt</code>的权限<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  temporary_ws <span class="built_in">umask</span> 077</span><br><span class="line">➜  temporary_ws <span class="built_in">umask</span></span><br><span class="line">077</span><br><span class="line">➜  temporary_ws <span class="built_in">echo</span> <span class="string">&quot;umask is 077&quot;</span> &gt; umask_077.txt</span><br><span class="line">➜  temporary_ws ls -l</span><br><span class="line">-rw------- 1 tangshp tangshp 13 3月   9 21:19 umask_077.txt</span><br></pre></td></tr></table></figure></li></ul><h3 id="root用户"><a href="#root用户" class="headerlink" title="root用户"></a>root用户</h3><p><code>-rw0-rw0-rw0-</code> - 文件的<strong>最大默认权限</strong><br><code>-000-0w0-0w0-</code> - <code>umask</code>的<strong>当前值-默认为022</strong><br><code>-rw0-r00-r00-</code> - <code>root_umask_022.txt</code>的权限<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@tangshp-desktop:/home/tangshp/Code_ws/temporary_ws<span class="comment"># echo &quot;I&#x27;m root, umask is 022&quot; &gt; root_umask_022.txt</span></span><br><span class="line">root@tangshp-desktop:/home/tangshp/Code_ws/temporary_ws<span class="comment"># ls -l</span></span><br><span class="line">total 12</span><br><span class="line">-rw-r--r-- 1 root    root    23 3月   9 21:29 root_umask_022.txt</span><br></pre></td></tr></table></figure></p><h2 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h2><h3 id="创建文件-1"><a href="#创建文件-1" class="headerlink" title="创建文件"></a>创建文件</h3><p><code>-rwx-rwx-rwx-</code> - 文件夹的<strong>最大默认权限</strong><br><code>-000-000-0w0-</code> - <code>umask</code>的<strong>当前值-默认为002</strong><br><code>-rwx-rwx-r0x-</code> - <code>root_umask_022.txt</code>的权限<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  temporary_ws <span class="built_in">umask</span></span><br><span class="line">002</span><br><span class="line">➜  temporary_ws mkdir current_umask_002</span><br><span class="line">➜  temporary_ws ls -l</span><br><span class="line">drwxrwxr-x 2 tangshp tangshp 4096 3月   9 21:34 current_umask_002</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Linux的基本使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux,权限 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32-F103ZET6-08-NVIC中断</title>
      <link href="/2022/03/07/Embedded-System-00/STM32-F103ZET6-08-NVIC%E4%B8%AD%E6%96%AD/"/>
      <url>/2022/03/07/Embedded-System-00/STM32-F103ZET6-08-NVIC%E4%B8%AD%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<p><code>NVIC</code>:<strong>内嵌向量中断控制器</strong>(<code>Nested Vectored Interrupt Controller</code>)</p><h1 id="CM3中断介绍"><a href="#CM3中断介绍" class="headerlink" title="CM3中断介绍"></a>CM3中断介绍</h1><h2 id="CM3中断数量"><a href="#CM3中断数量" class="headerlink" title="CM3中断数量"></a>CM3中断数量</h2><p><code>CM3</code><strong>内核支持</strong><code>256</code>个<strong>中断</strong>,<strong>其中包含了</strong><code>16</code><strong>个内核中断</strong>和<code>240</code>个<strong>外部中断</strong>,并且具有<code>256</code><strong>级的可编程中断设置</strong></p><p><code>STM32</code>并<strong>没有使用</strong><code>CM3</code><strong>内核的全部东西</strong>,而是<strong>只用了它的一部分</strong></p><p><code>STM32</code>有<code>84</code>个<strong>中断</strong>,包括<code>16</code>个<strong>内核中断</strong>和<code>68</code>个<strong>可屏蔽中断</strong>(即外部中断),具有<code>16</code><strong>级可编程的中断优先级</strong></p><p><code>STM32F103</code>系列上面,又只有<code>60</code>个<strong>可屏蔽中断</strong>(在<code>107</code>系列才有<code>68</code>个)</p><p><code>STM32F10xxx可屏蔽中断详情参考-STM32中文参考手册_V10.pdf-9.1.2中断和异常向量-表55</code></p><h2 id="中断优先级分组"><a href="#中断优先级分组" class="headerlink" title="中断优先级分组"></a>中断优先级分组</h2><p>通过设置<strong>寄存器</strong><code>AIRCR[10:8]</code>,对<code>STM32</code><strong>的所有中断进行分组</strong>,<strong>组</strong><code>0~4</code>。确定组后,也就<strong>确定了</strong>每个中断<strong>可设置抢占优先级的控制位数</strong>和<strong>响应优先级值控制位数</strong></p><p>下图<code>参考-Cortex-M3权威指南(中文).pdf - 表 D.13</code><br><img src="/images/AIRCR.png" alt="应用程序中断及复位控制寄存器(AIRCR)"></p><div class="table-container"><table><thead><tr><th style="text-align:center">组</th><th style="text-align:center"><code>AIRCR[10：8]</code></th><th style="text-align:center"><code>IP bit[7：4]</code>分配情况</th><th style="text-align:center">分配结果</th></tr></thead><tbody><tr><td style="text-align:center"><code>0</code></td><td style="text-align:center"><code>111</code></td><td style="text-align:center"><code>0:4</code></td><td style="text-align:center"><code>0</code>位抢占优先级，<code>4</code>位响应优先级</td></tr><tr><td style="text-align:center"><code>1</code></td><td style="text-align:center"><code>110</code></td><td style="text-align:center"><code>1:3</code></td><td style="text-align:center"><code>1</code>位抢占优先级，<code>3</code>位响应优先级</td></tr><tr><td style="text-align:center"><code>2</code></td><td style="text-align:center"><code>101</code></td><td style="text-align:center"><code>2:2</code></td><td style="text-align:center"><code>2</code>位抢占优先级，<code>2</code>位响应优先级</td></tr><tr><td style="text-align:center"><code>3</code></td><td style="text-align:center"><code>100</code></td><td style="text-align:center"><code>3:1</code></td><td style="text-align:center"><code>3</code>位抢占优先级，<code>1</code>位响应优先级</td></tr><tr><td style="text-align:center"><code>4</code></td><td style="text-align:center"><code>011</code></td><td style="text-align:center"><code>4:0</code></td><td style="text-align:center"><code>4</code>位抢占优先级，<code>0</code>位响应优先级</td></tr></tbody></table></div><ul><li><p><code>STM32</code>的<code>16</code><strong>级可编程的中断优先级</strong><br><code>IP bit[7：4]</code>共<code>4</code>个<code>bit</code>,供<strong>设置抢占优先级</strong>和<strong>响应优先级</strong></p></li><li><p><strong>抢占优先级</strong><code>&amp;</code> <strong>响应优先级区别</strong></p><ul><li><strong>高优先级</strong>的<strong>抢占优先级</strong>是<strong>可以打断正在进行</strong>的<strong>低抢占优先级中断</strong>的。</li><li><strong>抢占优先级相同</strong>的<strong>中断</strong>,<strong>高响应优先级不可以打断低响应优先级的中断</strong>。</li><li><strong>抢占优先级相同</strong>的<strong>中断</strong>,当<strong>两个中断同时发生的情况</strong>下,<strong>哪个响应优先级高</strong>,<strong>哪个先执行</strong>。</li><li>如果两个中断的<strong>抢占优先级</strong>和<strong>响应优先级</strong>都是一样的话,则看<strong>哪个中断先发生就先执行</strong>；<blockquote><p><strong>数字越小</strong>,<strong>优先级越大</strong></p></blockquote></li></ul></li></ul><p>&#x1F449;假定设置<strong>中断优先级组</strong>为<code>2</code><br><strong>设置中断</strong><code>3</code>(<code>RTC</code>中断)的<strong>抢占优先级</strong>为<code>2</code>,<strong>响应优先级</strong>为<code>1</code>。<br><strong>设置中断</strong><code>6</code>(外部中断<code>0</code>)的<strong>抢占优先级</strong>为<code>3</code>,<strong>响应优先级</strong>为<code>0</code>。<br><strong>设置中断</strong><code>7</code>(外部中断<code>1</code>)的<strong>抢占优先级</strong>为<code>2</code>,<strong>响应优先级</strong>为<code>0</code>。</p><p>这<code>3</code>个<strong>中断的优先级顺序</strong>为:<strong>中断</strong><code>7</code>&gt;<strong>中断</strong><code>3</code>&gt;<strong>中断</strong><code>6</code></p><blockquote><p>一般情况下,系统代码执行过程中,<strong>只设置一次中断优先级分组</strong>,比如<strong>分组2</strong>,设置好分组之后<strong>一般不会再改变分组</strong>。<strong>随意改变分组会导致中断管理混乱,程序出现意想不到的执行结果</strong></p></blockquote><h2 id="中断配置"><a href="#中断配置" class="headerlink" title="中断配置"></a>中断配置</h2><p>&#x1F4E3; 设置中断优先级分组</p><h1 id="外部中断概述"><a href="#外部中断概述" class="headerlink" title="外部中断概述"></a>外部中断概述</h1><p><code>STM32</code>的每个<code>IO</code>都可以作为<strong>外部中断输入</strong>,<code>STM32</code>的<strong>中断控制器支持</strong><code>19</code>个<strong>外部中断/事件请求</strong>：</p><ul><li>线<code>0~15</code>：对应外部<code>IO</code>口的输入中断。</li><li>线<code>16</code>：连接到<code>PVD</code>输出。</li><li>线<code>17</code>：连接到<code>RTC</code>闹钟事件。</li><li>线<code>18</code>：连接到<code>USB</code>唤醒事件。</li></ul><p>每个<strong>外部中断线</strong>可以<strong>独立的配置触发方式</strong>(<strong>上升沿，下降沿或者双边沿触发</strong>),<strong>触发/屏蔽,专用</strong>的状态位。</p><h2 id="线0-15与IO口映射关系"><a href="#线0-15与IO口映射关系" class="headerlink" title="线0~15与IO口映射关系"></a>线<code>0~15</code>与<code>IO</code>口映射关系</h2><p>参考<code>STM32中文参考手册_V10.pdf - 9.2.5 外部中断/事件线路映像</code><br><img src="/images/外部中断通用I_O映像.png" alt="外部中断通用I/O映像"></p><p><code>STM32F103ZET6</code>中断线有<code>EXTI0、、、EXTI15</code>,共<code>16</code>条中断线,每条中断线<code>EXTIx</code>与<code>PAx、PBx、、、PGx</code>关联,同时只有<code>PAx、PBx、、、PGx</code>中的<strong>一个引脚作为中断线</strong>作为<code>EXTIx</code>的<strong>中断输入</strong>;</p><p>对于<strong>每个中断线</strong>(<code>EXTIx</code>),我们可以<strong>设置相应的触发方式</strong>(上升沿触发、下降沿触发、边沿触发)以及使能</p><h2 id="中断服务函数"><a href="#中断服务函数" class="headerlink" title="中断服务函数"></a>中断服务函数</h2><p>是不是<code>16</code>个<strong>中断线</strong>就可以分配<code>16</code>个<strong>中断服务函数呢</strong>？</p><p>实际上,<code>IO</code>口<strong>外部中断</strong>在<strong>中断向量表中只分配了</strong><code>7</code><strong>个中断向量</strong>,也就是<strong>只能使用</strong><code>7</code><strong>个中断服务函数</strong><br>&#x1F449;<strong>参考</strong><code>STM32中文参考手册_V10.pdf - 9.1.2 中断和异常向量 -  表55 - 其它STM32F10xxx产品(小容量、中容量和大容量)的向量表</code><br><img src="/images/中断向量.png" alt="中断向量"><br>使用<code>STM32CubeMX</code>导出项目时,有汇编文件<code>startup_stm32f103xe.s</code>,其中包含如下中断服务函数<br><img src="/images/中断服务函数名.png" alt="中断服务函数名"></p><h2 id="常用中断库函数"><a href="#常用中断库函数" class="headerlink" title="常用中断库函数"></a>常用中断库函数</h2><h3 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h3><ul><li><p>常用函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1th</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_EXTILineConfig</span><span class="params">(<span class="keyword">uint8_t</span> GPIO_PortSource, <span class="keyword">uint8_t</span> GPIO_PinSource)</span></span>;</span><br><span class="line">   <span class="comment">//设置IO口与中断线的映射关系</span></span><br><span class="line"><span class="comment">// 2nd</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI_Init</span><span class="params">(EXTI_InitTypeDef* EXTI_InitStruct)</span></span>;</span><br><span class="line"> <span class="comment">//初始化中断线：触发方式等</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3rd</span></span><br><span class="line"><span class="function">ITStatus <span class="title">EXTI_GetITStatus</span><span class="params">(<span class="keyword">uint32_t</span> EXTI_Line)</span></span>;</span><br><span class="line"><span class="comment">//判断中断线中断状态，是否发生</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4th 必须手动清零</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI_ClearITPendingBit</span><span class="params">(<span class="keyword">uint32_t</span> EXTI_Line)</span></span>;</span><br><span class="line"><span class="comment">//清除中断线上的中断标志位</span></span><br></pre></td></tr></table></figure></li><li><p>中断触发方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span> EXTI_Line;<span class="comment">// 哪条中断线             </span></span><br><span class="line">  EXTIMode_TypeDef EXTI_Mode;<span class="comment">// 中断or事件      </span></span><br><span class="line">  EXTITrigger_TypeDef EXTI_Trigger;<span class="comment">// 触发方式</span></span><br><span class="line">  FunctionalState EXTI_LineCmd;<span class="comment">// 使能or使能</span></span><br><span class="line">&#125;EXTI_InitTypeDef;</span><br></pre></td></tr></table></figure></li><li><p>外部中断的<strong>一般配置步骤</strong></p><ul><li>1、初始化<code>IO</code>口为<strong>输入</strong>。<code>GPIO_Init();</code></li><li>2、开启<code>IO</code>口<strong>复用时钟</strong>。<code>RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);</code> &#x1F349;</li><li>3、设置<code>IO</code>口与中断线的<strong>映射关系</strong>。<code>void GPIO_EXTILineConfig();</code></li><li>4、初始化<strong>线上中断，设置触发条件</strong>等。<code>EXTI_Init();</code></li><li>5、配置中断分组<code>（NVIC）</code>,并<strong>使能中断</strong>。<code>NVIC_Init();</code></li><li>6、编写<strong>中断服务函数</strong>。<code>EXTIx_IRQHandler();</code></li><li>7、<strong>清除中断标志位</strong><code>EXTI_ClearITPendingBit();</code></li></ul></li></ul><h3 id="STM32CubeMX"><a href="#STM32CubeMX" class="headerlink" title="STM32CubeMX"></a>STM32CubeMX</h3><ul><li><code>GPIO</code>端口中断配置</li></ul><p><img src="/images/STM32CubeMX_EXTI/1.png" alt="端口模式配置"><br><img src="/images/STM32CubeMX_EXTI/2.png" alt="使能中断"><br><img src="/images/STM32CubeMX_EXTI/3.png" alt="中断优先级分组和抢占/响应优先级"></p><ul><li>回调函数<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EXTI0_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span><span class="comment">// 标准库中的中断服务函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HAL_GPIO_EXTI_IRQHandler</span><span class="params">(<span class="keyword">uint16_t</span> GPIO_Pin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != <span class="number">0x00</span>u)</span><br><span class="line">  &#123;<span class="comment">// 中断挂起位是否置1</span></span><br><span class="line">    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);<span class="comment">// 清除中断挂起位</span></span><br><span class="line">    HAL_GPIO_EXTI_Callback(GPIO_Pin);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// weak函数</span></span><br><span class="line"><span class="function">__weak <span class="keyword">void</span> <span class="title">HAL_GPIO_EXTI_Callback</span><span class="params">(<span class="keyword">uint16_t</span> GPIO_Pin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  UNUSED(GPIO_Pin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32-F103ZET6-07-端口复用&amp;重映射</title>
      <link href="/2022/03/06/Embedded-System-00/STM32-F103ZET6-07-%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8-%E9%87%8D%E6%98%A0%E5%B0%84/"/>
      <url>/2022/03/06/Embedded-System-00/STM32-F103ZET6-07-%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8-%E9%87%8D%E6%98%A0%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<p>参考<code>《STM32中文参考手册V10》-第8章通用和复用功能IO(GPIO和AFIO)</code><br>参考<code>\【正点原子】精英STM32F103开发板资料 资料盘(A盘)\7，硬件资料\7，硬件资料\2，芯片资料\STM32F103ZET6.pdf - Table 5.High-density STM32F103xx pin definitions (continued)</code></p><h1 id="端口复用"><a href="#端口复用" class="headerlink" title="端口复用"></a>端口复用</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>例如串口<code>1</code>的发送接收引脚是<code>PA9,PA10</code>,当我们把<code>PA9,PA10</code>不用作<code>GPIO</code>，而用做<strong>复用功能串口</strong><code>1</code>的<strong>发送接收引脚</strong>的时候,叫<strong>端口复用</strong><br><img src="/images/portAlterFunction.png" alt="串口复用"></p><blockquote><p><code>Default</code>列是说明了这些端口可以被复用的功能</p></blockquote><h2 id="端口复用配置流程"><a href="#端口复用配置流程" class="headerlink" title="端口复用配置流程"></a>端口复用配置流程</h2><ul><li><code>GPIO</code>端口<strong>时钟使能</strong></li><li><strong>复用外设时钟使能</strong></li><li><strong>端口模式配置</strong>(<code>《STM32中文参考手册V10》P110的表格&quot;8.1.11外设的GPIO配置&quot;</code>)</li></ul><h1 id="重映射"><a href="#重映射" class="headerlink" title="重映射"></a>重映射</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>一个<strong>外设的引脚除了具有默认的端口</strong>外,还可以<strong>通过设置重映射寄存器</strong>的方式，把这个外设的引脚<strong>映射到其它的端口</strong><br><img src="/images/remap.png" alt="重映射"></p><ul><li><strong>部分重映射</strong> &amp; <strong>完全重映射</strong><ul><li><strong>部分重映射</strong>：功能外设的<strong>部分引脚重新映射</strong>,还有一部分引脚是原来的默认引脚。</li><li><strong>完全重映射</strong>：功能外设的<strong>所有引脚都重新映射</strong>。</li></ul></li></ul><h2 id="重映射配置流程"><a href="#重映射配置流程" class="headerlink" title="重映射配置流程"></a>重映射配置流程</h2><ul><li><strong>使能</strong><code>GPIO</code>时钟(重映射后的<code>IO</code>);</li><li><strong>使能功能外设时钟</strong>(例如串口<code>1</code>);</li><li><strong>使能</strong><code>AFIO</code>时钟。重映射必须使能<code>AFIO</code>时钟</li><li><strong>开启重映射</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32-F103ZET6-06-Systick</title>
      <link href="/2022/03/06/Embedded-System-00/STM32-F103ZET6-06-Systick/"/>
      <url>/2022/03/06/Embedded-System-00/STM32-F103ZET6-06-Systick/</url>
      
        <content type="html"><![CDATA[<p><code>Systic</code>定时器是一个简单的定时器,对于<code>CM3、CM4</code>内核芯片都由<code>Systick</code>定时器。</p><h1 id="Systick定时器介绍"><a href="#Systick定时器介绍" class="headerlink" title="Systick定时器介绍"></a>Systick定时器介绍</h1><h2 id="Systick定时器作用"><a href="#Systick定时器作用" class="headerlink" title="Systick定时器作用"></a>Systick定时器作用</h2><p><code>Systic</code><strong>定时器通常被用来做延时</strong>,或则<strong>实时系统的心跳时钟</strong>。这样可以<strong>节省</strong><code>MCU</code>资源,<strong>不用浪费一个定时器</strong>。比如<code>UCOS</code>中,<strong>分时复用需要一个最小的时间戳</strong>;一般在<code>STM32+UCOS</code>系统中,都采用<code>Systick</code>做<code>UCOS</code><strong>心跳时钟</strong>。</p><h2 id="Systick定时器工作机制"><a href="#Systick定时器工作机制" class="headerlink" title="Systick定时器工作机制"></a>Systick定时器工作机制</h2><ul><li><p><code>Systick</code><strong>定时器就是系统滴答定时器</strong>,一个<code>24</code>位的<strong>倒计数定时器</strong>,计到<code>0</code>,将从<code>RELOAD</code><strong>寄存器</strong>中自动<strong>重装载定时初值</strong>。只要不把它在<code>SysTick</code><strong>控制及状态寄存器中的使能位清除</strong>,就<strong>永不停息</strong>,<strong>即使在睡眠模式下也能工作</strong></p></li><li><p><code>Systick</code><strong>定时器</strong>被捆绑在<code>NVIC</code>中，用于产生<code>SYSTICK</code><strong>异常</strong>（<strong>异常号</strong>:<code>15</code>)</p></li><li><p><code>Systick</code><strong>中断的优先级也可以设置</strong></p></li></ul><blockquote><p><code>参考 STM32中文参考手册_V10.pdf-7.2</code></p></blockquote><h2 id="Systick寄存器"><a href="#Systick寄存器" class="headerlink" title="Systick寄存器"></a>Systick寄存器</h2><p><code>参考 Cortex-M3权威指南(中文).pdf - 第8章-NVIC与中断控制 - SysTick定时器</code></p><p><code>Systick</code>寄存器通过结构体<code>SysTick_Type</code>类型来管理,定义如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __IOM <span class="keyword">uint32_t</span> CTRL;                   <span class="comment">/*!&lt; Offset: 0x000 (R/W)  SysTick Control and Status Register */</span></span><br><span class="line">  __IOM <span class="keyword">uint32_t</span> LOAD;                   <span class="comment">/*!&lt; Offset: 0x004 (R/W)  SysTick Reload Value Register */</span></span><br><span class="line">  __IOM <span class="keyword">uint32_t</span> VAL;                    <span class="comment">/*!&lt; Offset: 0x008 (R/W)  SysTick Current Value Register */</span></span><br><span class="line">  __IM  <span class="keyword">uint32_t</span> CALIB;                  <span class="comment">/*!&lt; Offset: 0x00C (R/ )  SysTick Calibration Register */</span></span><br><span class="line">&#125; SysTick_Type;</span><br></pre></td></tr></table></figure></p><p><code>Systick</code>寄存器包含<code>4</code>个<code>32</code>位<strong>寄存器</strong>,分别是:</p><ul><li><p><code>SysTick</code>控制及状态寄存器(<code>CTRL</code>)<br><img src="/images/SystickConfig.png" alt="控制及状态寄存器"></p><blockquote><p><strong>外部时钟源</strong>即<code>HCLK</code>的<code>1/8</code>; <strong>内核时钟</strong>即<code>HCLK</code>时钟</p></blockquote></li><li><p><code>SysTick</code>重装载数值寄存器(<code>LOAD</code>):当倒数至零时，将被重装载的值<br><img src="/images/SystickReloadValue.png" alt="重装载数值寄存器"></p></li><li><p><code>SysTick</code>当前数值寄存器(<code>VAL</code>)<br><img src="/images/SystickCurrentValue.png" alt="当前数值寄存器"></p></li><li><p><code>SysTick</code>校准数值寄存器(<code>CALIB</code>)<br><img src="/images/SystickCalib.png" alt="校准数值寄存器"></p><blockquote><p>该寄存器用的较少</p></blockquote></li></ul><h1 id="Systick定时器的运用"><a href="#Systick定时器的运用" class="headerlink" title="Systick定时器的运用"></a>Systick定时器的运用</h1><h2 id="延时"><a href="#延时" class="headerlink" title="延时"></a>延时</h2><p>使用<code>Systick</code><strong>定时器延时</strong>的方法有两种,包括<strong>查询</strong><code>CTRL</code>的<code>COUNTFLAG</code><strong>标志位</strong>和<strong>中断</strong>的方式</p><h3 id="使用查询标志位"><a href="#使用查询标志位" class="headerlink" title="使用查询标志位"></a>使用查询标志位</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSCLK_FREQ_72MHz  72000000</span></span><br><span class="line"><span class="keyword">uint32_t</span> SystemCoreClock         = SYSCLK_FREQ_72MHz;</span><br><span class="line"><span class="keyword">static</span> u8  fac_us=<span class="number">0</span>;   </span><br><span class="line"><span class="keyword">static</span> u16 fac_ms=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SysTick_CLKSourceConfig</span><span class="params">(<span class="keyword">uint32_t</span> SysTick_CLKSource)</span></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));</span><br><span class="line">  <span class="keyword">if</span> (SysTick_CLKSource == SysTick_CLKSource_HCLK)&#123;</span><br><span class="line">    SysTick-&gt;CTRL |= SysTick_CLKSource_HCLK;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    SysTick-&gt;CTRL &amp;= SysTick_CLKSource_HCLK_Div8;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay_init</span><span class="params">()</span></span>&#123;</span><br><span class="line">SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK_Div8);<span class="comment">//选择外部时钟  HCLK/8</span></span><br><span class="line">fac_us=SystemCoreClock/<span class="number">8000000</span>;<span class="comment">//为系统时钟的1/8  </span></span><br><span class="line">fac_ms=(u16)fac_us*<span class="number">1000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delay_us</span><span class="params">(u32 nus)</span></span>&#123;</span><br><span class="line">u32 temp;     </span><br><span class="line">SysTick-&gt;LOAD=nus*fac_us; <span class="comment">//时间加载   </span></span><br><span class="line">SysTick-&gt;VAL=<span class="number">0x00</span>;        <span class="comment">//清空计数器</span></span><br><span class="line">SysTick-&gt;CTRL|=SysTick_CTRL_ENABLE_Msk ;<span class="comment">//开始倒数  </span></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">temp=SysTick-&gt;CTRL;</span><br><span class="line">&#125;<span class="keyword">while</span>((temp&amp;<span class="number">0x01</span>)&amp;&amp;!(temp&amp;(<span class="number">1</span>&lt;&lt;<span class="number">16</span>)));<span class="comment">//等待时间到达   </span></span><br><span class="line">SysTick-&gt;CTRL&amp;=~SysTick_CTRL_ENABLE_Msk;<span class="comment">//关闭计数器</span></span><br><span class="line">SysTick-&gt;VAL =<span class="number">0X00</span>;       <span class="comment">//清空计数器 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>HCLK</code>的<strong>八分频</strong>作为<code>Systick</code>的时钟源,则<code>Systick</code>的时钟频率为$\frac{72MHz}{8}$, </p><ul><li><code>1 s</code>内 $9\times10^6$个<code>tick</code></li><li><code>1 ms</code>内 $9\times10^3$个<code>tick</code></li><li><code>1 us</code>内 $9$个<code>tick</code></li></ul><h3 id="使用中断处理函数"><a href="#使用中断处理函数" class="headerlink" title="使用中断处理函数"></a>使用中断处理函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  HAL_TICK_FREQ_10HZ         = <span class="number">100U</span>,</span><br><span class="line">  HAL_TICK_FREQ_100HZ        = <span class="number">10U</span>,</span><br><span class="line">  HAL_TICK_FREQ_1KHZ         = <span class="number">1U</span>,</span><br><span class="line">  HAL_TICK_FREQ_DEFAULT      = HAL_TICK_FREQ_1KHZ</span><br><span class="line">&#125; HAL_TickFreqTypeDef;</span><br><span class="line"></span><br><span class="line">__IO <span class="keyword">uint32_t</span> uwTick;</span><br><span class="line"></span><br><span class="line">HAL_TickFreqTypeDef uwTickFreq = HAL_TICK_FREQ_DEFAULT;  <span class="comment">/* 1KHz */</span></span><br><span class="line"></span><br><span class="line"><span class="function">__weak <span class="keyword">void</span> <span class="title">HAL_IncTick</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uwTick += uwTickFreq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SysTick_Handler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  HAL_IncTick();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">__weak <span class="keyword">uint32_t</span> <span class="title">HAL_GetTick</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> uwTick;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">__weak <span class="keyword">void</span> <span class="title">HAL_Delay</span><span class="params">(<span class="keyword">uint32_t</span> Delay)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> tickstart = HAL_GetTick();</span><br><span class="line">  <span class="keyword">uint32_t</span> wait = Delay;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (wait &lt; HAL_MAX_DELAY)</span><br><span class="line">  &#123;</span><br><span class="line">    wait += (<span class="keyword">uint32_t</span>)(uwTickFreq);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> ((HAL_GetTick() - tickstart) &lt; wait)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对以上<code>HAL</code>层代码,做如下解释:</p><ul><li>在<code>STM32F1</code>复位后,直到系统时钟就绪完成这段时间内,使用的是<code>LSI</code>,且<code>Systick</code>的时钟频率为<code>160MHz</code>(这个默认频率具体是多少,<strong>暂未查看到资料说明</strong>);这使得<code>HAL</code>库中有如下调用关系:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Reset of all peripherals, Initializes the Flash interface and the Systick. */</span></span><br><span class="line">  HAL_Init();</span><br><span class="line"></span><br><span class="line">  SystemClock_Config();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>在<code>HAL_Init()</code>中初始化过一次<code>Systick</code>(但<strong>系统时钟尚未自定义初始化</strong>,没有调用<code>SystemClock_Config</code>),这使得在<code>SystemClock_Config</code>中可以调用延时函数;</li></ul><p>在<code>SystemClock_Config</code>函数完成初始化后,确定了<strong>系统时钟</strong>后重新初始化了<code>Systick</code>,如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SystemCoreClock = HAL_RCC_GetSysClockFreq() &gt;&gt; AHBPrescTable[(RCC-&gt;CFGR &amp; RCC_CFGR_HPRE) &gt;&gt; RCC_CFGR_HPRE_Pos];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Configure the source of time base considering new system clocks settings*/</span></span><br><span class="line">HAL_InitTick(uwTickPrio);</span><br></pre></td></tr></table></figure></p><ul><li><code>HAL_Delay</code>函数说明<ul><li>由于<code>wait += (uint32_t)(uwTickFreq);</code>的原因,多延时<code>1 ms</code>的问题:<a href="https://my.oschina.net/u/4402117/blog/4658204">有网友在使用示波器测试过</a>,使用<code>HAL_Delay(1)</code>翻转高低电平,<strong>效果如下图所示,结果PWM周期</strong>为<code>4s</code>:<br><img src="/images/HAL_Delay.png" alt="HAL_Delay(1)产生的PWM"></li><li><code>tickstart</code>跨过<code>max(uint32_t)</code>后的两个无符号数相减,结果参考<strong>无符号数相减测试-反码</strong></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无符号数相减测试-反码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> b = <span class="number">0XFFFFFFFE</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a:0X%08X\nb:0X%08X\n&quot;</span>, a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a - b = 0X%08X\n&quot;</span>, a - b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行</span></span><br><span class="line">a:<span class="number">0X00000001</span></span><br><span class="line">b:<span class="number">0XFFFFFFFE</span></span><br><span class="line">a - b = <span class="number">0X00000003</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32-F103ZET6-04-时钟系统</title>
      <link href="/2022/03/02/Embedded-System-00/STM32-F103ZET6-05-%E6%97%B6%E9%92%9F%E7%B3%BB%E7%BB%9F/"/>
      <url>/2022/03/02/Embedded-System-00/STM32-F103ZET6-05-%E6%97%B6%E9%92%9F%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<ul><li><strong>学习时钟系统,可知知道各外设的时钟源是如何得到的;</strong></li><li><strong>任何外设使用前,都必须首先使能对应的时钟源</strong></li></ul><p><img src="/images/时钟系统.png" alt="时钟系统"></p><p><strong>上图说明</strong>:</p><ul><li><strong>蓝色正方形</strong>:<strong>时钟源</strong></li><li><strong>梯形</strong>:<strong>时钟选择器</strong></li></ul><h1 id="5个时钟源"><a href="#5个时钟源" class="headerlink" title="5个时钟源"></a>5个时钟源</h1><p><strong>时钟源在物理层面产生时钟信号</strong><br>上图是<code>STM32F1</code>的<strong>时钟系统框图</strong>,包含<code>5</code>个<strong>重要的时钟系统(蓝色正方形)</strong>,<strong>从上往下分别是</strong>:</p><ul><li><strong>高速内部时钟</strong>(<code>HSI RC-High Speed Internal RC</code>):约为<code>8</code><strong>MHz</strong>(<code>RC</code>振荡器产生的时钟,不<strong>稳定</strong>)</li><li><strong>高速外部时钟</strong>(<code>HSE Osc-High Speed External</code>):接<strong>外部晶振</strong>(晶振频率范围为<code>4~16M</code>,正点原子外接了<code>8M</code>晶振)</li><li><strong>锁相环PLL</strong>(<code>phase locked loop</code>):对<strong>输入的时钟源进行倍频</strong>(倍频系数可以是$\times 2… \times 16$)</li><li><strong>低速外部时钟</strong>(<code>LSE Osc-Low Speed External</code>):正点原子外接了<code>32.768KHz</code>的<strong>外部时钟</strong></li><li><strong>内部低速时钟</strong>(<code>LSI RC -Low Speed Internal</code>):约为<code>40KHz</code></li></ul><h1 id="几个重要的时钟"><a href="#几个重要的时钟" class="headerlink" title="几个重要的时钟"></a>几个重要的时钟</h1><h2 id="系统时钟"><a href="#系统时钟" class="headerlink" title="系统时钟"></a>系统时钟</h2><p><strong>系统时钟</strong>是图中的<code>SYSCLK</code>,其<strong>上游</strong>是<strong>时钟来源</strong>,并为<strong>下游外设提供时钟源</strong>:</p><h3 id="系统时钟来源"><a href="#系统时钟来源" class="headerlink" title="系统时钟来源"></a>系统时钟来源</h3><ul><li>来源于<strong>锁相环</strong><ul><li>直接来源于<code>HSI RC</code></li><li>来源于<code>HSI RC</code>的二分频</li><li>接来源于<code>HSE Osc</code></li><li>来源于<code>HSE Osc</code>的二分频</li></ul></li><li>来源于<code>HSI RC</code></li><li>来源于<code>HSE RC</code></li></ul><blockquote><p>时钟监控系统<code>css</code>用来检测<code>HSE Osc</code>是否失效,如果失效自动切换到<code>HSI RC</code></p></blockquote><h3 id="预分频器"><a href="#预分频器" class="headerlink" title="预分频器"></a>预分频器</h3><p><code>AHB</code>预分频器的<strong>分频因子</strong>为$\times 1  \times 2  \times 4  \times 8  \times 16  \times 64  \times 128  \times 256  \times 512$</p><ul><li><strong>系统时钟</strong><code>SYSCLK</code>经过<code>AHB</code>分频后得到<code>HCLK</code><strong>高速总线时钟</strong></li><li><code>HCLK</code><strong>高速总线时钟</strong>经过<code>APB1</code>得到<code>PCLK1</code></li><li><code>HCLK</code><strong>高速总线时钟</strong>经过<code>APB2</code>得到<code>PCLK2</code></li></ul><h2 id="实时时钟RTCCLK"><a href="#实时时钟RTCCLK" class="headerlink" title="实时时钟RTCCLK"></a>实时时钟<code>RTCCLK</code></h2><ul><li>来源于<code>HSE Osc</code>的<code>128</code>分频</li><li>来源于<code>LSE Osc</code></li><li>来源于<code>LSI RC</code></li></ul><h2 id="独立看门狗IWDGCLK"><a href="#独立看门狗IWDGCLK" class="headerlink" title="独立看门狗IWDGCLK"></a>独立看门狗<code>IWDGCLK</code></h2><p>来源于<code>LSI RC</code></p><h2 id="输出内部时钟"><a href="#输出内部时钟" class="headerlink" title="输出内部时钟"></a>输出内部时钟</h2><p>可以在<code>PA8</code>引脚<strong>输出内部时钟</strong>,该<strong>引脚的时钟源</strong>可以是:</p><ul><li>系统时钟<code>SYSCLK</code></li><li><code>HSI RC</code></li><li><code>HSE Osc</code></li><li><code>PLLCK</code>的二分频</li></ul><h2 id="USBCLK"><a href="#USBCLK" class="headerlink" title="USBCLK"></a><code>USBCLK</code></h2><p>对<code>PLLCLK</code>进行<code>1</code>或则<code>1.5</code>倍分频得到<code>USBCLK</code>;当不超频时,<code>PLLCLK</code>为<code>72MHz</code>,取分频系数为<code>1.5</code>,则<code>USBCLK</code>为$72MHz/1.5=48MHz$</p><h1 id="配置时钟系统"><a href="#配置时钟系统" class="headerlink" title="配置时钟系统"></a>配置时钟系统</h1><p>在<code>Drivers\CMSIS\Device\ST\STM32F1xx\Include\stm32f103xe.h</code>中定义了<strong>不同的外设被分配的首地址</strong>,及<strong>外设对应的内存</strong>应该<strong>被解释成什么类型的结构体</strong>;<br><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FLASH_BASE            0x08000000UL <span class="comment">/*!&lt; FLASH base address in the alias region */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FLASH_BANK1_END       0x0807FFFFUL <span class="comment">/*!&lt; FLASH END address of bank1 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SRAM_BASE             0x20000000UL <span class="comment">/*!&lt; SRAM base address in the alias region */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PERIPH_BASE           0x40000000UL <span class="comment">/*!&lt; Peripheral base address in the alias region */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SRAM_BB_BASE          0x22000000UL <span class="comment">/*!&lt; SRAM base address in the bit-band region */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PERIPH_BB_BASE        0x42000000UL <span class="comment">/*!&lt; Peripheral base address in the bit-band region */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FSMC_BASE             0x60000000UL <span class="comment">/*!&lt; FSMC base address */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FSMC_R_BASE           0xA0000000UL <span class="comment">/*!&lt; FSMC registers base address */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*!&lt; Peripheral memory map */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> APB1PERIPH_BASE       PERIPH_BASE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> APB2PERIPH_BASE       (PERIPH_BASE + 0x00010000UL)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AHBPERIPH_BASE        (PERIPH_BASE + 0x00020000UL)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RCC_BASE              (AHBPERIPH_BASE + 0x00001000UL)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RCC                 ((RCC_TypeDef *)RCC_BASE)</span></span><br></pre></td></tr></table></figure></p><h2 id="时钟系统配置寄存器"><a href="#时钟系统配置寄存器" class="headerlink" title="时钟系统配置寄存器"></a>时钟系统配置寄存器</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __IO <span class="keyword">uint32_t</span> CR;</span><br><span class="line">  __IO <span class="keyword">uint32_t</span> CFGR;</span><br><span class="line">  __IO <span class="keyword">uint32_t</span> CIR;</span><br><span class="line">  __IO <span class="keyword">uint32_t</span> APB2RSTR;</span><br><span class="line">  __IO <span class="keyword">uint32_t</span> APB1RSTR;</span><br><span class="line">  __IO <span class="keyword">uint32_t</span> AHBENR;</span><br><span class="line">  __IO <span class="keyword">uint32_t</span> APB2ENR;</span><br><span class="line">  __IO <span class="keyword">uint32_t</span> APB1ENR;</span><br><span class="line">  __IO <span class="keyword">uint32_t</span> BDCR;</span><br><span class="line">  __IO <span class="keyword">uint32_t</span> CSR;</span><br><span class="line">&#125; RCC_TypeDef;</span><br></pre></td></tr></table></figure><p>参考<code>STM32中文参考手册_V10.pdf - 6.3</code><br><code>AHBENR</code>: <code>SDIO、FSMC、CRC、FLITF、SRAM、DMA2、DMA1</code><br><code>APB2ENR</code>: <code>ADC3、USART1、TIM8、SPI1、TIM1、ADC2、ADC1、GPIOA-E、AFIO</code><br><code>APB1ENR</code>: <code>DAC、电源、备份接口、CAN、USB、I2C2、I2C1、UART5、UART4、USART2、SPI3、SPI2、窗口看门狗、TIM7-2</code></p><h3 id="CIR寄存器"><a href="#CIR寄存器" class="headerlink" title="CIR寄存器"></a>CIR寄存器</h3><p><code>LSIRDYF-flag</code>:<strong>中断使能的前提条件</strong>下,<strong>时钟源就绪</strong>后<code>LSIRDYF</code>被<strong>硬件</strong>置<code>1</code><br><code>LSIRDYIE-enable</code>:<strong>就绪中断使能</strong><br><code>LSIRDYC-clear</code>:写<code>1</code>用来<strong>清除</strong><code>LSIRDYF</code></p><blockquote><p><strong>同理可以</strong>把<code>LSI</code>替换为<code>LSE、HSI、HSE、PLL</code></p></blockquote><p><code>CSSF</code>:当<code>HSE</code>出现<strong>故障</strong>时,由<strong>硬件</strong>置<code>1</code><br><code>CSSC</code>:写<code>1</code>时,清除<code>CSSF</code></p><p><code>STM32F10xxx闪存编程参考手册.pdf</code></p><h3 id="CR寄存器"><a href="#CR寄存器" class="headerlink" title="CR寄存器"></a>CR寄存器</h3><ul><li><strong>使能等同于运行</strong></li><li><strong>禁止等同于停止</strong></li><li><strong>旁路等同于不使用外部晶体,但是需要提供外部时钟</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32-F103ZET6-04-GPIO-KEY_BEEP</title>
      <link href="/2022/02/28/Embedded-System-00/STM32-F103ZET6-04-GPIO-KEY-BEEP/"/>
      <url>/2022/02/28/Embedded-System-00/STM32-F103ZET6-04-GPIO-KEY-BEEP/</url>
      
        <content type="html"><![CDATA[<h1 id="端口编号记录"><a href="#端口编号记录" class="headerlink" title="端口编号记录"></a>端口编号记录</h1><p>为了<strong>避免重复</strong>查询<code>STM32F103ZET6</code>精英板的原理图,在此记录常用<strong>端口编号、功能、配置</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">功能</th><th style="text-align:center">端口</th><th style="text-align:center">配置</th><th style="text-align:center">初始状态</th></tr></thead><tbody><tr><td style="text-align:center"><code>LED0</code></td><td style="text-align:center"><code>PB5</code></td><td style="text-align:center"><strong>推挽输出</strong>-<strong>高电平</strong></td><td style="text-align:center"><strong>熄灭</strong></td></tr><tr><td style="text-align:center"><code>LED1</code></td><td style="text-align:center"><code>PE5</code></td><td style="text-align:center"><strong>推挽输出</strong>-<strong>高电平</strong></td><td style="text-align:center"><strong>熄灭</strong></td></tr><tr><td style="text-align:center"><code>BEEP</code></td><td style="text-align:center"><code>PB8</code></td><td style="text-align:center"><strong>推挽输出</strong>-<strong>低电平</strong></td><td style="text-align:center"><strong>静音</strong></td></tr><tr><td style="text-align:center"><code>KEY_WK</code></td><td style="text-align:center"><code>PA0</code></td><td style="text-align:center"><strong>输入下拉</strong></td><td style="text-align:center"><code>NULL</code></td></tr><tr><td style="text-align:center"><code>KEY0</code></td><td style="text-align:center"><code>PE4</code></td><td style="text-align:center"><strong>输入上拉</strong></td><td style="text-align:center"><code>NULL</code></td></tr><tr><td style="text-align:center"><code>KEY1</code></td><td style="text-align:center"><code>PE3</code></td><td style="text-align:center"><strong>输入上拉</strong></td><td style="text-align:center"><code>NULL</code></td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32-F103ZET6-03-GPIO-Bit_Band</title>
      <link href="/2022/02/27/Embedded-System-00/STM32-F103ZET6-03-GPIO-Bit-Band/"/>
      <url>/2022/02/27/Embedded-System-00/STM32-F103ZET6-03-GPIO-Bit-Band/</url>
      
        <content type="html"><![CDATA[<p><strong>参考</strong><a href="https://zhuanlan.zhihu.com/p/142586194">STM32位带操作全解</a></p><p>为什么设计出<strong>位带别名区</strong>(<code>bit-band alias</code>)？</p><ul><li>一个是因为访问速度快(<strong>位带别名区</strong>是按照<code>32</code>数据对齐的,将<strong>位带区域</strong>映射到1字节或者2字节的地址空间不行吗？只能说，<code>STM32</code>是一个<code>32</code>位的机器，<strong>内核按字寻址的话寻址速度是最快的</strong>)</li><li>另一个是因为安全(如果在<strong>裸机开发</strong>中，<strong>位带操作</strong>相比于<strong>直接的读-改-写操作</strong>除了访问速度快一点以外好像也没有什么可以说的了，但是如果在带<strong>操作系统</strong>的开发中，多任务<strong>并发运行的时候</strong>就有可能在任务切换的过程中发生不可预料的问题，而<strong>位带操作由于是属于硬件完成的不可被异常打断的操作(原子操作)</strong>，所以相对于读-写-改的操作模式的话会更安全些)</li></ul><h1 id="位带区-位带别名区"><a href="#位带区-位带别名区" class="headerlink" title="位带区/位带别名区"></a>位带区/位带别名区</h1><p><code>Cortex-M3</code>的内存区域如图<code>位带区和位带别名区</code>所示,<br>图<code>位带区和位带别名区</code>中标识了两块<strong>位带区</strong>:</p><ul><li><code>SRAM</code>的<code>0X2000 0000 ~ 0X200F FFFF</code>,共<code>0X200F FFFF - 0X2000 0000 + 1 = 0X10 0000 byte= 1 M</code></li><li>外设区<code>Peripherals</code>的<code>0X4000 0000 ~ 0X400F FFFF</code>,共<code>0X400F FFFF - 0X4000 0000 + 1 = 0X10 0000 byte= 1 M</code></li></ul><p>在<code>SRAM</code>和<strong>外设地址段</strong>内的这<code>1M</code>大小的空间就是<strong>位带区</strong>，说白了就是<strong>支持位带操作的区域就是位带区</strong></p><p>图<code>位带区和位带别名区</code>中标识了两块<strong>位带别名区</strong>:</p><ul><li><code>SRAM</code>的<strong>位带别名区</strong>里的<code>0X2200 0000 ~ 0X23FF FFFF</code>地址段,共<code>0X23FF FFFF - 0X2200 0000 + 1= 0X200 0000 byte = 32 M</code></li><li><strong>外设区</strong><code>Peripherals</code>里<code>0X4200 0000 ~ 0X43FF FFFF</code>地址段,共<code>0X43FF FFFF - 0X4200 0000 + 1 = 0X200 0000 byte = 32 M</code><br><img src="/images/位带区.png" alt="位带区和位带别名区"></li></ul><p><br></p><h1 id="位带区与别名区的映射"><a href="#位带区与别名区的映射" class="headerlink" title="位带区与别名区的映射"></a>位带区与别名区的映射</h1><p><strong>位带区</strong>都是<code>1M</code>大小,而<strong>位带别名区</strong>都是<code>32M</code>,可以推测<strong>位带区</strong>的<code>1 bit</code><strong>映射</strong>到<strong>位带别名区</strong>的<code>32 bit</code><br><img src="/images/memory_map_of_bitbanding.png" alt="位带区映射关系"></p><p><strong>位带别名区</strong>的<strong>每个地址对齐的字</strong>都是<strong>最低位有效的</strong>，也就是说在映射关系里，我们可以得到下面的<strong>结论</strong>:</p><p><strong>在位带别名区里,只要最低位是<code>1</code>,那么对应的位带区的位就是<code>1</code></strong><br><code>0X4000 0000</code>地址位<code>3</code>置<code>1</code>操作:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*(<span class="keyword">uint32_t</span>*)(<span class="number">0x40000000</span>) |= (<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">*(<span class="keyword">uint32_t</span>*)(<span class="number">0x40000010</span>) = <span class="number">0x01</span>;<span class="comment">//只要最低位是1即可</span></span><br><span class="line"><span class="comment">//也等价于</span></span><br><span class="line">*(<span class="keyword">uint32_t</span>*)(<span class="number">0x40000010</span>) = <span class="number">0x03</span>;</span><br><span class="line"><span class="comment">//也等价于</span></span><br><span class="line">*(<span class="keyword">uint32_t</span>*)(<span class="number">0x40000010</span>) = <span class="number">0x05</span>;</span><br></pre></td></tr></table></figure></p><p><code>0X4000 0000</code>地址位<code>3</code>置<code>0</code>操作:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*(<span class="keyword">uint32_t</span>*)(<span class="number">0x40000000</span>)  &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line"> <span class="comment">//等价于</span></span><br><span class="line">*(<span class="keyword">uint32_t</span>*)(<span class="number">0x40000010</span>) = <span class="number">0x00</span>;<span class="comment">//只要最低位是0即可</span></span><br><span class="line"><span class="comment">//也等价于</span></span><br><span class="line">*(<span class="keyword">uint32_t</span>*)(<span class="number">0x40000010</span>) = <span class="number">0x02</span>;</span><br><span class="line"><span class="comment">//也等价于</span></span><br><span class="line">*(<span class="keyword">uint32_t</span>*)(<span class="number">0x40000010</span>) = <span class="number">0x04</span>;</span><br></pre></td></tr></table></figure></p><ul><li>对于<code>SRAM</code><strong>位带区的地址</strong>为<code>addr</code>的位 $n(0\le n &lt; 8)$ 在<strong>位带别名区的地址</strong>为<code>AliasAddr</code><br><code>AliasAddr = 0X2200 0000 + (addr - 0X2000 0000)*8*4 + n*4</code></li><li>对于片上外设<code>Peripherals</code><strong>位带区的地址</strong>为<code>addr</code>的位 $n(0\le n &lt; 8)$ 在<strong>位带别名区的地址</strong>为<code>AliasAddr</code><br><code>AliasAddr = 0X4200 0000 + (addr - 0X4000 0000)*8*4 + n*4</code></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="地址空间映射图"><a href="#地址空间映射图" class="headerlink" title="地址空间映射图"></a>地址空间映射图</h2><p><img src="/images/STM32F10X系列地址空间映射图.png" alt="STM32F10X系列地址空间映射图"></p><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><p>根据<code>STM32F10X系列地址空间映射图</code>可容易理解<code>A</code>组<code>GPIO</code>基地址<code>GPIOA_BASE</code>的计算<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stm32f103xe.h hal库的头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PERIPH_BASE           0x40000000UL <span class="comment">/*!&lt; Peripheral base address in the alias region */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> APB2PERIPH_BASE       (PERIPH_BASE + 0x00010000UL)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIOA_BASE            (APB2PERIPH_BASE + 0x00000800UL)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIOA               ((GPIO_TypeDef *)GPIOA_BASE)</span></span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HAL_GPIO_Init</span><span class="params">(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> struct</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __IO <span class="keyword">uint32_t</span> CRL;</span><br><span class="line">  __IO <span class="keyword">uint32_t</span> CRH;</span><br><span class="line">  __IO <span class="keyword">uint32_t</span> IDR; <span class="comment">// 地址偏移 8 </span></span><br><span class="line">  __IO <span class="keyword">uint32_t</span> ODR; <span class="comment">// 地址偏移 12</span></span><br><span class="line">  __IO <span class="keyword">uint32_t</span> BSRR;</span><br><span class="line">  __IO <span class="keyword">uint32_t</span> BRR;</span><br><span class="line">  __IO <span class="keyword">uint32_t</span> LCKR;</span><br><span class="line">&#125; GPIO_TypeDef;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//映射地址公式</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BITBAND(addr, bitnum) ((addr &amp; 0xF0000000) + 0x2000000 + ((addr &amp; 0xFFFFF) &lt;&lt; 5) + (bitnum &lt;&lt; 2))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEM_ADDR(addr) *((volatile unsigned long *)(addr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT_ADDR(addr, bitnum) MEM_ADDR(BITBAND(addr, bitnum))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IO口输出寄存器地址映射</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIOA_ODR_Addr (GPIOA_BASE + 12) <span class="comment">// 0x4001080C</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IO口输入寄存器地址映射</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIOA_IDR_Addr (GPIOA_BASE + 8) <span class="comment">// 0x40010808</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// IO口操作,只对单一的IO口!</span></span><br><span class="line"><span class="comment">//确保n的值为0~15</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAout(n) BIT_ADDR(GPIOA_ODR_Addr, n) <span class="comment">//输出</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAin(n) BIT_ADDR(GPIOA_IDR_Addr, n)  <span class="comment">//输入</span></span></span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>其中<strong>位带操作的核心</strong>在于<code>(addr &amp; 0xF000 0000) + 0x200 0000 + ((addr &amp; 0xF FFFF) &lt;&lt; 5) + (bitnum &lt;&lt; 2)</code></p><p><code>SRAM</code>区域的位带区的地址范围<code>0X2000 0000 ~ 0X200F FFFF</code><br><code>AliasAddr = 0X2200 0000 + (addr - 0X2000 0000)*8*4 + n*4</code><br><code>......... = 0X2000 0000 + 0X0200 0000 + (addr - 0X2000 0000)*8*4 + n*4</code><br><code>......... = (addr &amp; 0xF000 0000) + 0X0200 0000 + (addr - 0X2000 0000)*8*4 + n*4</code><br><code>......... = (addr &amp; 0xF000 0000) + 0X0200 0000 + (addr &amp; 0XF FFFF)*8*4 + n*4</code> — <strong>式1</strong></p><p><strong>片上外设区</strong><code>Peripherals</code>的位带区地址范围为<code>0X4000 0000 ~ 0X400F FFFF</code><br><code>AliasAddr = 0X4200 0000 + (addr - 0X4000 0000)*8*4 + n*4</code><br><code>......... = 0X4000 0000 + 0X0200 0000 + (addr - 0X4000 0000)*8*4 + n*4</code><br><code>......... = (addr &amp; 0xF000 0000) + 0X0200 0000 + (addr &amp; 0XF FFFF)*8*4 + n*4</code> — <strong>式2</strong></p><ul><li>不论是在哪个位带区,都有<code>n*4</code>,即计算的<strong>第三部分</strong><code>(bitnum &lt;&lt; 2)</code></li><li>综合<strong>式1</strong>和<strong>式2</strong>可知,<strong>位带别名区地址计算公式</strong>为<code>(addr &amp; 0xF000 0000) + 0x200 0000 + ((addr &amp; 0xF FFFF) &lt;&lt; 5) + (bitnum &lt;&lt; 2)</code></li></ul><p><strong>位带操作的全部实现参考</strong><a href="/code/bit_band_operation.h">bit_band_operation.h</a></p><h1 id="STM32F103ZET6的两片内存"><a href="#STM32F103ZET6的两片内存" class="headerlink" title="STM32F103ZET6的两片内存"></a>STM32F103ZET6的两片内存</h1><p>参考<code>图STM32F10X 系列地址空间映射图</code>   </p><ul><li><code>FLASH</code>-<code>[0X0800 0000, 0X0808 0000)</code>,共<code>512K</code>,被用作存放<strong>代码</strong></li><li><code>SRAM</code> -<code>[0X2000 0000, 0X2001 0000)</code>,共<code>64K</code>,被用作存放<strong>数据</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32-F103ZET6-02-GPIO寄存器配置(HAL)</title>
      <link href="/2022/02/26/Embedded-System-00/STM32-F103ZET6-02-GPIO%E5%AF%84%E5%AD%98%E5%99%A8%E9%85%8D%E7%BD%AE(HAL)/"/>
      <url>/2022/02/26/Embedded-System-00/STM32-F103ZET6-02-GPIO%E5%AF%84%E5%AD%98%E5%99%A8%E9%85%8D%E7%BD%AE(HAL)/</url>
      
        <content type="html"><![CDATA[<h1 id="GPIO配置流程"><a href="#GPIO配置流程" class="headerlink" title="GPIO配置流程"></a>GPIO配置流程</h1><ul><li><strong>使能</strong><code>IO</code>口时钟(配置寄存器<code>RCC_APB2ENR</code>,参考<code>STM32中文参考手册_V10.pdf-6.3.6~6.3.8</code>)</li><li><strong>初始化</strong><code>IO</code>口模式(配置寄存器<code>GPIOx_CRH/CRL</code>,参考<code>STM32中文参考手册_V10.pdf-8.2 GPIO寄存器描述</code>)</li><li><strong>操作</strong><code>IO</code>口(配置寄存器<code>GPIOx_ODR/GPIOx_BSRR/GPIOx_BRR</code>,参考<code>STM32中文参考手册_V10.pdf-8.2 GPIO寄存器描述</code>)</li></ul><h1 id="HAL库API梳理"><a href="#HAL库API梳理" class="headerlink" title="HAL库API梳理"></a>HAL库API梳理</h1><p><code>STM32F103ZET6</code>的<code>LED0</code>和<code>LED1</code>通过<code>PB5</code>和<code>PE5</code>端口接入芯片(<code>USART1</code>的收发引脚通过<code>PA9</code>和<code>PA10</code>端口接入芯片)</p><h2 id="使能时钟"><a href="#使能时钟" class="headerlink" title="使能时钟"></a>使能时钟</h2><p>通过宏<code>__HAL_RCC_GPIOE_CLK_ENABLE();</code>来开启<code>E</code>组<strong>所有端口的时钟</strong>,<code>E</code>组<code>IO</code>口是<strong>挂载</strong>在<code>APB2</code>时钟上,对应寄存器<code>RCC_APB2ENR</code>;<br>参考<code>STM32中文参考手册_V10.pdf-6.3.7</code>查看<strong>端口挂载在哪个时钟上</strong></p><blockquote><p><code>IOPEEN</code>：<code>IO</code>端口<code>E</code>时钟<strong>使能</strong> (<code>I/O port E clock enable</code>) 由软件置<code>1</code>或清<code>0</code><br><code>0：IO</code>端口<code>E</code>时钟<strong>关闭</strong>；<br><code>1：IO</code>端口<code>E</code>时钟<strong>开启</strong>。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RCC_APB2ENR_IOPEEN_Pos               (6U)                              </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RCC_APB2ENR_IOPEEN_Msk               (0x1UL &lt;&lt; RCC_APB2ENR_IOPEEN_Pos)  <span class="comment">/*!&lt; 0x00000040 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RCC_APB2ENR_IOPEEN                   RCC_APB2ENR_IOPEEN_Msk            <span class="comment">/*!&lt; I/O port E clock enable */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __HAL_RCC_GPIOE_CLK_ENABLE()                     \</span></span><br><span class="line"><span class="meta">  do                                                     \</span></span><br><span class="line"><span class="meta">  &#123;                                                      \</span></span><br><span class="line"><span class="meta">    __IO uint32_t tmpreg;                                \</span></span><br><span class="line"><span class="meta">    SET_BIT(RCC-&gt;APB2ENR, RCC_APB2ENR_IOPEEN);           \</span></span><br><span class="line"><span class="meta">    <span class="comment">/* Delay after an RCC peripheral clock enabling */</span>   \</span></span><br><span class="line"><span class="meta">    tmpreg = READ_BIT(RCC-&gt;APB2ENR, RCC_APB2ENR_IOPEEN); \</span></span><br><span class="line"><span class="meta">    UNUSED(tmpreg);                                      \</span></span><br><span class="line"><span class="meta">  &#125; while (0U)</span></span><br></pre></td></tr></table></figure><h2 id="默认输出高电平"><a href="#默认输出高电平" class="headerlink" title="默认输出高电平"></a>默认输出高电平</h2><p>通过函数<code>HAL_GPIO_WritePin(GPIOE, GPIO_PIN_5, GPIO_PIN_SET);</code>来<strong>设置输出端口为高电平</strong></p><p><code>GPIO_PIN_0~GPIO_PIN_15、GPIO_PIN_ALL</code>共<code>17</code>个状态,定义了以下<code>17</code>个宏<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_PIN_0                 ((uint16_t)0x0001)  <span class="comment">/* Pin 0 selected    */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_PIN_1                 ((uint16_t)0x0002)  <span class="comment">/* Pin 1 selected    */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_PIN_2                 ((uint16_t)0x0004)  <span class="comment">/* Pin 2 selected    */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_PIN_3                 ((uint16_t)0x0008)  <span class="comment">/* Pin 3 selected    */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_PIN_4                 ((uint16_t)0x0010)  <span class="comment">/* Pin 4 selected    */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_PIN_5                 ((uint16_t)0x0020)  <span class="comment">/* Pin 5 selected    */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_PIN_6                 ((uint16_t)0x0040)  <span class="comment">/* Pin 6 selected    */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_PIN_7                 ((uint16_t)0x0080)  <span class="comment">/* Pin 7 selected    */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_PIN_8                 ((uint16_t)0x0100)  <span class="comment">/* Pin 8 selected    */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_PIN_9                 ((uint16_t)0x0200)  <span class="comment">/* Pin 9 selected    */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_PIN_10                ((uint16_t)0x0400)  <span class="comment">/* Pin 10 selected   */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_PIN_11                ((uint16_t)0x0800)  <span class="comment">/* Pin 11 selected   */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_PIN_12                ((uint16_t)0x1000)  <span class="comment">/* Pin 12 selected   */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_PIN_13                ((uint16_t)0x2000)  <span class="comment">/* Pin 13 selected   */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_PIN_14                ((uint16_t)0x4000)  <span class="comment">/* Pin 14 selected   */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_PIN_15                ((uint16_t)0x8000)  <span class="comment">/* Pin 15 selected   */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_PIN_All               ((uint16_t)0xFFFF)  <span class="comment">/* All pins selected */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_PIN_MASK              0x0000FFFFu <span class="comment">/* PIN mask for assert test */</span></span></span><br><span class="line"><span class="comment">// 通过判断低16位不为0,高16位为0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_GPIO_PIN(PIN)           (((((uint32_t)PIN) &amp; GPIO_PIN_MASK ) != 0x00u) &amp;&amp; ((((uint32_t)PIN) &amp; ~GPIO_PIN_MASK) == 0x00u))</span></span><br></pre></td></tr></table></figure></p><p><strong>端口电平为枚举值</strong>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  GPIO_PIN_RESET = <span class="number">0u</span>,</span><br><span class="line">  GPIO_PIN_SET</span><br><span class="line">&#125; GPIO_PinState;</span><br></pre></td></tr></table></figure></p><p><code>GPIOx_BSRR</code>寄存器的高<code>16</code>位作<strong>控制输出低电平</strong>,低<code>16</code>位用作<strong>控制输出高电平</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HAL_GPIO_WritePin</span><span class="params">(GPIO_TypeDef *GPIOx, <span class="keyword">uint16_t</span> GPIO_Pin, GPIO_PinState PinState)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_GPIO_PIN(GPIO_Pin));</span><br><span class="line">  assert_param(IS_GPIO_PIN_ACTION(PinState));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (PinState != GPIO_PIN_RESET)</span><br><span class="line">  &#123;<span class="comment">// 输出高电平 控制低16位 </span></span><br><span class="line">    GPIOx-&gt;BSRR = GPIO_Pin;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;<span class="comment">// 输出高电平 控制高16位</span></span><br><span class="line">    GPIOx-&gt;BSRR = (<span class="keyword">uint32_t</span>)GPIO_Pin &lt;&lt; <span class="number">16u</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="端口模式初始化"><a href="#端口模式初始化" class="headerlink" title="端口模式初始化"></a>端口模式初始化</h2><p>通过函数<code>HAL_GPIO_Init(GPIOE, &amp;GPIO_InitStruct);</code>来初始化指定端口,其中<code>GPIO_InitTypeDef</code>定义如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span> Pin;      <span class="comment">// 端口</span></span><br><span class="line">  <span class="keyword">uint32_t</span> Mode;     <span class="comment">// 输出模式</span></span><br><span class="line">  <span class="keyword">uint32_t</span> Pull;     <span class="comment">// 上拉,下拉,No</span></span><br><span class="line">  <span class="keyword">uint32_t</span> Speed;    <span class="comment">// 输出翻转速度</span></span><br><span class="line">&#125; GPIO_InitTypeDef;</span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GPIO_InitStruct.Pin = GPIO_PIN_5;</span><br><span class="line">GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;</span><br><span class="line">GPIO_InitStruct.Pull = GPIO_NOPULL;</span><br><span class="line">GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;</span><br><span class="line">HAL_GPIO_Init(GPIOE, &amp;GPIO_InitStruct);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>STM32-F103ZET6-01-GPIO的工作模式和寄存器描述</title>
      <link href="/2022/02/26/Embedded-System-00/STM32-F103ZET6-01-GPIO%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%AF%84%E5%AD%98%E5%99%A8%E6%8F%8F%E8%BF%B0/"/>
      <url>/2022/02/26/Embedded-System-00/STM32-F103ZET6-01-GPIO%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%AF%84%E5%AD%98%E5%99%A8%E6%8F%8F%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/STM32GPIO.png" alt="GPIO输入输出电路"></p><p><code>GPIO</code>端口电路包括<strong>输入驱动器</strong>和<strong>输出驱动器</strong>两部分</p><h1 id="GPIO参考资料"><a href="#GPIO参考资料" class="headerlink" title="GPIO参考资料"></a>GPIO参考资料</h1><ul><li><code>STM32F1开发指南(精英版)-HAL库版本_V1.0.pdf--第六章跑马灯实验</code></li><li><code>正点原子数据手册-STM32F103ZET6.pdf</code>-每个引脚做什么功能</li></ul><h1 id="GPIO模式"><a href="#GPIO模式" class="headerlink" title="GPIO模式"></a>GPIO模式</h1><h2 id="保护二极管"><a href="#保护二极管" class="headerlink" title="保护二极管"></a>保护二极管</h2><p>引脚的两个<strong>保护二级管</strong>可以防止引脚外部<strong>过高或过低的电压输入</strong>:</p><ul><li>当<strong>引脚电压高于</strong><code>VDD</code> 时，上方的二极管导通, 防止不正常电压引入芯片导致芯片烧毁</li><li>当<strong>引脚电压低于</strong><code>VSS</code>时，下方的二极管导通, 防止不正常电压引入芯片导致芯片烧毁。</li></ul><blockquote><p>1、尽管有这样的保护，并不意味着<code>STM32</code>的引脚能直接外接<strong>大功率驱动器件</strong>，如直接驱动电机，强制驱动要么电机不转，要么导致芯片烧坏，必须要加大功率及隔离电路驱动。<br>2、查看<code>数据手册-STM32F103ZET6.pdf</code>,带有<code>FT</code>标识的表示可以容忍<code>5V</code>,端口接入<code>5V</code>时,可以被识别为高电平</p></blockquote><p><br></p><h2 id="输出驱动器"><a href="#输出驱动器" class="headerlink" title="输出驱动器"></a>输出驱动器</h2><p><strong>输出驱动器</strong>中包含两个<code>MOS</code>管,所以先弄清楚<code>MOS</code>的工作原理</p><h3 id="MOS管"><a href="#MOS管" class="headerlink" title="MOS管"></a>MOS管</h3><p><strong>MOS管</strong>全称为<strong>金属半场效应晶体管</strong>(<code>Metal-Oxide-Semiconductor Field-Effect Transistor, MOSFET</code>)</p><ul><li><code>NMOS</code>管<ul><li>1、<code>NMOS</code>的参数:封装,<code>Vgsth</code>,<code>Rdson</code>,<code>Cgs</code>;</li><li>2、<code>NMOS</code>的<strong>等效模型</strong>为由<strong>电压控制的电阻</strong>,电压指$U_{gs}$ ,  电阻指$R_{DS}$ ,  $R_{DS}$随着$U_{gs}$变化而变化</li><li>3、<code>Vgsth</code>是<code>DS</code>被导通后所需要$U_{gs}$</li><li>4、<code>Rdson</code>是<code>DS</code>被完全导通后所需要$R_{ds}$(越小越好,越小则耗散在<code>MOS</code>管上的功率也越小,发热也越小,但是价格越高,体积越大)</li><li>5、<code>Cgs</code>是<code>gs</code>之间的<strong>等效电容</strong>,电容越大,$U_{gs}$到<code>Vgsth</code>的时间越长, 如<code>被 Cgs 耽误的 PWM</code>所示(一般<code>Rdson</code>越大,<code>Cgs</code>越小)</li><li>6、<code>MOS</code>管的作用:<code>MOS</code>管的栅极<code>Gate</code>极接入<strong>导通电压</strong>是,漏极<code>Drain</code>和源极<code>Source</code>是导通的(控制端口的高低电平); 当<code>MOS</code>管的栅极<code>Gate</code>极以一定的<strong>频率</strong>接入导通电压断开导通电压时,则$U_{DS}$间就形成的<code>PWM</code>(<code>PWM</code>)</li></ul></li></ul><p><img src="/images/pmos.png" alt="NMOS"></p><p><img src="/images/被Cgs耽误的PWM.png" alt="被Cgs耽误的PWM"></p><ul><li><code>PMOS</code>管<ul><li>1、<code>NMOS</code>在<strong>栅极</strong><code>Gate</code>处于高电平时导通;而<code>PMOS</code>在<strong>栅极</strong><code>Gate</code>处于低电平时导通</li><li>2、如果<code>NMOS</code>处于灯泡上面,则当<code>DS</code>导通时,$V_s=5V$,需要<code>NMOS</code>导通,则<code>$V_g$</code>要达到<code>10V</code>,这不合理</li><li>3、如果<strong>控制的是芯片</strong>,却使用的是<code>NMOS</code>管,当<code>NMOS</code>导通时,芯片<strong>没有直接接地</strong>(芯片无法与其它元器件共地,会造成<strong>通讯混乱</strong>);而但<code>NMOS</code>管断开时,芯片与<code>5V</code>相连(电流可能从其它<code>io</code>口流出);所以<strong>控制芯片这类有缘器件</strong>的话,使用<code>PMOS</code>作为<strong>上管</strong>,接通时可以良好共地,断开时与电源隔离;而<strong>控制灯泡、电机这类无源器件</strong>时,使用<code>NMOS</code>作为<strong>下管</strong></li><li>4、由于$Rdson_{P}&gt;Rdson_{N}$、$Price_{P}&gt;Price_{N}$、$variety_{PMOS}&gt;variety_{NMOS}$,  所以<strong>尽量</strong>选用<code>NMOS</code></li><li>5、<strong>注意</strong><code>PMOS</code>和<code>NMOS</code>接线端子<code>DS</code>与<strong>电源/地的关系</strong></li></ul></li></ul><p><img src="/images/PMOS和NMOS.png" alt="PMOS和NMOS的区别"></p><ul><li><code>MOS</code>管和三极管<br>三极管的运用场景很少了,原因主要包括两个:集成电路的发展和<code>MOS</code>管的普及<br><img src="/images/三极管.png" alt="三极管"></li></ul><p>三极管是<strong>电流控制元件</strong>(有持续的电流时,<code>CE</code>才会导通(电流放大),<code>BE</code>之间会有<strong>功率消耗</strong>),而<code>MOS</code>管是<strong>电压控制元件</strong>(给<code>GS</code>之间的<strong>等效电容充满电</strong>后,尽管断开栅极<code>Gate</code>的供电仍可使<code>DS</code>之间导通,这是<code>MOS</code>管的<strong> </strong>);此外,<code>MOS</code>的<strong>导通阻抗小</strong>,所以<strong>导通后功率消耗小</strong></p><p>三极管的<strong>优势</strong>是便宜;而且由于<code>MOS</code>工艺原因,要想<strong>耐高压</strong>,<code>Rdson</code>会<strong>比较大</strong>,三极管<strong>很容易做到耐高压</strong>;</p><h3 id="GPIO的推挽输出"><a href="#GPIO的推挽输出" class="headerlink" title="GPIO的推挽输出"></a><code>GPIO</code>的推挽输出</h3><ul><li><p><strong>推挽输出</strong><code>Push–pull output</code>的概念<br><strong>推挽输出</strong>:输出既可以向负载<strong>灌电流</strong>，也可以从负载<strong>抽取电流</strong></p></li><li><p><strong>推挽输出电路</strong></p><ul><li>输入<strong>高电平</strong>时,经过<strong>反向后</strong>,上方的<code>P-MOS</code>管导通，下方的<code>N-MOS</code>关闭，对外<strong>输出高电平</strong>;</li><li>输入<strong>低电平</strong>时,经过<strong>反向后</strong>,下方的<code>N-MOS</code>管导通，上方的<code>P-MOS</code>关闭，对外<strong>输出低电平</strong>。<br><img src="/images/Push–pull-output.png" alt="推挽输出电路"><blockquote><p>三角形+圆圈表示非门输出</p></blockquote></li></ul></li></ul><p><code>STM32</code>的推挽<strong>输出流程</strong>:写入-位设置/清除寄存器-3输出数据寄存器-输出控制-<code>PMOS/NMOS</code>管-1保护-端口</p><h3 id="GPIO的推挽复用输出"><a href="#GPIO的推挽复用输出" class="headerlink" title="GPIO的推挽复用输出"></a><code>GPIO</code>的推挽复用输出</h3><p><strong>推挽复用输出</strong>与<strong>推挽输出</strong>很相似,只是<strong>控制来源</strong>不同(<strong>片上外设</strong>)<br><code>STM32</code>的推挽复用<strong>输出流程</strong>:边上外设-4复用功能输出-输出控制-<code>PMOS/NMOS</code>管-1保护-端口</p><h3 id="GPIO的开漏输出"><a href="#GPIO的开漏输出" class="headerlink" title="GPIO的开漏输出"></a><code>GPIO</code>的开漏输出</h3><p><strong>开漏输出模式</strong>时，上方的<code>P-MOS</code>管完全不工作</p><ul><li>若控制输出<strong>低电平</strong>,则<code>P-MOS</code>管<strong>关闭</strong>,<code>N-MOS</code>管导通，使<strong>输出接地</strong></li><li>若控制输出<strong>高电平</strong>,则·<code>P-MOS</code>管和<code>N-MOS</code>管<strong>都关闭</strong>,所以<strong>引脚既不输出高电平</strong>,<strong>也不输出低电平</strong>,为<strong>高阻态</strong><blockquote><p><strong>高阻态</strong>是一个<strong>数字电路</strong>里常见的术语,指的是电路的一种<strong>输出状态</strong>,既不是<strong>高电平</strong>也不是<strong>低电平</strong>,如果<strong>高阻态再输入下一级电路的话</strong>,对下级电路<strong>无任何影响</strong>,和没接一样,如果用万用表测的话有<strong>可能是高电平也有可能是低电平</strong> ,随它<strong>后面接的东西定</strong>的</p></blockquote></li></ul><p>为正常使用时必须<strong>外部接上拉电阻</strong>。它具有<strong>线与</strong>特性,也就是说,若有很<strong>多个开漏模式引脚连接到一起</strong>时,只有当所有<strong>引脚都输出高阻态</strong>,才由<strong>上拉电阻提供高电平</strong>,此<strong>高电平的电压</strong>为<strong>外部上拉电阻所接的电源的电压</strong>。若其中一个引脚为<strong>低电平</strong>,那<strong>线路就相当于短路接地</strong>,使得整条线路都为<strong>低电平</strong><br><img src="/images/开漏输出.png" alt="开漏输出"></p><p>在<code>STM32</code>的开漏输出模式中,通过如下<strong>流程</strong>:<br>写入-位设置/清除寄存器-3输出数据寄存器-输出控制-<code>NMOS</code>管-1保护-端口<br>此时可以通过输入电路读取当前端口的电平;</p><h3 id="GPIO的开漏复用输出模式"><a href="#GPIO的开漏复用输出模式" class="headerlink" title="GPIO的开漏复用输出模式"></a><code>GPIO</code>的开漏复用输出模式</h3><p><strong>开漏复用输出模式</strong>与<strong>开漏输出模式</strong>很相似,只是控制端不同(<strong>片上外设</strong>)<br><strong>开漏复用输出流程</strong>:边上外设-4复用功能输出-输出控制-<code>NMOS</code>管-1保护-端口</p><h2 id="输入驱动器"><a href="#输入驱动器" class="headerlink" title="输入驱动器"></a>输入驱动器</h2><p>输入驱动器中包含了<strong>TTL肖基特触发器</strong>,下面介绍<strong>TTL肖基特触发器</strong></p><h3 id="TTL肖特基触发器"><a href="#TTL肖特基触发器" class="headerlink" title="TTL肖特基触发器"></a>TTL肖特基触发器</h3><p><strong>TTL肖特基触发器</strong>其实可以理解为用<strong>肖特基管</strong>构成的<strong>施密特触发器</strong><br><strong>施密特触发器</strong>用作将<strong>变化的波形</strong>转化为<strong>方波</strong>,用作<strong>输入采集</strong>,获得高质量的离散的高低电平;包括以下特点:</p><ul><li><strong>输入信号</strong>在<strong>上升和下降</strong>过程中,电路<strong>状态转化的输入电平</strong>不同(如下图所示$V_{T+}$和$V_{T-}$)</li><li>电路状态转化时有正反馈过程,使输出波形边沿变陡</li></ul><p><img src="/images/施密特触发器.png" alt="施密特触发器"></p><h3 id="GPIO的输入浮空模式"><a href="#GPIO的输入浮空模式" class="headerlink" title="GPIO的输入浮空模式"></a><code>GPIO</code>的输入浮空模式</h3><p><strong>输入浮空模式</strong>流程:端口-1-上下拉(上下拉断开)-<code>TTL</code>肖基特触发器(工作)-5输入数据寄存器</p><h3 id="GPIO的输入上拉模式"><a href="#GPIO的输入上拉模式" class="headerlink" title="GPIO的输入上拉模式"></a><code>GPIO</code>的输入上拉模式</h3><p><strong>输入浮空模式</strong>流程:端口-1-上下拉(上拉接通)-<code>TTL</code>肖基特触发器(工作)-5输入数据寄存器</p><h3 id="GPIO的输入下拉模式"><a href="#GPIO的输入下拉模式" class="headerlink" title="GPIO的输入下拉模式"></a><code>GPIO</code>的输入下拉模式</h3><p><strong>输入浮空模式</strong>流程:端口-1-上下拉(下拉接通)-<code>TTL</code>肖基特触发器(工作)-5输入数据寄存器</p><h3 id="GPIO的模拟模式"><a href="#GPIO的模拟模式" class="headerlink" title="GPIO的模拟模式"></a><code>GPIO</code>的模拟模式</h3><p><strong>模拟模式</strong>流程:端口-1-上下拉(无效)-模拟输入</p><h1 id="GPIO寄存器"><a href="#GPIO寄存器" class="headerlink" title="GPIO寄存器"></a>GPIO寄存器</h1><p><code>STM32F103ET6</code>的<code>GPIO</code>分为<code>GPIOA,GPIOB,、、、,GPIOG 7</code>组,每组包括<code>16</code>个端口,共<code>112</code>个端口</p><h2 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h2><div class="table-container"><table><thead><tr><th style="text-align:center">输入模式</th><th style="text-align:center">输出模式</th></tr></thead><tbody><tr><td style="text-align:center">输入浮空</td><td style="text-align:center">开漏输出</td></tr><tr><td style="text-align:center">输入上拉</td><td style="text-align:center">开漏复用功能</td></tr><tr><td style="text-align:center">输入下拉</td><td style="text-align:center">推挽式输出</td></tr><tr><td style="text-align:center">模拟输入</td><td style="text-align:center">推挽式复用功能</td></tr></tbody></table></div><h2 id="3种最大翻转速度"><a href="#3种最大翻转速度" class="headerlink" title="3种最大翻转速度"></a>3种最大翻转速度</h2><p><code>2MHZ、10MHz、50MHz</code></p><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>每组<code>GPIO</code>都包含以下寄存器:<br>两个32位<strong>配置寄存器</strong>(<code>GPIOx_CRL,GPIOx_CRH</code>)<br>两个32位<strong>数据寄存器</strong> (<code>GPIOx_IDR和GPIOx_ODR</code>)<br>一个32位<strong>置位/复位寄存器</strong>(<code>GPIOx_BSRR</code>)<br>一个16位<strong>复位寄存器</strong>(<code>GPIOx_BRR</code>)，<br>一个32位<strong>锁定寄存器</strong>(<code>GPIOx_LCKR</code>)</p><blockquote><p>具体如何配置这些寄存器参考<code>STM32中文参考手册_V10.pdf-8.2 GPIO寄存器描述</code></p></blockquote><h3 id="配置寄存器"><a href="#配置寄存器" class="headerlink" title="配置寄存器"></a>配置寄存器</h3><ul><li>两个32位<strong>配置寄存器</strong>(<code>GPIOx_CRL,GPIOx_CRH</code>) ,共<code>64</code>个<code>bit</code>位,配置每个端口需要4个<code>bit</code>位,刚好为<code>16</code>个端口配置;</li><li>配置寄存器可以<strong>配置</strong>每个端口的<strong>最大翻转速度</strong>和<code>8</code>中端口模式<blockquote><p>具体如何配置这些寄存器参考<code>STM32中文参考手册_V10.pdf-8.2 GPIO寄存器描述 - 8.2.1~8.2.2</code></p></blockquote></li></ul><h3 id="数据寄存器"><a href="#数据寄存器" class="headerlink" title="数据寄存器"></a>数据寄存器</h3><ul><li>32位<strong>数据寄存器</strong> <code>GPIOx_IDR</code>,<strong>读取端口电平</strong><br><code>GPIOx_IDR</code>高<code>16</code>位没有使用,低<code>16</code>位<strong>寄存器</strong>分别表示<code>16</code>个端口的<strong>输入电平高低</strong>;当<strong>配置为输入模式</strong>(非模拟)时或<strong>输出模式</strong>时都可以获取当前<strong>电平的高低</strong></li></ul><ul><li>32位<strong>数据寄存器</strong> (<code>GPIOx_ODR</code>),控制<strong>输出高低电平</strong><ul><li><code>GPIOx_ODR</code>高<code>16</code>位没有使用,低<code>16</code>位<strong>寄存器</strong>分别控制<code>16</code>个端口的<strong>输出电平高低</strong>;</li><li>如果当前为<strong>输入模式</strong>,则<code>GPIOx_ODR</code>相应位为<code>1</code>表示上拉,<code>GPIOx_ODR</code>相应位为<code>0</code>表示下拉</li></ul></li></ul><h3 id="置位-复位寄存器"><a href="#置位-复位寄存器" class="headerlink" title="置位/复位寄存器"></a>置位/复位寄存器</h3><p>32位<strong>置位/复位寄存器</strong>(<code>GPIOx_BSRR</code>),控制<strong>输出高低电平</strong></p><ul><li><p>高<code>16</code>位-这些位只能写入并只能以字(<code>16</code>位)的形式操作</p><ul><li>写0:对输出端口<strong>没有影响</strong></li><li>写1:将对应输出端口<strong>置</strong>为<code>0</code></li></ul></li><li><p>低<code>16</code>位-这些位只能写入并只能以字(<code>16</code>位)的形式操作</p><ul><li>写0:对输出端口<strong>没有影响</strong></li><li>写1:将对应输出端口<strong>置</strong>为<code>1</code></li></ul></li></ul><h3 id="复位寄存器"><a href="#复位寄存器" class="headerlink" title="复位寄存器"></a>复位寄存器</h3><p>16位<strong>复位寄存器</strong>(<code>GPIOx_BRR</code>)</p><ul><li>写<code>1</code>:对对应的<code>ODRy</code>位<strong>不产生影响</strong></li><li>写<code>0</code>:清除对应的<code>ODRy</code>位为<code>0</code> </li></ul><h3 id="锁定寄存器"><a href="#锁定寄存器" class="headerlink" title="锁定寄存器"></a>锁定寄存器</h3><p>用来配置是否允许修改<strong>配置寄存器</strong>(<code>GPIOx_CRL、GPIOx_CRH</code>)</p><h2 id="端口复用和端口重映射"><a href="#端口复用和端口重映射" class="headerlink" title="端口复用和端口重映射"></a>端口复用和端口重映射</h2><p>略</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32-00-STM32F103ZET6介绍</title>
      <link href="/2022/02/26/Embedded-System-00/STM32-00/"/>
      <url>/2022/02/26/Embedded-System-00/STM32-00/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>msys2</title>
      <link href="/2022/02/19/msys2/"/>
      <url>/2022/02/19/msys2/</url>
      
        <content type="html"><![CDATA[<h1 id="msys2的安装"><a href="#msys2的安装" class="headerlink" title="msys2的安装"></a>msys2的安装</h1><p><code>MSYS2 is a collection of tools and libraries providing you with an easy-to-use environment for building, installing and running native Windows software.</code></p><p><a href="https://www.msys2.org/">下载 msys2</a><br><br><br></p><h1 id="msys2的使用"><a href="#msys2的使用" class="headerlink" title="msys2的使用"></a>msys2的使用</h1><h2 id="修改源"><a href="#修改源" class="headerlink" title="修改源"></a>修改源</h2><p>修改文件<code>msys64/etc/pacman.d/mirrorlist.mingw64</code></p><p>在最上面增加<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Server = https://mirrors.tuna.tsinghua.edu.cn/msys2/mingw/x86_64</span><br></pre></td></tr></table></figure><br><br></p><h2 id="下载工具链"><a href="#下载工具链" class="headerlink" title="下载工具链"></a>下载工具链</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S mingw-w64-x86_64-toolchain</span><br></pre></td></tr></table></figure><blockquote><p>此时已有<code>gcc,ar,ld</code>等工具,但是没有<code>make</code></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S base-devel</span><br></pre></td></tr></table></figure><blockquote><p>此时已有<code>make</code></p></blockquote><p><br></p><h2 id="vscode中添加msys2"><a href="#vscode中添加msys2" class="headerlink" title="vscode中添加msys2"></a><code>vscode</code>中添加<code>msys2</code></h2><p>参考<a href="/2021/09/12/vscode的基本使用/">vscode 中添加 msys2 shell</a></p><p><br></p><h2 id="使用msys2编译ffmpeg"><a href="#使用msys2编译ffmpeg" class="headerlink" title="使用msys2编译ffmpeg"></a>使用<code>msys2</code>编译<code>ffmpeg</code></h2><ul><li>准备<a href="https://github.com/FFmpeg/FFmpeg.git">ffmpeg</a>、<a href="https://www.videolan.org/developers/x264.html">x264</a>,并解压到如下指定的路径中;</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tangcheng@LAPTOP-85H0O1H5 MINGW64 ~/ffmpeg_build</span><br><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">/home/tangcheng/ffmpeg_build</span><br><span class="line"></span><br><span class="line">tangcheng@LAPTOP-85H0O1H5 MINGW64 ~/ffmpeg_build</span><br><span class="line">$ ls</span><br><span class="line">FFmpeg-master  x264-master</span><br></pre></td></tr></table></figure><ul><li>安装<br>没有安装汇编工具<code>nasm</code>时,会报如下错误<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">------------------ build x264-master ----------------</span><br><span class="line">Found no assembler</span><br><span class="line">Minimum version is nasm-2.13</span><br><span class="line">If you really want to compile without asm, configure with --disable-asm.</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S nasm</span><br></pre></td></tr></table></figure><ul><li>编译脚本<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">tangcheng@LAPTOP-85H0O1H5 MINGW64 /home/tangcheng/ffmpeg_build</span><br><span class="line">$ ls</span><br><span class="line">build.sh  FFmpeg-master  x264_install  x264-master</span><br><span class="line"></span><br><span class="line">tangcheng@LAPTOP-85H0O1H5 MINGW64 /home/tangcheng/ffmpeg_build</span><br><span class="line">$ cat ./build.sh </span><br><span class="line">ROOT=$(<span class="built_in">cd</span> `dirname <span class="variable">$0</span>`;<span class="built_in">pwd</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;ROOT is &quot;</span><span class="variable">$&#123;ROOT&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># build x264-master</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;------------------ build x264-master ----------------&quot;</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$&#123;ROOT&#125;</span>/x264-master</span><br><span class="line">./configure --prefix=<span class="variable">$&#123;ROOT&#125;</span>/x264_install --enable-static</span><br><span class="line">make -j4</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;------------------ build ffmpeg ----------------&quot;</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$&#123;ROOT&#125;</span>/FFmpeg-master</span><br><span class="line">./configure --enable-static --enable-shared --enable-libx264 \</span><br><span class="line">--extra-cflags=-I<span class="variable">$&#123;ROOT&#125;</span>/x264_install/include \</span><br><span class="line">--extra-ldflags=-L<span class="variable">$&#123;ROOT&#125;</span>/x264_install/lib    \</span><br><span class="line">--enable-gpl</span><br><span class="line"><span class="comment"># ./configure --prefix=$&#123;ROOT&#125;/ffmpeg_install --enable-static --enable-shared --enable-libx264 \</span></span><br><span class="line"><span class="comment"># --extra-cflags=-I$&#123;ROOT&#125;/x264_install/include \</span></span><br><span class="line"><span class="comment"># --extra-ldflags=-L$&#123;ROOT&#125;/x264_install/lib    \</span></span><br><span class="line"><span class="comment"># --enable-gpl</span></span><br><span class="line">make -j4</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><blockquote><ul><li><code>ffmpeg</code>的头文件<strong>默认安装路径</strong>在<code>msys64\usr\local\include</code></li><li><code>ffmpeg</code>的库文件<strong>默认安装路径</strong>在<code>msys64\usr\local\bin</code></li></ul></blockquote></li></ul><p><br></p><h2 id="vscode和msys2-FFmpeg"><a href="#vscode和msys2-FFmpeg" class="headerlink" title="vscode和msys2,FFmpeg"></a><code>vscode</code>和<code>msys2</code>,<code>FFmpeg</code></h2><p>要想在vscode和<code>msys2</code>的环境中使用<code>FFmpeg</code>库</p><ul><li><p>首先需要修改<code>msys64/msys2_shell.cmd</code>文件<br>添加如下内容,指定<strong>头文件路径</strong>和<strong>库文件路径</strong>,编译和链接阶段都需要用</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> LIBRARY_PATH=path2msys64\usr\local\bin</span><br><span class="line"><span class="built_in">set</span> C_INCLUDE_PATH=path2msys64\usr\local\include</span><br></pre></td></tr></table></figure></li><li><p>使用<code>vscode</code>函数跳转,需要在<code>c_cpp_properties.json</code>的<code>includePath</code>中<strong>添加头文件路径</strong>(即<code>&quot;E:\\msys64\\usr\\local\\include\\*&quot;</code>)</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ /demo00/.vscode</span><br><span class="line">$ ls</span><br><span class="line">c_cpp_properties.json  settings.json</span><br><span class="line"></span><br><span class="line">$ /demo00/.vscode</span><br><span class="line">$ cat ./c_cpp_properties.json </span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Win32&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;includePath&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;E:\\msys64\\usr\\local\\include\\*&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;defines&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;_DEBUG&quot;</span>,</span><br><span class="line">                <span class="string">&quot;UNICODE&quot;</span>,</span><br><span class="line">                <span class="string">&quot;_UNICODE&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;compilerPath&quot;</span>: <span class="string">&quot;E:\\msys64\\mingw64\\bin\\gcc.exe&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;cStandard&quot;</span>: <span class="string">&quot;gnu17&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;cppStandard&quot;</span>: <span class="string">&quot;gnu++14&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;intelliSenseMode&quot;</span>: <span class="string">&quot;windows-gcc-x64&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavcodec/avcodec.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, avcodec_configuration());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">OBJ=demo</span><br><span class="line"></span><br><span class="line"><span class="variable">$(OBJ)</span> : main.c</span><br><span class="line">gcc <span class="variable">$^</span> -lavcodec  -o  <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm <span class="variable">$(OBJ)</span></span><br></pre></td></tr></table></figure><blockquote><p>编译和运行需要在<code>MSYS2 MinGWx64</code>中完成</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows,编译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>odrvie01-1电机速度闭环运行模式</title>
      <link href="/2022/01/16/odrvie01/"/>
      <url>/2022/01/16/odrvie01/</url>
      
        <content type="html"><![CDATA[<h1 id="实时绘制"><a href="#实时绘制" class="headerlink" title="实时绘制"></a>实时绘制</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">66</span>]: start_liveplotter(<span class="keyword">lambda</span>:[odrv0.axis0.encoder.vel_estimate,odrv0.axis0.controller.input_vel])</span><br><span class="line">Out[<span class="number">66</span>]: &lt;fibre.utils.Event at <span class="number">0x132014b9070</span>&gt;</span><br></pre></td></tr></table></figure><h1 id="设置速度控制模式"><a href="#设置速度控制模式" class="headerlink" title="设置速度控制模式"></a>设置速度控制模式</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">86</span>]: odrv0.axis0.controller.config.control_mode=CONTROL_MODE_VELOCITY_CONTROL</span><br><span class="line"></span><br><span class="line">In [<span class="number">86</span>]: odrv0.axis0.controller.config.control_mode=</span><br><span class="line">Out[<span class="number">86</span>]: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">87</span>]: CONTROL_MODE_VELOCITY_CONTROL</span><br><span class="line">Out[<span class="number">87</span>]: <span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="设置速度"><a href="#设置速度" class="headerlink" title="设置速度"></a>设置速度</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">77</span>]: odrv0.axis0.controller.input_vel=<span class="number">5</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Odrive&amp;Motor </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Motor,Odrive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>odrvie00-电机位置闭环运行模式</title>
      <link href="/2022/01/16/odrvie00/"/>
      <url>/2022/01/16/odrvie00/</url>
      
        <content type="html"><![CDATA[<p><code>Tiger U8</code>效率型<code>KV170</code>的参数说明可以在<a href="https://uav-cn.tmotor.com/html/2018/U_1106/9.html">U8官网</a>获得,详细参数如下:<br><img src="/images/U8产品测试记录.png" alt="U8产品测试记录"><br><img src="/images/U8负载测试数据.png" alt="U8负载测试数据"></p><h1 id="配置限制"><a href="#配置限制" class="headerlink" title="配置限制"></a>配置限制</h1><h2 id="设置限制电流"><a href="#设置限制电流" class="headerlink" title="设置限制电流"></a>设置限制电流</h2><p>由表<strong>U8产品测试记录</strong>可知,最大持续电流为<code>35 A</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">9</span>]: odrv0.axis0.motor.config.current_lim=<span class="number">35</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: odrv0.axis0.motor.config.current_lim</span><br><span class="line">Out[<span class="number">9</span>]: <span class="number">35.0</span></span><br></pre></td></tr></table></figure></p><h2 id="设置电流采样范围"><a href="#设置电流采样范围" class="headerlink" title="设置电流采样范围"></a>设置电流采样范围</h2><p>一般把<strong>电流采样范围</strong>设置为比<strong>限制电流</strong>大的值,此处设置为<code>70 A</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">11</span>]: odrv0.axis0.motor.config.requested_current_range=<span class="number">70</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: odrv0.axis0.motor.config.requested_current_range</span><br><span class="line">Out[<span class="number">11</span>]: <span class="number">70.0</span></span><br></pre></td></tr></table></figure></p><h2 id="设置电机转速最大值"><a href="#设置电机转速最大值" class="headerlink" title="设置电机转速最大值"></a>设置电机转速最大值</h2><p>由表<strong>U8负载测试数据</strong>可知最大转速为<code>2700r/min</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">10</span>]: odrv0.axis0.controller.config.vel_limit=<span class="number">2700</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: odrv0.axis0.controller.config.vel_limit</span><br><span class="line">Out[<span class="number">10</span>]: <span class="number">2700.0</span></span><br></pre></td></tr></table></figure></p><h2 id="电机校准电流限制"><a href="#电机校准电流限制" class="headerlink" title="电机校准电流限制"></a>电机校准电流限制</h2><p>在校准电机时的电流限制, 这使得电机校准时可以承受一定的负载<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">12</span>]: odrv0.axis0.motor.config.calibration_current=<span class="number">20</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: odrv0.axis0.motor.config.calibration_current</span><br><span class="line">Out[<span class="number">12</span>]: <span class="number">20.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="AS5047P编码器接线"><a href="#AS5047P编码器接线" class="headerlink" title="AS5047P编码器接线"></a>AS5047P编码器接线</h1><p>下图为<strong>AS504D的接线图</strong>, 而<code>AS5047P</code>只需要在<strong>AS504D的接线图</strong>的基础上, 把<code>AS5047P</code>中<code>A</code>端子左边的<code>I/PWM</code>接入<code>Odrive</code>中的<code>Z</code>端子即可;<br><img src="/images/U8&amp;AS5047P接线图.png" alt="AS5047P接线图"></p><p>如果<code>AS5047P</code>使用<code>5V</code>供电,则跳线帽与<code>5V</code>相连,否则与<code>3V3</code>相连<br><img src="/images/U8&amp;AS5047P原理图.png" alt="AS5047P原理图"></p><blockquote><p>此处与<code>5V</code>相连</p></blockquote><h1 id="配置硬件参数"><a href="#配置硬件参数" class="headerlink" title="配置硬件参数"></a>配置硬件参数</h1><h2 id="设置耗散电阻值"><a href="#设置耗散电阻值" class="headerlink" title="设置耗散电阻值"></a>设置耗散电阻值</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">3</span>]: odrv0.config.brake_resistance=<span class="number">0.47</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: odrv0.config.brake_resistance</span><br><span class="line">Out[<span class="number">3</span>]: <span class="number">0.4699999988079071</span></span><br></pre></td></tr></table></figure><h2 id="设置极对数"><a href="#设置极对数" class="headerlink" title="设置极对数"></a>设置极对数</h2><p><strong>极对数</strong>不是定子中的线圈的数量,而是转子中的<strong>磁条数</strong>,查看产品测试记录表可知极对数为<code>42/2</code>(磁钢个数除以<code>2</code>)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">4</span>]: odrv0.axis0.motor.config.pole_pairs=<span class="number">21</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: odrv0.axis0.motor.config.pole_pairs</span><br><span class="line">Out[<span class="number">4</span>]: <span class="number">21</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h2 id="设置电机类型"><a href="#设置电机类型" class="headerlink" title="设置电机类型"></a>设置电机类型</h2><p>电机类型有<strong>大电流电机</strong>-<code>MOTOR_TYPE_HIGH_CURRENT</code>,<strong>云台电机</strong>-<code>MOTOR_TYPE_GIMBAL</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">5</span>]: odrv0.axis0.motor.config.motor_type=MOTOR_TYPE_HIGH_CURRENT</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: odrv0.axis0.motor.config.motor_type</span><br><span class="line">Out[<span class="number">5</span>]: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: MOTOR_TYPE_HIGH_CURRENT</span><br><span class="line">Out[<span class="number">6</span>]: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: MOTOR_TYPE_GIMBAL</span><br><span class="line">Out[<span class="number">7</span>]: <span class="number">2</span></span><br></pre></td></tr></table></figure></p><h2 id="编码器每转计数"><a href="#编码器每转计数" class="headerlink" title="编码器每转计数"></a>编码器每转计数</h2><p>编码器一般以四倍频计数,脉冲数<code>PPR</code>值的<code>4</code>倍,一般<code>AS5047P</code>的脉冲数是<code>1000</code>，所以这里应该<code>4000</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">8</span>]: odrv0.axis0.encoder.config.cpr=<span class="number">4000</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: odrv0.axis0.encoder.config.cpr</span><br><span class="line">Out[<span class="number">8</span>]: <span class="number">4000</span></span><br></pre></td></tr></table></figure></p><h2 id="保存配置"><a href="#保存配置" class="headerlink" title="保存配置"></a>保存配置</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">9</span>]: odrv0.save_configuration()</span><br></pre></td></tr></table></figure><h1 id="校准电机"><a href="#校准电机" class="headerlink" title="校准电机"></a>校准电机</h1><h2 id="电机特性测量和编码器校准"><a href="#电机特性测量和编码器校准" class="headerlink" title="电机特性测量和编码器校准"></a>电机特性测量和编码器校准</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">9</span>]: odrv0.axis0.requested_state=AXIS_STATE_FULL_CALIBRATION_SEQUENCE</span><br></pre></td></tr></table></figure><h2 id="电机已校准"><a href="#电机已校准" class="headerlink" title="电机已校准"></a>电机已校准</h2><p>电机已校准,重启后可以直接使用本次校准的结果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">9</span>]: odrv0.axis0.motor.config.pre_calibrated=<span class="literal">True</span></span><br></pre></td></tr></table></figure></p><h2 id="重启后操作"><a href="#重启后操作" class="headerlink" title="重启后操作"></a>重启后操作</h2><p>重启后可以直接使用<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: odrv0.axis0.requested_state=AXIS_STATE_ENCODER_OFFSET_CALIBRATION</span><br></pre></td></tr></table></figure></p><h1 id="闭环控制"><a href="#闭环控制" class="headerlink" title="闭环控制"></a>闭环控制</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">2</span>]: odrv0.axis0.requested_state=AXIS_STATE_CLOSED_LOOP_CONTROL</span><br></pre></td></tr></table></figure><ul><li>此时扭动电机转子时,电机会反抗,并回到转动前的位置;</li><li>此时的<strong>闭环控制</strong>默认是<strong>位置闭环控制</strong>(有下面的指令可以查看)<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">11</span>]: odrv0.axis0.controller.config.control_mode</span><br><span class="line">Out[<span class="number">11</span>]: <span class="number">3</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: CONTROL_MODE_POSITION_CONTROL</span><br><span class="line">Out[<span class="number">14</span>]: <span class="number">3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h1 id="位置闭环控制命令汇总"><a href="#位置闭环控制命令汇总" class="headerlink" title="位置闭环控制命令汇总"></a>位置闭环控制命令汇总</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">odrv0.axis0.motor.config.current_lim=<span class="number">35</span></span><br><span class="line"></span><br><span class="line">odrv0.axis0.motor.config.requested_current_range=<span class="number">70</span></span><br><span class="line"></span><br><span class="line">odrv0.axis0.controller.config.vel_limit=<span class="number">2700</span></span><br><span class="line"></span><br><span class="line">odrv0.axis0.motor.config.calibration_current=<span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ------------------------------------</span></span><br><span class="line">odrv0.config.brake_resistance=<span class="number">0.47</span></span><br><span class="line"></span><br><span class="line">odrv0.axis0.motor.config.pole_pairs=<span class="number">21</span></span><br><span class="line"></span><br><span class="line">odrv0.axis0.motor.config.motor_type=MOTOR_TYPE_HIGH_CURRENT</span><br><span class="line"></span><br><span class="line">odrv0.axis0.encoder.config.cpr=<span class="number">4000</span></span><br><span class="line"></span><br><span class="line">odrv0.save_configuration()</span><br><span class="line"></span><br><span class="line"><span class="comment">#---------------------------------</span></span><br><span class="line">odrv0.axis0.requested_state=AXIS_STATE_FULL_CALIBRATION_SEQUENCE</span><br><span class="line"></span><br><span class="line">odrv0.axis0.motor.config.pre_calibrated=<span class="literal">True</span></span><br><span class="line"></span><br><span class="line">odrv0.axis0.requested_state=AXIS_STATE_ENCODER_OFFSET_CALIBRATION</span><br><span class="line"></span><br><span class="line"><span class="comment">#-------------------------------</span></span><br><span class="line">odrv0.axis0.requested_state=AXIS_STATE_CLOSED_LOOP_CONTROL</span><br></pre></td></tr></table></figure><h1 id="使用dump-errors查看error"><a href="#使用dump-errors查看error" class="headerlink" title="使用dump_errors查看error"></a>使用<code>dump_errors</code>查看error</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">29</span>]: dump_errors(odrv0)</span><br><span class="line">axis0</span><br><span class="line">  axis: no error</span><br><span class="line">  motor: no error</span><br><span class="line">  fet_thermistor: no error</span><br><span class="line">  motor_thermistor: no error</span><br><span class="line">  encoder: no error</span><br><span class="line">  controller: no error</span><br><span class="line">axis1</span><br><span class="line">  axis: no error</span><br><span class="line">  motor: no error</span><br><span class="line">  fet_thermistor: no error</span><br><span class="line">  motor_thermistor: no error</span><br><span class="line">  encoder: no error</span><br><span class="line">  controller: no error</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Odrive&amp;Motor </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Motor,Odrive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gcc01</title>
      <link href="/2021/12/19/gcc01/"/>
      <url>/2021/12/19/gcc01/</url>
      
        <content type="html"><![CDATA[<h1 id="编译参数"><a href="#编译参数" class="headerlink" title="编译参数"></a>编译参数</h1><h2 id="fno-common"><a href="#fno-common" class="headerlink" title="-fno-common"></a><code>-fno-common</code></h2>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gcc编译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《链接、装载与库》-第三章-目标文件中有什么</title>
      <link href="/2021/12/17/%E9%93%BE%E6%8E%A5%E3%80%81%E8%A3%85%E8%BD%BD%E4%B8%8E%E5%BA%933/"/>
      <url>/2021/12/17/%E9%93%BE%E6%8E%A5%E3%80%81%E8%A3%85%E8%BD%BD%E4%B8%8E%E5%BA%933/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在学习第<code>3</code>章内容时,可结合<code>b</code>站的<a href="https://www.bilibili.com/video/BV1xf4y127AJ?p=1">视频教程</a>一块学习;</p></blockquote><p>使用<code>gcc</code>命令从<code>C</code>源代码文件开始,经过<strong>预处理</strong>、<strong>编译</strong>和<strong>汇编</strong>直接输出<strong>目标文件(Object File)</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.c -o hello.o</span><br></pre></td></tr></table></figure><br><br><br><br><br><strong>目标文件</strong>已近编译后的<strong>可执行程序文件格式</strong>,只是没有经过链接的过程,其中有些<strong>符号</strong>或则<strong>地址</strong>还没有被调整。 但与可执行程序稍有不同。</p><h1 id="目标文件的格式"><a href="#目标文件的格式" class="headerlink" title="目标文件的格式"></a>目标文件的格式</h1><ul><li><p>可执行文件的格式</p><ul><li><code>Windows</code>下的<code>PE(Portable Executable)</code></li><li><code>Linux</code>下的<code>ELF(Executable Linkable Format)</code><blockquote><p>都是<code>COFF(Common file format)</code>格式的变种</p></blockquote></li></ul></li><li><p>目标文件</p><ul><li><code>Windows</code>下的<code>.obj</code></li><li><code>Linux</code>下的<code>.o</code></li></ul></li><li><p>可以广义地将<strong>可执行程序</strong>和<strong>目标文件</strong>看出一种类型的文件</p><ul><li>在<code>Windows</code>可统称为<code>PE-COFF</code>文件格式</li><li>在<code>Linux</code>下的<code>ELF(Executable Linkable Format)</code>文件格式<blockquote><p>1、还有<strong>不太常见的可执行文件格式</strong>,包括<code>Intel/Microsoft</code>的<code>OMF(Object Module Format)</code>、<code>Unix</code>的<code>a.out</code>、<code>MS-DOS</code>的<code>.COM</code>格式;<br>2、同时<strong>动态库</strong>、<strong>静态链接库</strong>都是以可执行文件的格式存储的。</p></blockquote></li></ul></li><li><p><code>ELF</code>文件分类</p><ul><li><strong>可重定位文件(Relocatable File)</strong>, 指<code>Linux</code>中的<strong>中间目标文件</strong><code>.o</code>文件和<strong>静态库</strong>文件<code>.a</code></li><li><strong>可执行文件(Executable File)</strong>,如<code>/bash/ls</code></li><li><strong>共享目标文件(Shared Object File)</strong>, 如<code>.so</code>文件</li><li><strong>核心转储文件(Core Dump File)</strong>, <code>Linux</code>下的<code>core dump</code>文件</li></ul></li></ul><p>使用<code>file</code>命令查看文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ file /usr/arm-linux-gnueabi/libhf/libc.a   </span><br><span class="line">/usr/arm-linux-gnueabi/libhf/libc.a: symbolic link to ../../arm-linux-gnueabihf/lib/libc.a</span><br><span class="line"></span><br><span class="line">➜  ~ file /bin/ls</span><br><span class="line">/bin/ls: ELF 64-bit LSB shared object, ARM aarch64, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-aarch64.so.1, BuildID[sha1]=168521274d24d03cbab1365c28dc20078bf46835, <span class="keyword">for</span> GNU/Linux 3.7.0, stripped</span><br><span class="line"></span><br><span class="line">➜  ~ file Code_ws/Pthreads_ws/draft_ws/build/4.2.main </span><br><span class="line">Code_ws/Pthreads_ws/draft_ws/build/4.2.main: ELF 64-bit LSB shared object, ARM aarch64, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-aarch64.so.1, BuildID[sha1]=aa9246776ef8e4137c530cf6ade9cf05f6c91b3b, <span class="keyword">for</span> GNU/Linux 3.7.0, not stripped</span><br><span class="line"></span><br><span class="line">➜  ~ file /usr/arm-linux-gnueabihf/lib/libpthread-2.31.so               </span><br><span class="line">/usr/arm-linux-gnueabihf/lib/libpthread-2.31.so: ELF 32-bit LSB shared object, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-armhf.so.3, BuildID[sha1]=3b1842b42852463304a6420e759eeaad690ab671, <span class="keyword">for</span> GNU/Linux 3.2.0, not stripped</span><br></pre></td></tr></table></figure><br><br><br><br></p><h1 id="目标文件是什么样子"><a href="#目标文件是什么样子" class="headerlink" title="目标文件是什么样子"></a>目标文件是什么样子</h1><p>目标文件中至少包含<strong>机器指令代码</strong>、<strong>数据</strong>; 除此之外<strong>目标文件</strong>还包含了<strong>链接时所需要的一些信息</strong>,比如<strong>符号表</strong>、<strong>调试信息</strong>、<strong>字符串</strong>等;一般目标文件将这些信息按照<code>Section</code>和<code>Segment</code>的形式存储,<code>Section</code>和<code>Segment</code>梢有不同。</p><ul><li><code>.code</code>和<code>.text</code>：保存了<strong>机器指令代码</strong></li><li><code>.data</code>:保存了已<strong>初始化</strong>的<strong>全局变量</strong>和已<strong>初始化</strong>的<strong>局部静态变量</strong></li><li><code>.bss(Block Started by Symbol)</code>: 保存了<strong>未初始化的全局变量和未初始化的局部变量</strong>;因为<strong>未初始化的全局变量和未初始化的局部变量</strong>都是<code>0</code>,所以把它们两保存在<code>.data</code>段分配内存空间并且存放<code>0</code>是<strong>没有必要的</strong>;所以<code>.bss</code>段只是<strong>为未初始化的全局变量和未初始化的局部变量预留位置而已,它没有内容</strong>。</li></ul><p><strong>总体而言,程序源代码被编译后主要分为两种数据:程序指令和程序数据。代码段属于程序指令,而数据段和<code>.bss</code>段属于程序数据。</strong></p><h2 id="区分程序指令和数据指令"><a href="#区分程序指令和数据指令" class="headerlink" title="区分程序指令和数据指令"></a>区分程序指令和数据指令</h2><p>区分<strong>程序指令</strong>和<strong>数据指令</strong>并分开存储的原因？</p><ul><li><strong>程序指令</strong>和<strong>数据指令</strong>被映射到两个虚拟区域后, 对于<strong>数据区域</strong>来说, 进程<strong>可读可写</strong>;但是对于指令区域来说,<strong>进程只可读</strong>。这样可以<strong>防止进程无意改写</strong>。</li><li>由于<code>Cache</code>体系的<strong>时间局部性和空间局部性</strong>策略,<strong>程序指令</strong>和<strong>数据指令</strong>被映射到两个虚拟区域,对<code>CPU</code>的缓存命中率提高有好处。</li><li><strong>最重要的原因</strong>:当系统中<strong>运行多个该程序的副本</strong>时, 内存只需要<strong>保存一份该程序的指令部分</strong>。且对于程序里面的<strong>图标、图片、文本等资源也是属于可以共享</strong>的。但每个<strong>副本进程的数据区域都是不一样的,只要它们是私有的</strong>就行。</li></ul><p><br><br><br></p><h1 id="挖掘SimpleSection-o"><a href="#挖掘SimpleSection-o" class="headerlink" title="挖掘SimpleSection.o"></a>挖掘<code>SimpleSection.o</code></h1><p><code>objdump</code>用作显示目标文件的信息(<code>man objdump =&gt; objdump - display information from object files</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>; <span class="comment">// .text</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> global_init_var = <span class="number">84</span>;            <span class="comment">// .data 4 bytes</span></span><br><span class="line"><span class="keyword">int</span> extern_global_uninit_var;        <span class="comment">// .bss or other-4bytes or 0</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> global_static_uninit_var; <span class="comment">// .bss</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="comment">// .text</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i); <span class="comment">// .rodata 4 bytes</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> <span class="comment">// .text</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> c_int = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> static_var = <span class="number">85</span>; <span class="comment">// .data 4 bytes</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> static_var2;     <span class="comment">// .bss</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> static_a = <span class="number">1</span>;    <span class="comment">// .data 4 bytes</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> static_b = <span class="number">0</span>;    <span class="comment">// .bss</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    func1(static_var + static_var2 + a + b); <span class="comment">// .text</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生成目标文件"><a href="#生成目标文件" class="headerlink" title="生成目标文件"></a>生成目标文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  draft_ws gcc -c  ./SimpleSection.c -o SimpleSection.o</span><br><span class="line">➜  draft_ws wc ./SimpleSection.o</span><br><span class="line">   3   21 2256 ./SimpleSection.o</span><br></pre></td></tr></table></figure><p><br><br></p><h2 id="SimpleSection-o的文件布局"><a href="#SimpleSection-o的文件布局" class="headerlink" title="SimpleSection.o的文件布局"></a><code>SimpleSection.o</code>的文件布局</h2><p>可参考<code>readelf_parser</code>来解析<code>obj</code>文件中的<code>ELF Header</code>和<code>Section Headers</code>(<a href="/code/readelf_parser.zip">下载 readelf_parser.zip</a>); 目标文件的布局如下图所示,包括了<code>ELF Header</code>、<code>Sections</code>和<code>Section Headers</code>三个部分。</p><blockquote><p><strong>对齐</strong> 导致了 <code>0X589</code>和<code>0X590</code>相差一个字节</p></blockquote><p><img src="/images/obj.png" alt="SimpleSection布局"></p><h3 id="ELF-Header"><a href="#ELF-Header" class="headerlink" title="ELF Header"></a><code>ELF Header</code></h3><p>目标文件<code>.o</code>全是二进制数据,且开始部分是<code>ELF Header</code>, <code>ELF Header</code>的大小及如何解析根据<code>/usr/include/elf.h</code>中的结构体<code>Elf64/32_Ehdr</code>定义;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> e_ident[EI_NIDENT]; <span class="comment">/* Magic number and other info */</span></span><br><span class="line">  Elf64_Half  e_type;     <span class="comment">/* Object file type */</span></span><br><span class="line">  Elf64_Half  e_machine;    <span class="comment">/* Architecture */</span></span><br><span class="line">  Elf64_Word  e_version;    <span class="comment">/* Object file version */</span></span><br><span class="line">  Elf64_Addr  e_entry;    <span class="comment">/* Entry point virtual address */</span></span><br><span class="line">  Elf64_Off e_phoff;    <span class="comment">/* Program header table file offset */</span></span><br><span class="line">  Elf64_Off e_shoff;    <span class="comment">/* Section header table file offset */</span></span><br><span class="line">  Elf64_Word  e_flags;    <span class="comment">/* Processor-specific flags */</span></span><br><span class="line">  Elf64_Half  e_ehsize;   <span class="comment">/* ELF header size in bytes */</span></span><br><span class="line">  Elf64_Half  e_phentsize;    <span class="comment">/* Program header table entry size */</span></span><br><span class="line">  Elf64_Half  e_phnum;    <span class="comment">/* Program header table entry count */</span></span><br><span class="line">  Elf64_Half  e_shentsize;    <span class="comment">/* Section header table entry size */</span></span><br><span class="line">  Elf64_Half  e_shnum;    <span class="comment">/* Section header table entry count */</span></span><br><span class="line">  Elf64_Half  e_shstrndx;   <span class="comment">/* Section header string table index */</span></span><br><span class="line">&#125; Elf64_Ehdr;</span><br></pre></td></tr></table></figure><p>结构体<code>Elf64_Ehdr</code>说明了<code>ELF Header</code>的所有信息, <code>sizeof(Elf64_Ehdr)</code>为<code>64 bytes(0X40)</code>, <code>sizeof(Elf32_Ehdr)</code>为<code>52 bytes(0X34)</code>,这就是<code>Size of this header</code>所指出的大小</p><ul><li><p><code>ELF</code>文件的模数<br><code>7f 45 4c 46</code>分别对应<code>DEL</code>,<code>E</code>,<code>L</code>,<code>F</code>,模数用来确定文件的类型,操作系统在在加载可执行文件时,会确认模数是否正确,否则拒绝加载</p></li><li><p><code>02 01 01</code><br><code>02 01 01</code>分别代表<code>ELF</code>文件类型(<code>0</code>-无效格式/<code>1-ELF32</code>/<code>2-ELF64</code>)、字节序(0-无效格式/1-小端/2-大端)、<code>ELF</code>文件的主版本</p><blockquote><p><code>ELF</code>文件的主版本号一般为<code>1</code>,因为<code>ELF</code>标准在<code>1.2</code>后没有更新; <code>ELF</code>文件的模数 和 <code>02 01 01</code> 都是通过<code>e_ident</code>来体现的。</p></blockquote></li><li><p><code>Type</code>表示该文件文件类型,包括以下文件类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Legal values for e_type (object file type).  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ET_NONE   0   <span class="comment">/* No file type */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ET_REL    1   <span class="comment">/* Relocatable file */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ET_EXEC   2   <span class="comment">/* Executable file */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ET_DYN    3   <span class="comment">/* Shared object file */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ET_CORE   4   <span class="comment">/* Core file */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ET_NUM    5   <span class="comment">/* Number of defined types */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ET_LOOS   0xfe00    <span class="comment">/* OS-specific range start */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ET_HIOS   0xfeff    <span class="comment">/* OS-specific range end */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ET_LOPROC 0xff00    <span class="comment">/* Processor-specific range start */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ET_HIPROC 0xffff    <span class="comment">/* Processor-specific range end */</span></span></span><br></pre></td></tr></table></figure></li><li><p><code>Machine</code>表示生成该文件的平台框架</p></li><li><p><code>Version</code>表示目标文件的版本</p></li><li><p><code>e_entry(Entry point address)</code>:程序的<strong>入口地址</strong>, <strong>目标文件</strong>不可以执行,所以入口地址为<code>0</code></p></li><li><p><code>e_phoff(Start of program headers)</code>:<code>??</code></p></li><li><p><code>e_shoff(Start of section headers)</code>:是<code>Section headers</code>相对于<strong>文件首地址</strong>的偏移, 由<code>图 SimpleSection 布局</code>可知,该值为<code>0X590</code>,由<code>readelf</code>查询可知该值为<code>1424</code>;即表示<code>Section Headers</code>的文件偏移地址为<code>1424 bytes</code>(如<code>图 SimpleSection 布局</code>)；</p><blockquote><p>可以把<code>Section headers</code>看成一张表,表表述了各<code>Section</code>的详细信息,包括<code>name、Type、Addr、Offset、Size</code>等信息。参考”解析<code>Section Headers</code> “</p></blockquote></li><li><p><code>e_word(Flags)</code>:用来标识<code>ELF</code>文件平台相关属性</p></li><li><p><code>e_ehsize(Size of this header)</code>:即<code>sizeof(Elf64/32_Ehdr)</code></p></li><li><p><code>e_phentsize(Size of program headers)</code>:<code>??</code></p></li><li><p><code>e_phnum(Number of program headers)</code>:<code>??</code></p></li><li><p><code>e_shentsize(Size of section headers)</code>:即<code>sizeof(Elf64/32_Shdr)</code></p></li><li><p><code>e_shnum(Number of section headers)</code>:即<code>Section</code>的<strong>个数</strong>。参考”解析<code>Section Headers</code> “</p></li><li><p><code>e_shstrndx(Section header string table index)</code>:各<code>Section</code>的<code>name</code>都集中存储在<code>.shstrtab</code>中,如下所示;<code>e_shstrndx</code>表示<code>.shstrtab</code>在<code>13</code>个<code>Section</code>中的<strong>索引</strong>。参考”解析<code>Section Headers</code> “</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00000520: 2800 0000 0000 0000 002e 7379 6d74 6162  (.........symtab</span><br><span class="line">00000530: 002e 7374 7274 6162 002e 7368 7374 7274  ..strtab..shstrt</span><br><span class="line">00000540: 6162 002e 7265 6c61 2e74 6578 7400 2e64  ab..rela.text..d</span><br><span class="line">00000550: 6174 6100 2e62 7373 002e 726f 6461 7461  ata..bss..rodata</span><br><span class="line">00000560: 002e 636f 6d6d 656e 7400 2e6e 6f74 652e  ..comment..note.</span><br><span class="line">00000570: 474e 552d 7374 6163 6b00 2e72 656c 612e  GNU-stack..rela.</span><br><span class="line">00000580: 6568 5f66 7261 6d65 0000 0000 0000 0000  eh_frame........</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">➜  draft_ws git:(master) ✗ readelf -h ./SimpleSection.o</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2<span class="string">&#x27;s complement, little endian</span></span><br><span class="line"><span class="string">  Version:                           1 (current)</span></span><br><span class="line"><span class="string">  OS/ABI:                            UNIX - System V</span></span><br><span class="line"><span class="string">  ABI Version:                       0</span></span><br><span class="line"><span class="string">  Type:                              REL (Relocatable file)</span></span><br><span class="line"><span class="string">  Machine:                           AArch64</span></span><br><span class="line"><span class="string">  Version:                           0x1</span></span><br><span class="line"><span class="string">  Entry point address:               0x0</span></span><br><span class="line"><span class="string">  Start of program headers:          0 (bytes into file)</span></span><br><span class="line"><span class="string">  Start of section headers:          1424 (bytes into file)</span></span><br><span class="line"><span class="string">  Flags:                             0x0</span></span><br><span class="line"><span class="string">  Size of this header:               64 (bytes)</span></span><br><span class="line"><span class="string">  Size of program headers:           0 (bytes)</span></span><br><span class="line"><span class="string">  Number of program headers:         0</span></span><br><span class="line"><span class="string">  Size of section headers:           64 (bytes)</span></span><br><span class="line"><span class="string">  Number of section headers:         13</span></span><br><span class="line"><span class="string">  Section header string table index: 12</span></span><br></pre></td></tr></table></figure><p><br><br></p><h3 id="解析ELF-Header"><a href="#解析ELF-Header" class="headerlink" title="解析ELF Header"></a>解析<code>ELF Header</code></h3><ul><li>使用<code>mmap</code>将<strong>目标文件</strong>映射到进程内, <code>file_mmbase</code>即为<strong>目标文件</strong>的<strong>首地址</strong></li><li>将<code>file_mmbase</code>转化为<code>Elf64_Ehdr</code>类型,即可查看<code>ELF Header</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">file_mmbase = mmapHelper(file_status.st_size, fd, argv);</span><br><span class="line"><span class="keyword">const</span> Elf64_Ehdr *pElf64_Ehdr = (<span class="keyword">const</span> Elf64_Ehdr *)file_mmbase;</span><br><span class="line">printElf_Ehdr(pElf64_Ehdr);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printElf_Ehdr_e_ident</span><span class="params">(<span class="keyword">const</span> Elf64_Ehdr *pElf64_Ehdr)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  Magic:&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; EI_NIDENT; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%02x&quot;</span>, pElf64_Ehdr-&gt;e_ident[i]);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; EI_NIDENT - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printElf_Ehdr_Rest</span><span class="params">(<span class="keyword">const</span> Elf64_Ehdr *pElf64_Ehdr)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  %-35s%s\n&quot;</span>, <span class="string">&quot;Type:&quot;</span>, ((ET_REL == pElf64_Ehdr-&gt;e_type) ? <span class="string">&quot;Relocatable file&quot;</span> : <span class="string">&quot;Others&quot;</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  %-35s%s\n&quot;</span>, <span class="string">&quot;Machine:&quot;</span>, ((EM_AARCH64 == pElf64_Ehdr-&gt;e_machine) ? <span class="string">&quot;ARM AARCH64&quot;</span> : <span class="string">&quot;Others&quot;</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  %-35s0x%X\n&quot;</span>, <span class="string">&quot;Version:&quot;</span>, pElf64_Ehdr-&gt;e_version);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  %-35s0x%lX\n&quot;</span>, <span class="string">&quot;Entry point address:&quot;</span>, pElf64_Ehdr-&gt;e_entry);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  %-35s0x%lX\n&quot;</span>, <span class="string">&quot;Start of program headers:&quot;</span>, pElf64_Ehdr-&gt;e_phoff);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  %-35s0x%lX\n&quot;</span>, <span class="string">&quot;Start of section headers:&quot;</span>, pElf64_Ehdr-&gt;e_shoff);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  %-35s0x%X\n&quot;</span>, <span class="string">&quot;Flags:&quot;</span>, pElf64_Ehdr-&gt;e_flags);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  %-35s%d(bytes)\n&quot;</span>, <span class="string">&quot;Size of this header:&quot;</span>, pElf64_Ehdr-&gt;e_ehsize);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  %-35s%d(bytes)\n&quot;</span>, <span class="string">&quot;Size of program headers:&quot;</span>, pElf64_Ehdr-&gt;e_phentsize);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  %-35s%d(bytes)\n&quot;</span>, <span class="string">&quot;Number of program headers:&quot;</span>, pElf64_Ehdr-&gt;e_phnum);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  %-35s%d(bytes)\n&quot;</span>, <span class="string">&quot;Size of section headers:&quot;</span>, pElf64_Ehdr-&gt;e_shentsize);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  %-35s%d\n&quot;</span>, <span class="string">&quot;Number of section headers:&quot;</span>, pElf64_Ehdr-&gt;e_shnum);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  %-35s%d\n&quot;</span>, <span class="string">&quot;Section header string table index:&quot;</span>, pElf64_Ehdr-&gt;e_shstrndx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="Section-Headers摘要"><a href="#Section-Headers摘要" class="headerlink" title="Section Headers摘要"></a><code>Section Headers</code>摘要</h3><p>使用<code>objdump -h</code>查看<code>Section header</code>的<strong>摘要信息</strong>(<code>Display summary information from the section headers of the object file.</code>); 结合<a href="/2021/08/15/Linux-命令/">objdump命令使用</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  draft_ws objdump -h ./SimpleSection.o &gt; SimpleSection_h.txt</span><br></pre></td></tr></table></figure><br><code>SimpleSection_h.txt</code>内容如下</p><ul><li><code>sh_name(Name)</code>:用于在<code>.shstrtab</code>中查找<code>Name</code>,是<strong>偏移地址</strong>,相对于<code>.shstrtab</code>的<strong>偏移地址</strong><blockquote><p><code>Section</code>的名字在编译和链接过程中有意义,但是对于<strong>操作系统</strong>加载时并<strong>没有实质意义</strong>;<strong>操作系统</strong>如何处理该<code>Section</code>取决于该<code>Section</code>的<strong>属性</strong>和<strong>权限</strong>,<code>Section</code>的属性由<code>sh_type</code>和<code>sh_flags</code>决定。</p></blockquote></li><li><code>sh_type(Type)</code>:<code>Section</code>的<strong>类型</strong>,查看<code>SHT_XXX</code>查看所有<strong>类型</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Legal values for sh_type (section type).  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHT_NULL    0   <span class="comment">/* Section header table entry unused */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHT_PROGBITS    1   <span class="comment">/* Program data */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHT_SYMTAB    2   <span class="comment">/* Symbol table */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHT_STRTAB    3   <span class="comment">/* String table */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHT_RELA    4   <span class="comment">/* Relocation entries with addends */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHT_HASH    5   <span class="comment">/* Symbol hash table */</span></span></span><br></pre></td></tr></table></figure></li><li><code>sh_addr(Address)</code>:如果该段可以被加载,则表示被加载到进程中的<strong>虚拟地址</strong>,否则为零</li><li><code>sh_offset(Offset)</code>:该<code>Section</code>在文件中相对首地址的<strong>偏移</strong></li><li><code>sh_size(Size)</code>:是<code>Section</code>的大小</li><li><code>()</code>:</li><li><code>()</code>:</li></ul><p>使用<code>objdump -h</code>命令可以看到<code>6</code>个关键<code>Section</code>,省略了其它<code>Section</code>;<code>readelf -S</code>可以查看<code>ELF</code>文件的所有<code>Section</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">➜  draft_ws git:(master) ✗ readelf -S ./SimpleSection.o </span><br><span class="line">There are 13 section headers, starting at offset 0x590:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .text             PROGBITS         0000000000000000  00000040</span><br><span class="line">       000000000000007c  0000000000000000  AX       0     0     4</span><br><span class="line">  [ 2] .rela.text        RELA             0000000000000000  00000438</span><br><span class="line">       00000000000000c0  0000000000000018   I      10     1     8</span><br><span class="line">  [ 3] .data             PROGBITS         0000000000000000  000000bc</span><br><span class="line">       000000000000000c  0000000000000000  WA       0     0     4</span><br><span class="line">  [ 4] .bss              NOBITS           0000000000000000  000000c8</span><br><span class="line">       000000000000000c  0000000000000000  WA       0     0     4</span><br><span class="line">  [ 5] .rodata           PROGBITS         0000000000000000  000000c8</span><br><span class="line">       0000000000000004  0000000000000000   A       0     0     8</span><br><span class="line">  [ 6] .comment          PROGBITS         0000000000000000  000000cc</span><br><span class="line">       000000000000002b  0000000000000001  MS       0     0     1</span><br><span class="line">  [ 7] .note.GNU-stack   PROGBITS         0000000000000000  000000f7</span><br><span class="line">       0000000000000000  0000000000000000           0     0     1</span><br><span class="line">  [ 8] .eh_frame         PROGBITS         0000000000000000  000000f8</span><br><span class="line">       0000000000000058  0000000000000000   A       0     0     8</span><br><span class="line">  [ 9] .rela.eh_frame    RELA             0000000000000000  000004f8</span><br><span class="line">       0000000000000030  0000000000000018   I      10     8     8</span><br><span class="line">  [10] .symtab           SYMTAB           0000000000000000  00000150</span><br><span class="line">       0000000000000240  0000000000000018          11    19     8</span><br><span class="line">  [11] .strtab           STRTAB           0000000000000000  00000390</span><br><span class="line">       00000000000000a8  0000000000000000           0     0     1</span><br><span class="line">  [12] .shstrtab         STRTAB           0000000000000000  00000528</span><br><span class="line">       0000000000000061  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  p (processor specific)</span><br></pre></td></tr></table></figure></p><blockquote><p>1、以上各<code>Section</code>分别为<code>.text</code><strong>代码段</strong>、<code>.data</code><strong>数据段</strong>、<code>.bss</code><strong>段</strong>、<code>.rodata</code><strong>只读数据段</strong>、<code>.comment</code><strong>注释信息段</strong>、<code>.note.GNU-stack</code><strong>堆栈提示段</strong>; 其中<code>.eh_frame</code>段暂时不明确。<br>2、同时列出各<code>Section</code>的<strong>属性</strong>,包括<code>Size</code>大小、<code>File off</code>偏置等;<br>3、第二行中的<code>CONTENTS</code>表示<strong>该段在文件中存在</strong>, <code>.bss</code>在文件中实际上不存在;<code>.note.GNU-stack</code>虽然存在,但是<code>Size</code>却为<code>0</code>;</p></blockquote><p><br></p><h3 id="解析Section-Headers"><a href="#解析Section-Headers" class="headerlink" title="解析Section Headers"></a>解析<code>Section Headers</code></h3><p><code>Section Headers</code>是一张表,表的每一行都代表一个<code>Section</code>的<strong>摘要信息</strong>,该行如<code>Elf64_Shdr</code>(段描述符<code>Section Descriptor</code>)定义所示。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Word  sh_name;    <span class="comment">/* Section name (string tbl index) */</span></span><br><span class="line">  Elf64_Word  sh_type;    <span class="comment">/* Section type */</span></span><br><span class="line">  Elf64_Xword sh_flags;   <span class="comment">/* Section flags */</span></span><br><span class="line">  Elf64_Addr  sh_addr;    <span class="comment">/* Section virtual addr at execution */</span></span><br><span class="line">  Elf64_Off sh_offset;    <span class="comment">/* Section file offset */</span></span><br><span class="line">  Elf64_Xword sh_size;    <span class="comment">/* Section size in bytes */</span></span><br><span class="line">  Elf64_Word  sh_link;    <span class="comment">/* Link to another section */</span></span><br><span class="line">  Elf64_Word  sh_info;    <span class="comment">/* Additional section information */</span></span><br><span class="line">  Elf64_Xword sh_addralign;   <span class="comment">/* Section alignment */</span></span><br><span class="line">  Elf64_Xword sh_entsize;   <span class="comment">/* Entry size if section holds table */</span></span><br><span class="line">&#125; Elf64_Shdr;</span><br></pre></td></tr></table></figure></p><ul><li><code>pElf64_Ehdr-&gt;e_shnum</code>是<code>Section</code>的数量</li><li>每个<code>Section</code>的<code>Name</code>都保存在<code>.shstrtab</code>中,通过<code>file_mmbase + offset_shstrtab + offset_name</code>即可得到每个<code>Section</code>的<code>Name</code></li><li><code>file_mmbase + pElf64_Ehdr-&gt;e_shoff</code>是<code>Section Header</code>的<strong>首地址</strong>, <code>file_mmbase + pElf64_Ehdr-&gt;e_shoff + i * sizeof(Elf64_Shdr)</code>即为第<code>i</code>个<code>Section</code><strong>表</strong>的<strong>首地址</strong></li><li><code>Section Header</code>是<strong>描述</strong><code>Section</code>的,而不是<code>Section</code>本身;<code>pElf64_Shdr-&gt;sh_offset</code>则是<code>Section</code>本身的<strong>地址</strong>;</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint16_t</span> secNum = getSectionNum(pElf64_Ehdr);</span><br><span class="line"><span class="keyword">const</span> Elf64_Shdr *pElf64_Shdr = (<span class="keyword">const</span> Elf64_Shdr *)(file_mmbase + pElf64_Ehdr-&gt;e_shoff);</span><br><span class="line">printElf_Shdr(file_mmbase, secNum);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">getSectionNum</span><span class="params">(<span class="keyword">const</span> Elf64_Ehdr *pElf64_Ehdr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pElf64_Ehdr-&gt;e_shnum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> Elf64_Shdr *<span class="title">getElf64_Shdr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file_mmbase, <span class="keyword">size_t</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Elf64_Ehdr *pElf64_Ehdr = (<span class="keyword">const</span> Elf64_Ehdr *)file_mmbase;</span><br><span class="line">    <span class="comment">// the i th section header address</span></span><br><span class="line">    <span class="keyword">const</span> Elf64_Shdr *pElf64_Shdr = (<span class="keyword">const</span> Elf64_Shdr *)(file_mmbase + pElf64_Ehdr-&gt;e_shoff + i * <span class="keyword">sizeof</span>(Elf64_Shdr));</span><br><span class="line">    <span class="keyword">return</span> pElf64_Shdr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">getSectionName</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file_mmbase, <span class="keyword">size_t</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> isFirst = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> Elf64_Ehdr *pElf64_Ehdr = (<span class="keyword">const</span> Elf64_Ehdr *)file_mmbase;</span><br><span class="line">    <span class="comment">// the i th section header address</span></span><br><span class="line">    <span class="keyword">const</span> Elf64_Shdr *pElf64_Shdr = getElf64_Shdr(file_mmbase, i);</span><br><span class="line">    <span class="comment">// section shstrtab header address</span></span><br><span class="line">    <span class="keyword">const</span> Elf64_Shdr *pShstrtab = (<span class="keyword">const</span> Elf64_Shdr *)(file_mmbase + pElf64_Ehdr-&gt;e_shoff + pElf64_Ehdr-&gt;e_shstrndx * <span class="keyword">sizeof</span>(Elf64_Shdr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> offset_shstrtab = pShstrtab-&gt;sh_offset;</span><br><span class="line">    <span class="keyword">uint32_t</span> offset_name = pElf64_Shdr-&gt;sh_name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> file_mmbase + offset_shstrtab + offset_name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printElf_Shdr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file_mmbase, <span class="keyword">uint16_t</span> secNum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Elf64_Shdr *pElf64_Shdr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Section Headers:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  [Nr] %-15s   %-10s   %-8s %-6s %-6s %-2s %-3s %2s %3s %2s %-8s\n&quot;</span>, <span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Type&quot;</span>, <span class="string">&quot;Addr&quot;</span>, <span class="string">&quot;Off&quot;</span>, <span class="string">&quot;Size&quot;</span>, <span class="string">&quot;ES&quot;</span>, <span class="string">&quot;Flg&quot;</span>, <span class="string">&quot;Lk&quot;</span>, <span class="string">&quot;Inf&quot;</span>, <span class="string">&quot;Al&quot;</span>, <span class="string">&quot;secHoff&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;       %-15s   %-10s   %-8s %-6s %-6s %-2s %-3s %2s %3s %2s %-8s\n&quot;</span>, <span class="string">&quot;Unit&quot;</span>, <span class="string">&quot;Dec&quot;</span>, <span class="string">&quot;Hex&quot;</span>, <span class="string">&quot;Hex&quot;</span>, <span class="string">&quot;Hex&quot;</span>, <span class="string">&quot;He&quot;</span>, <span class="string">&quot;Hex&quot;</span>, <span class="string">&quot;De&quot;</span>, <span class="string">&quot;Dec&quot;</span>, <span class="string">&quot;De&quot;</span>, <span class="string">&quot;Hex&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; secNum; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  [%2ld] %-15s   &quot;</span>, i, getSectionName(file_mmbase, i));</span><br><span class="line">        pElf64_Shdr = getElf64_Shdr(file_mmbase, i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%-10d&quot;</span>, pElf64_Shdr-&gt;sh_type);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;   %08lX&quot;</span>, pElf64_Shdr-&gt;sh_addr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %06lX&quot;</span>, pElf64_Shdr-&gt;sh_offset);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %06lX&quot;</span>, pElf64_Shdr-&gt;sh_size);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %02lX&quot;</span>, pElf64_Shdr-&gt;sh_entsize);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %-3lX&quot;</span>, pElf64_Shdr-&gt;sh_flags);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %-2d&quot;</span>, pElf64_Shdr-&gt;sh_link);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %-3d&quot;</span>, pElf64_Shdr-&gt;sh_info);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %-2ld&quot;</span>, pElf64_Shdr-&gt;sh_addralign);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %08lX&quot;</span>, (<span class="keyword">char</span> *)pElf64_Shdr - (<span class="keyword">char</span> *)file_mmbase);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br></p><h2 id="Section的大小"><a href="#Section的大小" class="headerlink" title="Section的大小"></a><code>Section</code>的大小</h2><h3 id="各变量的存储区域说明"><a href="#各变量的存储区域说明" class="headerlink" title="各变量的存储区域说明"></a>各变量的存储区域说明</h3><p><img src="/images/SimpleSection.png" alt="SimpleSection"></p><ul><li><strong>已初始化的全局变量</strong>和<strong>已初始化的局部静态变量</strong> <code>=&gt;</code> <code>.data</code>; 如第<code>3</code>行、第<code>15</code>行、第<code>17</code>行所示;<ul><li>但<strong>局部静态变量被初始化</strong>为<code>0</code>时, 会被优化以节省磁盘空间,被存储在<code>.bss</code>中,如第<code>18</code>行</li></ul></li><li><strong>字符串常量</strong>被存储在<code>.rodata</code>中,如第<code>9</code>行的<code>%d\n</code>共<code>4</code>个<code>bytes</code>(包括<code>\0</code>)</li><li><strong>未初始化的全局静态变量</strong>(第<code>5</code>行)和<strong>未初始化的局部静态变量</strong>(第<code>16</code>行)会被存储在<code>.bss</code>中<ul><li>当编译时, 以<code>gcc -c  -fno-common ./SimpleSection.c</code>的方式(添加<code>-fno-common</code>选项时), <strong>未初始化的全局变量</strong>(如第<code>4</code>行)会被存储在<code>.bss</code>中;否则<code>extern_global_uninit_var</code>没有存储在任何<code>Section</code>中,等到最终链接成可执行程序时,再在<code>.bss</code>中<strong>分配空间</strong>。</li></ul></li></ul><p><strong>综上所述</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"><code>.rodata</code><strong>代码段</strong></th><th style="text-align:center"><code>.data</code><strong>数据段</strong></th><th style="text-align:center"><code>.bss</code><strong>段</strong></th></tr></thead><tbody><tr><td style="text-align:center">不使用<code>-fno-common</code>选项</td><td style="text-align:center">4</td><td style="text-align:center">12</td><td style="text-align:center">12</td></tr><tr><td style="text-align:center">使用<code>-fno-common</code>选项</td><td style="text-align:center">4</td><td style="text-align:center">12</td><td style="text-align:center">16</td></tr></tbody></table></div><p><img src="/images/fno_common.png" alt="fno_common"></p><h3 id="Section的起始地址"><a href="#Section的起始地址" class="headerlink" title="Section的起始地址"></a><code>Section</code>的起始地址</h3><div class="table-container"><table><thead><tr><th><code>Sections</code></th><th><code>size</code></th><th><code>file offset</code></th><th><code>align</code></th></tr></thead><tbody><tr><td><code>.text</code></td><td><code>0X7C</code></td><td><code>64(0X40)</code></td><td>$2^2$</td></tr><tr><td></td><td></td><td></td></tr></tbody></table></div><h2 id="对应关系"><a href="#对应关系" class="headerlink" title="对应关系"></a>对应关系</h2><p>代码段-数据段-机器码对应关系</p><p><img src="/images/代码段数据段汇编代码.png" alt="代码段-数据段-汇编代码"></p><blockquote><p>1、<code>.comment</code>中存放的是编译器版本信息,比如<code>GCC: (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0</code><br>2、这些段都有<code>.</code>作为前缀,表示是系统保留的。<br>3、可以把资源(图片/Music)作为目标文件的一个<code>Section</code></p></blockquote><p><br><br></p><h2 id="自定义段"><a href="#自定义段" class="headerlink" title="自定义段"></a>自定义段</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((section(<span class="string">&quot;custom_section&quot;</span>))) <span class="keyword">int</span> custom_var = <span class="number">43</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> <span class="comment">// .text</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">➜  draft_ws objdump -h ./customSection.o    </span><br><span class="line"></span><br><span class="line">./customSection.o:     file format elf64-littleaarch64</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  0 .text         00000008  0000000000000000  0000000000000000  00000040  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">  1 .data         00000000  0000000000000000  0000000000000000  00000048  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  2 .bss          00000000  0000000000000000  0000000000000000  00000048  2**0</span><br><span class="line">                  ALLOC</span><br><span class="line">  3 custom_section 00000004  0000000000000000  0000000000000000  00000048  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  4 .comment      0000002b  0000000000000000  0000000000000000  0000004c  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  5 .note.GNU-stack 00000000  0000000000000000  0000000000000000  00000077  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  6 .eh_frame     00000028  0000000000000000  0000000000000000  00000078  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA</span><br></pre></td></tr></table></figure><p><br><br></p><h2 id="链接的接口"><a href="#链接的接口" class="headerlink" title="链接的接口"></a>链接的接口</h2><p><br></p><h3 id="弱符号与强符号"><a href="#弱符号与强符号" class="headerlink" title="弱符号与强符号"></a>弱符号与强符号</h3><p>针对<code>C</code>语言, 编译器<strong>默认</strong>把<strong>函数</strong>和<strong>初始化了的全局变量</strong>当成<strong>强符号</strong>; <strong>未初始化的全局变量</strong>被当作<strong>弱符号</strong>;<br>编译器针对<strong>弱符号与强符号</strong>的概念,按照如下规则处理与选择被多次定义的<strong>全局符号</strong>:</p><ul><li><strong>规则1</strong>:不允许<strong>强符号被多次定义</strong>,否则<strong>链接器会报符号重复定义</strong></li><li><strong>规则2</strong>:如果一个符号在某个文件中是<strong>强符号</strong>,在其它文件中都是<strong>弱符号</strong>,则选择<strong>强符号</strong></li><li><strong>规则3</strong>:如果一个<strong>符号</strong>在多个目标文件中都是<strong>强符号</strong>,那么选择<strong>占用空间</strong>最大的一个</li></ul><p>在<code>test.c</code>变量<code>x</code>是弱符号,在<code>strongWeak.c</code>中变量<code>x</code>是强符号;所以链接完成后,全局范围内,可见的是<code>strongWeak.c</code>中的<code>x</code>;但是编译阶段<code>func</code>中已近完成汇编代码,汇编代码中把<code>20</code>复制给 <code>x</code>变量开始的地址,但是改变了被解释为<code>4</code>个字节,即往<code>&amp;x</code>开始的<code>4 bytes</code>空间内填入<code>20</code>;</p><p>所以<code>x</code>的结果为<code>0X5678</code>,<code>y</code>的结果为<code>0X1234</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  strongWeak git:(master) ✗ gcc strongWeak.c test.c -o ./strongWeak</span><br><span class="line">/usr/bin/ld: warning: alignment 2 of symbol `x<span class="string">&#x27; in /tmp/ccu9dx8p.o is smaller than 4 in /tmp/ccIgdJbt.o</span></span><br><span class="line"><span class="string">➜  strongWeak git:(master) ✗ ./strongWeak</span></span><br><span class="line"><span class="string">x:000A(dec:   10) y:000A(dec:   10)</span></span><br><span class="line"><span class="string">x:5678(dec:22136) y:1234(dec: 4660)</span></span><br></pre></td></tr></table></figure><p><img src="/images/strongWeak.png" alt="func函数调用过程"><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = <span class="number">0X12345678</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// strongWeak.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">short</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">short</span> y = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x:%04X(dec:%5d) y:%04X(dec:%5d)\n&quot;</span>, x, x, y, y);</span><br><span class="line">    func();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x:%02X(dec:%5d) y:%02X(dec:%5d)\n&quot;</span>, x, x, y, y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="强引用与弱引用"><a href="#强引用与弱引用" class="headerlink" title="强引用与弱引用"></a>强引用与弱引用</h3><ul><li><p><strong>强引用</strong>:<strong>目标文件</strong>使用<strong>外部定义的符号</strong>时,如果<strong>没有正确找到该符号的定义</strong>,则<strong>链接器</strong>会报<strong>未定义的错误</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    foo_ref();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  weak_question git:(master) ✗ gcc main.c -o main</span><br><span class="line">main.c: In <span class="keyword">function</span> ‘main’:</span><br><span class="line">main.c:8:5: warning: implicit declaration of <span class="keyword">function</span> ‘foo_ref’ [-Wimplicit-function-declaration]</span><br><span class="line">    8 |     foo_ref();</span><br><span class="line">      |     ^~~~~~~</span><br><span class="line">/usr/bin/ld: /tmp/ccl9HOK0.o: <span class="keyword">in</span> <span class="keyword">function</span> `main<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">main.c:(.text+0x8): undefined reference to `foo_ref&#x27;</span></span><br><span class="line">collect2: error: ld returned 1 <span class="built_in">exit</span> status</span><br></pre></td></tr></table></figure></li><li><p><strong>弱引用</strong>:<strong>目标文件</strong>使用<strong>外部定义的符号</strong>时,如果<strong>正确找到该符号的定义</strong>,则<strong>使用该符号</strong>;如果<strong>没有找到该符号的定义</strong>,<strong>链接器不会报错</strong>,<strong>链接器</strong>默认该符号为<code>0</code>或则一个<strong>特殊符号</strong>。<br>可以使用<code>__attribute__</code>来声明一个<strong>外部函数的引用</strong>为<strong>弱引用</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __attribute__((weakref(<span class="string">&quot;foo&quot;</span>))) <span class="function"><span class="keyword">void</span> <span class="title">foo_ref</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    foo_ref();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  weak_question git:(master) ✗ gcc main.c -o main               </span><br><span class="line">➜  weak_question git:(master) ✗ ./main             </span><br><span class="line">[1]    51824 segmentation fault (core dumped)  ./main</span><br></pre></td></tr></table></figure><p><strong>改良</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __attribute__((weakref(<span class="string">&quot;foo&quot;</span>))) <span class="function"><span class="keyword">void</span> <span class="title">foo_ref</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!foo_ref)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;undefined foo\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        foo_ref();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;foo()\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  strongWeak git:(master) ✗ gcc ./main.c -o main</span><br><span class="line">➜  strongWeak git:(master) ✗ ./main</span><br><span class="line">undefined foo</span><br><span class="line">➜  strongWeak git:(master) ✗ gcc ./main.c test.c -o main</span><br><span class="line">➜  strongWeak git:(master) ✗ ./main</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p><br></p></li></ul><h3 id="弱符号与弱引用的运用"><a href="#弱符号与弱引用的运用" class="headerlink" title="弱符号与弱引用的运用"></a>弱符号与弱引用的运用</h3><p><code>???--int pthread_create(pthread_t *, const pthread_attr_t *, void *(*)(void *), void *)</code><br>由<code>foo_ref</code>的例子可知:<strong>弱引用</strong>与<strong>弱符号</strong>对于<strong>库十分有用</strong>,</p><ul><li>如果库中定义的<strong>弱符号</strong>被用户的<strong>强符号</strong>所覆盖,从而使用<strong>自定义版本的库函数</strong></li><li>程序可以对<strong>某些扩展功能模块</strong>的引用<strong>定义为弱引用</strong>,但我们的程序<strong>链接这些模块</strong>时,<strong>功能模块</strong>正常运行;<strong>不链接这些功能模块</strong>时,就<strong>裁剪</strong>这些功能了</li></ul><p><strong>示例</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __attribute__((weakref(<span class="string">&quot;camera_module&quot;</span>))) <span class="function"><span class="keyword">void</span> <span class="title">camera_module_ref</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (camera_module_ref)</span><br><span class="line">        camera_module_ref(<span class="string">&quot;front&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Don&#x27;t use camera module.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">➜  camera_module git:(master) ✗ cat ./camera_init.c </span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">void camera_module(const char *name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;init camera[%s] module.\n&quot;</span>, name);</span><br><span class="line">&#125;</span><br><span class="line">➜  camera_module git:(master) ✗ <span class="built_in">pwd</span>               </span><br><span class="line">/weakUse/camera_module</span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------</span></span><br><span class="line">➜  weakUse git:(master) ✗ cat ./Makefile</span><br><span class="line">all : main_with_camera main_without_camera</span><br><span class="line"></span><br><span class="line">main_with_camera : main.c </span><br><span class="line">        gcc ./camera_module/camera_init.c main.c -o main_with_camera</span><br><span class="line"></span><br><span class="line">main_without_camera : main.c </span><br><span class="line">        gcc ./main.c  -o main_without_camera</span><br><span class="line"></span><br><span class="line">.PHONY : all clean</span><br><span class="line"></span><br><span class="line">clean :</span><br><span class="line">        rm main_without_camera main_with_camera ./lib/libcamera_module.a ./build/camera_init.o%</span><br></pre></td></tr></table></figure><ul><li>编译运行<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  weakUse git:(master) ✗ make</span><br><span class="line">gcc ./camera_module/camera_init.c main.c -o main_with_camera</span><br><span class="line">gcc ./main.c  -o main_without_camera</span><br><span class="line">➜  weakUse git:(master) ✗ ./main_with_camera</span><br><span class="line">init camera[front] module.</span><br><span class="line">➜  weakUse git:(master) ✗ ./main_without_camera </span><br><span class="line">Don<span class="string">&#x27;t use camera module.</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p><strong>思考</strong>:当把<code>camera_init.c</code>制作成静态库时,运行结果都是<code>Don&#39;t use camera module.</code></p></blockquote><p><br><br><br></p><h1 id="pdf"><a href="#pdf" class="headerlink" title="pdf"></a>pdf</h1><div class="row">    <embed src="/pdf/程序员的自我修养—链接、装载与库--书签目录.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-内核学习-06</title>
      <link href="/2021/11/22/Linux-%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0-06/"/>
      <url>/2021/11/22/Linux-%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0-06/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> knum[<span class="number">2</span>] = &#123;<span class="number">99</span>,<span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">hello_drv_ioctl</span> <span class="params">(struct file *pTfiles, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">switch</span>(cmd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> DEV_FIFO_CLEAN:</span><br><span class="line">printk(<span class="string">&quot;DEV_FIFOC_CLEAN\n&quot;</span>);</span><br><span class="line">result = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DEV_FIFO_GETVALUE:</span><br><span class="line">result = copy_to_user((<span class="keyword">void</span>*)arg, knum, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">printk(<span class="string">&quot;DEV_FIFO_GETVALUE %d\n&quot;</span>, knum[<span class="number">0</span>]);</span><br><span class="line">result = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DEV_FIFO_SETVALUE:</span><br><span class="line">result = copy_from_user(knum, (<span class="keyword">void</span>*)arg, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">printk(<span class="string">&quot;DEV_FIFO_SETVALUE %d\n&quot;</span>, knum[<span class="number">0</span>]);</span><br><span class="line">result = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">printk(<span class="string">&quot;UNKNOWN command\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="keyword">class</span> *<span class="title">hello_class</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1.确定主设备号 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> major = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2.定义自己的file_operations结构体 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">hello_drv</span> =</span> &#123;</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.open    = hello_drv_open,</span><br><span class="line">.read    = hello_drv_read,</span><br><span class="line">.write   = helle_drv_write,</span><br><span class="line">.release = hello_drv_close,</span><br><span class="line">.unlocked_ioctl = hello_drv_ioctl,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVNAME <span class="meta-string">&quot;/dev/hello&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    fd = open(DEVNAME, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;can not open file %s\n&quot;</span>, DEVNAME);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">result = ioctl(fd, DEV_FIFO_CLEAN);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ioctl(fd, DEV_FIFO_CLEAN) is %d\n&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">result = ioctl(fd, DEV_FIFO_GETVALUE, &amp;num);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ioctl(fd, DEV_FIFO_GETVALUE, &amp;num) is %d, num is %d\n&quot;</span>, result, num);</span><br><span class="line"></span><br><span class="line">num = <span class="number">999</span>;</span><br><span class="line"></span><br><span class="line">result = ioctl(fd, DEV_FIFO_SETVALUE, &amp;num);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ioctl(fd, DEV_FIFO_SETVALUE, &amp;num) is %d\n&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内核日志<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[ 3794.593133] /home/tangshp/Code_ws/Linux_ws/<span class="built_in">source</span>/01_hello_drv/hello_drv.c hello_init line 106</span><br><span class="line">[ 3802.109592] /home/tangshp/Code_ws/Linux_ws/<span class="built_in">source</span>/01_hello_drv/hello_drv.c hello_drv_open line 45</span><br><span class="line">[ 3802.109602] DEV_FIFOC_CLEAN</span><br><span class="line">[ 3802.109755] DEV_FIFO_GETVALUE 99</span><br><span class="line">[ 3802.109811] DEV_FIFO_SETVALUE 999</span><br><span class="line">[ 3802.109853] /home/tangshp/Code_ws/Linux_ws/<span class="built_in">source</span>/01_hello_drv/hello_drv.c hello_drv_close line 51</span><br></pre></td></tr></table></figure></p><p>用户层日志<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ioctl(fd, DEV_FIFO_CLEAN) is 10</span><br><span class="line">ioctl(fd, DEV_FIFO_GETVALUE, &amp;num) is 20, num is 99</span><br><span class="line">ioctl(fd, DEV_FIFO_SETVALUE, &amp;num) is 30</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Linux内核 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C, 驱动开发, Linux内核 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell编程</title>
      <link href="/2021/11/21/shell%E7%BC%96%E7%A8%8B/"/>
      <url>/2021/11/21/shell%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h1><ul><li>以<code>debug</code>模式运行脚本</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 0-debug.sh</span></span><br><span class="line">echo &quot;debug&quot;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sh -x ./0-debug.sh</span><br><span class="line">+ <span class="built_in">echo</span> debug</span><br><span class="line">debug</span><br></pre></td></tr></table></figure><blockquote><p>1.带<code>+</code>表示执行过程<br>2.没有<code>+</code>表示标准输出</p></blockquote><ul><li>在脚本中指定一部分脚本开启<code>debug</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;debug&quot;</span><br><span class="line">set -x </span><br><span class="line">ls</span><br><span class="line">set +x</span><br><span class="line">echo &quot;end&quot;</span><br></pre></td></tr></table></figure><blockquote><p>1.<code>set -x</code>开启<code>debug</code><br>2.<code>set +x</code>关闭<code>debug</code></p></blockquote><h1 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h1><h2 id="正则符号"><a href="#正则符号" class="headerlink" title="正则符号"></a>正则符号</h2><ul><li>基础正则( <code>^</code> <code>$</code> <code>^$</code> <code>.</code> <code>*</code> <code>.*</code> <code>[a-z]</code> <code>[^abc]</code> )-(<code>Basic RE-BRE</code>)<br>支持的命令包括<code>grep/sed/awk</code></li><li>扩展正则( <code>+</code> <code>|</code> <code>()</code> <code>&#123;&#125;</code> <code>?</code>)-(<code>Extended RE-ERE</code>)<br>支持的命令包括<code>egrep/sed -r/awk</code></li></ul><h2 id="正则VS通配符"><a href="#正则VS通配符" class="headerlink" title="正则VS通配符"></a>正则<code>VS</code>通配符</h2><div class="table-container"><table><thead><tr><th style="text-align:center">分类</th><th style="text-align:center">用途</th><th style="text-align:center">支持的命令</th></tr></thead><tbody><tr><td style="text-align:center">正则(<code>re</code>)</td><td style="text-align:center">三剑客,高级语言;被用作过滤(匹配字符)</td><td style="text-align:center">三剑客<code>grep,sed,awk,find,rename,expr</code></td></tr><tr><td style="text-align:center">通配符(<code>pathname extension</code> 或则<code>glob</code>)</td><td style="text-align:center">匹配文件名(<code>*.txt, *.log</code>)</td><td style="text-align:center"><code>Linux</code>中大部分命令</td></tr></tbody></table></div><h2 id="基础正则"><a href="#基础正则" class="headerlink" title="基础正则"></a>基础正则</h2><p><strong>素材</strong><br><code>grep_help.txt</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">grep  searches for PATTERNS in each FILE.  PATTERNS is one or more patterns </span><br><span class="line">separated by newline characters, and grep prints each line that matches a pattern.</span><br><span class="line">Typically PATTERNS should be quoted when grep is used in a shell command.</span><br><span class="line"></span><br><span class="line">A FILE of “-” stands for standard input.  If no FILE is given, recursive searches </span><br><span class="line">examine the working  directory,  and  nonrecursive  searches  read  standard</span><br><span class="line">input.</span><br><span class="line"></span><br><span class="line">In  addition, the variant programs egrep, fgrep and rgrep are the same as grep -E, </span><br><span class="line">grep -F, and grep -r, respectively.  These variants are deprecated, but are</span><br><span class="line">provided for backward compatibility.</span><br></pre></td></tr></table></figure></p><ul><li><code>^xxx</code>-以<code>xxx</code>开头的行<br>搜索以<code>In</code>开头的行<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts grep <span class="string">&quot;^In&quot;</span> ./grep_help.txt </span><br></pre></td></tr></table></figure><img src="/images/shell/^xxx.png" alt="结果"></li></ul><ul><li><p><code>xxx$</code>-以<code>xxx</code>结尾的行<br>搜索以<code>.</code>结尾的行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts grep <span class="string">&#x27;\.$&#x27;</span> ./grep_help.txt</span><br></pre></td></tr></table></figure><p><img src="/images/shell/xxx$.png" alt="结果"></p></li><li><p><code>^$</code>-<strong>空行</strong><br><strong>空行</strong>表示没有任何字符(空格也没有)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts grep -n <span class="string">&#x27;^$&#x27;</span> ./grep_help.txt</span><br></pre></td></tr></table></figure><p><strong>用法</strong>:排除空行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">grep -v <span class="string">&#x27;^$&#x27;</span> ./grep_help.txt</span><br><span class="line">grep  searches <span class="keyword">for</span> PATTERNS <span class="keyword">in</span> each FILE.  PATTERNS is one or more patterns </span><br><span class="line">separated by newline characters, and grep prints each line that matches a pattern.</span><br><span class="line">Typically PATTERNS should be quoted when grep is used <span class="keyword">in</span> a shell <span class="built_in">command</span>.</span><br><span class="line">A FILE of “-” stands <span class="keyword">for</span> standard input.  If no FILE is given, recursive searches </span><br><span class="line">examine the working  directory,  and  nonrecursive  searches  <span class="built_in">read</span>  standard</span><br><span class="line">input.</span><br><span class="line">In  addition, the variant programs egrep, fgrep and rgrep are the same as grep -E, </span><br><span class="line">grep -F, and grep -r, respectively.  These variants are deprecated, but are</span><br><span class="line">provided <span class="keyword">for</span> backward compatibility.</span><br></pre></td></tr></table></figure></li><li><p><code>.</code>-<strong>任意一个字符</strong><br><strong>但是会忽略空行</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts grep <span class="string">&#x27;. &#x27;</span> ./grep_help.txt</span><br></pre></td></tr></table></figure><p><img src="/images/shell/any.png" alt="结果"></p></li><li><p><code>x*</code>-<code>0</code>次及<code>0</code>次以上出现<code>x</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts grep <span class="string">&#x27;T*&#x27;</span> ./grep_help.txt</span><br></pre></td></tr></table></figure><p><img src="/images/shell/xany.png" alt="结果"></p></li><li><p><code>.*</code>-<strong>所有</strong><br><strong>运用</strong>:匹配以指定字符结束的行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts grep <span class="string">&#x27;^.*P&#x27;</span> ./grep_help.txt</span><br></pre></td></tr></table></figure><p><img src="/images/shell/compose.png" alt="结果"></p><blockquote><p>到最后一个指定字符, 则体现了正则表达式的<strong>贪婪行</strong></p></blockquote></li><li><p><code>[abc]</code>-一次匹配一个字符(<code>a,b,c</code>中任意一个)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts grep <span class="string">&#x27;[a-z]&#x27;</span> ./grep_help.txt</span><br></pre></td></tr></table></figure><p><img src="/images/shell/az.png" alt="结果"></p><ul><li><p>匹配大小写与数字</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts grep <span class="string">&#x27;[a-zA-Z0-9]&#x27;</span> ./grep_help.txt</span><br><span class="line">➜  Scripts grep <span class="string">&#x27;[a-Z0-9]&#x27;</span> ./grep_help.txt </span><br></pre></td></tr></table></figure><p><img src="/images/shell/aZ09.png" alt="结果"></p></li><li><p><code>[]</code>中添加其它的符号<br>除了匹配<code>a-Z 0-9</code>以外,还要匹配<code>,</code>和<code>.</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts grep <span class="string">&#x27;[a-Z,.0-9]&#x27;</span> ./grep_help.txt</span><br></pre></td></tr></table></figure><p><img src="/images/shell/fromaZ.png" alt="结果"></p></li></ul></li><li><p><code>[^xxx]</code>-匹配除<code>xxx</code>以外的内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts grep <span class="string">&#x27;[^a-z]&#x27;</span> ./grep_help.txt</span><br></pre></td></tr></table></figure><p><img src="/images/shell/other.png" alt="结果"></p></li></ul><h2 id="扩展正则"><a href="#扩展正则" class="headerlink" title="扩展正则"></a>扩展正则</h2><ul><li><p><code>+</code>-匹配<code>1</code>或则<code>1</code>个以上的字符,并输出匹配到的行<br>要使用扩展正则命令,需要以以下三种方式书写</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&#x27;m\+&#x27;</span> ./grep_help.txt</span><br><span class="line">grep -E <span class="string">&#x27;m+&#x27;</span> ./grep_help.txt</span><br><span class="line">egrep <span class="string">&#x27;m+&#x27;</span> ./grep_help.txt</span><br></pre></td></tr></table></figure><p><img src="/images/shell/+ERE.png" alt="结果"></p><ul><li>匹配文件中连续的数字<br>素材<code>ascii.txt</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">000   0     00    NUL &#x27;\0&#x27; (null character)   100   64    40    @</span><br><span class="line">001   1     01    SOH (start of heading)      101   65    41    A</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">egrep -o <span class="string">&#x27;[0-9]+&#x27;</span> ./ascii.txt</span><br><span class="line">egrep <span class="string">&#x27;[0-9]+&#x27;</span> ./ascii.txt</span><br></pre></td></tr></table></figure><img src="/images/shell/+RER_0.png" alt="结果"><blockquote><p><code>-o</code>表示输出过程,可获得匹配到的对象,而不是整行</p></blockquote></li></ul></li><li><p><code>|</code>-或者</p></li></ul><p>匹配单词或则数值<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">egrep <span class="string">&#x27;[0-9]+|[a-Z]+&#x27;</span> ./ascii.txt</span><br></pre></td></tr></table></figure><br><img src="/images/shell/or_ERE.png" alt="结果"></p><div class="table-container"><table><thead><tr><th style="text-align:center">符号</th><th style="text-align:center">区别</th><th style="text-align:center">运用场景</th></tr></thead><tbody><tr><td style="text-align:center"><code>[]</code></td><td style="text-align:center"><code>1</code>一次匹配一个字符<code>[abc]</code></td><td style="text-align:center">匹配单个字符</td></tr><tr><td style="text-align:center">&#124;</td><td style="text-align:center">a &#124; b &#124; c &#124; string</td><td style="text-align:center">匹配单词</td></tr></tbody></table></div><ul><li><p><code>()</code>-括号</p><blockquote><p>1.被括号括起来的内容是一个整体<br>2.反向引用-<code>sed</code></p></blockquote><ul><li>匹配<code>tooth或者teeth</code><br>素材<code>bracket.txt</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if a law or an organization has teeth, it has the power to force people to obey it.</span><br><span class="line">We fought tooth and nail to get these plans accepted.</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">egrep <span class="string">&#x27;t(oo|ee)th&#x27;</span> ./bracket.txt</span><br></pre></td></tr></table></figure><img src="/images/shell/bracket_0.png" alt="结果"></li></ul></li></ul><ul><li><code>&#123;&#125;</code>-连续出现<br>使用格式为,其中$k$表示出现的次数</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">格式</th><th style="text-align:center">说明</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center"><code>x&#123;n,m&#125;</code></td><td style="text-align:center">表示前一个字母<code>x</code>至少连续出现<code>n</code>次,之多出现<code>m</code>次</td><td style="text-align:center">$ n \le k \le m$</td></tr><tr><td style="text-align:center"><code>x&#123;n&#125;</code></td><td style="text-align:center">表示前一个字母<code>x</code>恰好连续出现<code>n</code>次</td><td style="text-align:center">$ k = n $</td></tr><tr><td style="text-align:center"><code>x&#123;,m&#125;</code></td><td style="text-align:center">表示前一个字母<code>x</code>恰好连续出现<code>n</code>次</td><td style="text-align:center">$ k \le m $</td></tr><tr><td style="text-align:center"><code>x&#123;n,&#125;</code></td><td style="text-align:center">表示前一个字母<code>x</code>恰好连续出现<code>n</code>次</td><td style="text-align:center">$ k \ge n$</td></tr></tbody></table></div><ul><li><p><code>?</code>-前一个字符出现<code>0</code>次或者<code>1</code>次</p><blockquote><p>匹配符合要求的行</p></blockquote><ul><li><p>匹配单复数<br><code>question_mark.txt</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Peel the oranges and divide them into segments.</span><br><span class="line">a bright shade of orange</span><br></pre></td></tr></table></figure><p><img src="/images/shell/question_mark.png" alt="结果"></p></li></ul></li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="粗略地匹配身份证"><a href="#粗略地匹配身份证" class="headerlink" title="粗略地匹配身份证"></a>粗略地匹配身份证</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">赵 211324198705244720</span><br><span class="line">钱 500224197105168312</span><br><span class="line">孙 1233211234569sunSS</span><br><span class="line">李 liliangcheng</span><br><span class="line">周 zhou21132693130593</span><br><span class="line">吴 14052219961008852X</span><br><span class="line">郑 431009199606233566</span><br><span class="line">王 47001320060315X365</span><br></pre></td></tr></table></figure><p><img src="/images/shell/id.png" alt="结果"></p><h3 id="排除空行和包含-的行"><a href="#排除空行和包含-的行" class="headerlink" title="排除空行和包含^的行"></a>排除空行和包含<code>^</code>的行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">egrep -v <span class="string">&#x27;^$|#&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="三剑客"><a href="#三剑客" class="headerlink" title="三剑客"></a>三剑客</h1><div class="table-container"><table><thead><tr><th>命令</th><th>特点</th><th>场景</th></tr></thead><tbody><tr><td><code>grep</code></td><td>过滤</td><td><code>grep</code>命令过滤速度最快</td></tr><tr><td><code>sed</code></td><td>替换,修改文件内容,取行</td><td>如果要进行替换/修改文件内容,取出某个范围的内容(从早上10:00到11:00)</td></tr><tr><td><code>awk</code></td><td>取列,统计计算</td><td>取列,对比/比较(<code>&gt;=, &lt;=,!=</code>),统计,计算(<code>awk数组</code>)</td></tr></tbody></table></div><h2 id="三剑客-grep"><a href="#三剑客-grep" class="headerlink" title="三剑客-grep"></a>三剑客-grep</h2><p><code>Global Regular Expression Print</code></p><div class="table-container"><table><thead><tr><th style="text-align:center">选项</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center"><code>-E</code></td><td style="text-align:center">等同于<code>egrep</code></td></tr><tr><td style="text-align:center"><code>-A</code></td><td style="text-align:center"><code>-A5</code>匹配的内容往后<code>5</code>行(<code>after</code>)</td></tr><tr><td style="text-align:center"><code>-B</code></td><td style="text-align:center"><code>-B5</code>匹配的内容之前<code>5</code>行(<code>before</code>)</td></tr><tr><td style="text-align:center"><code>-C</code></td><td style="text-align:center"><code>-C5</code>匹配的内容前后共<code>5</code>行(<code>context</code>)</td></tr><tr><td style="text-align:center"><code>-c</code>小写</td><td style="text-align:center">统计出现了多少行,等同于<code>wc -l</code></td></tr><tr><td style="text-align:center"><code>-v</code>小写</td><td style="text-align:center">取反(排除行)</td></tr><tr><td style="text-align:center"><code>-n</code>小写</td><td style="text-align:center">显示行号</td></tr><tr><td style="text-align:center"><code>-i</code>小写</td><td style="text-align:center">忽略大小写</td></tr><tr><td style="text-align:center"><code>-w</code>小写</td><td style="text-align:center">精确匹配</td></tr></tbody></table></div><ul><li><p><code>-C</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts seq 10 | grep -C1 5</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td></tr></table></figure></li><li><p><code>-c</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts ps -ef | grep sshd | wc -l</span><br><span class="line">8</span><br><span class="line">➜  Scripts ps -ef | grep -c sshd     </span><br><span class="line">8</span><br></pre></td></tr></table></figure></li><li><p><code>-v</code></p><blockquote><p>过滤<code>grep</code>本身这个进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts ps -ef | grep hexo         </span><br><span class="line">tangshp     6109    5504  1 20:42 pts/0    00:01:56 hexo</span><br><span class="line">tangshp     8281    6205  0 22:24 pts/1    00:00:00 grep --color=auto hexo</span><br><span class="line">➜  Scripts ps -ef | grep hexo | grep -v auto</span><br><span class="line">tangshp     6109    5504  1 20:42 pts/0    00:01:56 hexo</span><br></pre></td></tr></table></figure></blockquote></li><li><p><code>w</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts <span class="built_in">echo</span> hello helloworld | grep -w hello</span><br><span class="line">hello helloworld</span><br></pre></td></tr></table></figure><p><img src="/images/shell/grepw.png" alt="结果"></p><blockquote><p><code>\b</code>表示边界</p></blockquote></li></ul><h2 id="三剑客-sed"><a href="#三剑客-sed" class="headerlink" title="三剑客-sed"></a>三剑客-sed</h2><p><code>stream editor</code>流编辑器</p><h3 id="sed格式"><a href="#sed格式" class="headerlink" title="sed格式"></a><code>sed</code>格式</h3><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">选项</th><th style="text-align:center">sed命令功能</th><th style="text-align:center">参数/文件</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>sed</code></td><td style="text-align:center"><code>-r</code></td><td style="text-align:center"><code>s#orange#apple#g</code></td><td style="text-align:center"><code>question_mark.txt</code></td><td style="text-align:center"><code>s</code>替换,<code>g</code>修饰符</td></tr></tbody></table></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts sed -r <span class="string">&#x27;s#orange#apple#g&#x27;</span> ./question_mark.txt </span><br><span class="line">Peel the apples and divide them into segments.</span><br><span class="line">a bright shade of apple%     </span><br></pre></td></tr></table></figure><blockquote><p>把<code>orange</code>替换为<code>apple</code></p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">功能</th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center"><code>s</code></td><td style="text-align:center">替换<code>substitute</code></td></tr><tr><td style="text-align:center"><code>p</code></td><td style="text-align:center">显示<code>print</code></td></tr><tr><td style="text-align:center"><code>d</code></td><td style="text-align:center">删除<code>delete</code></td></tr><tr><td style="text-align:center"><code>cai</code></td><td style="text-align:center">增加<code>c/a/i</code></td></tr></tbody></table></div><h3 id="sed查找"><a href="#sed查找" class="headerlink" title="sed查找"></a><code>sed</code>查找</h3><ul><li><p>流程<br><img src="/images/sed_process.png" alt="结果"></p></li><li><p><code>sed</code>查找格式</p></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">查找格式</th><th style="text-align:center">说明</th><th style="text-align:center">示例</th></tr></thead><tbody><tr><td style="text-align:center"><code>xp</code></td><td style="text-align:center">查找第<code>x</code>行</td><td style="text-align:center"><code>demo0</code></td></tr><tr><td style="text-align:center"><code>m,np</code></td><td style="text-align:center">查找第<code>n</code>行到第<code>m</code>行</td><td style="text-align:center"><code>demo1</code></td></tr><tr><td style="text-align:center"><code>/regular/p</code></td><td style="text-align:center">查找符合<code>regular</code>的行,<code>//</code>里面可以写正则表达式</td><td style="text-align:center"><code>demo2</code></td></tr><tr><td style="text-align:center"><code>/10:00/,/11:00/p</code></td><td style="text-align:center">表示范围过滤</td><td style="text-align:center"><code>demo3</code></td></tr></tbody></table></div><p><code>sed_test.txt</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">10:00 赵 211324198705244720</span><br><span class="line">10:10 钱 500224197105168312</span><br><span class="line">10:20 孙 1233211234569sunSS</span><br><span class="line">10:30 李 liliangcheng</span><br><span class="line">10:40 周 zhou21132693130593</span><br><span class="line">10:50 吴 14052219961008852X</span><br><span class="line">10:60 郑 431009199606233566</span><br><span class="line">10:70 王 47001320060315X365</span><br></pre></td></tr></table></figure></p><ul><li><strong>查找示例</strong></li></ul><ul><li><p><code>demo0</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts sed -n <span class="string">&#x27;3p&#x27;</span> ./sed_test.txt </span><br><span class="line">10:20 孙 1233211234569sunSS</span><br></pre></td></tr></table></figure></li><li><p><code>demo1</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts sed -n <span class="string">&#x27;2,4p&#x27;</span> ./sed_test.txt</span><br><span class="line">10:10 钱 500224197105168312</span><br><span class="line">10:20 孙 1233211234569sunSS</span><br><span class="line">10:30 李 liliangcheng</span><br><span class="line">➜  Scripts sed -n <span class="string">&#x27;7,$p&#x27;</span> ./sed_test.txt             </span><br><span class="line">10:60 郑 431009199606233566</span><br><span class="line">10:70 王 47001320060315X365</span><br></pre></td></tr></table></figure></li><li><p><code>demo2</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts sed -nr <span class="string">&#x27;/[0-9]&#123;17&#125;[0-9X]/p&#x27;</span> ./sed_test.txt</span><br><span class="line">10:00 赵 211324198705244720</span><br><span class="line">10:10 钱 500224197105168312</span><br><span class="line">10:50 吴 14052219961008852X</span><br><span class="line">10:60 郑 431009199606233566</span><br></pre></td></tr></table></figure><blockquote><p><code>-r</code>表示使用扩展正则表达式</p></blockquote></li><li><p><code>demo3</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts sed -n <span class="string">&#x27;/10:30/,/10:50/p&#x27;</span> ./sed_test.txt </span><br><span class="line">10:30 李 liliangcheng</span><br><span class="line">10:40 周 zhou21132693130593</span><br><span class="line">10:50 吴 14052219961008852X</span><br></pre></td></tr></table></figure></li></ul><h3 id="删除-delete"><a href="#删除-delete" class="headerlink" title="删除-delete"></a>删除-<code>delete</code></h3><ul><li>删除格式</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">查找格式</th><th style="text-align:center">说明</th><th style="text-align:center">示例</th></tr></thead><tbody><tr><td style="text-align:center"><code>xd</code></td><td style="text-align:center">删除第<code>x</code>行</td><td style="text-align:center"><code>demo0</code></td></tr><tr><td style="text-align:center"><code>m,nd</code></td><td style="text-align:center">删除第<code>n</code>行到第<code>m</code>行</td><td style="text-align:center"><code>demo1</code></td></tr><tr><td style="text-align:center"><code>/regular/d</code></td><td style="text-align:center">查找符合<code>regular</code>的行,<code>//</code>里面可以写正则表达式</td><td style="text-align:center"><code>demo2</code></td></tr><tr><td style="text-align:center"><code>/10:00/,/11:00/d</code></td><td style="text-align:center">表示范围过滤</td><td style="text-align:center"><code>demo3</code></td></tr></tbody></table></div><ul><li><p><strong>删除示例</strong></p><ul><li><p>删除第<code>x</code>行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts sed <span class="string">&#x27;1d&#x27;</span> ./sed_test.txt              </span><br><span class="line">10:10 钱 500224197105168312</span><br><span class="line">10:20 孙 1233211234569sunSS</span><br><span class="line">10:30 李 liliangcheng</span><br><span class="line">10:40 周 zhou21132693130593</span><br><span class="line">10:50 吴 14052219961008852X</span><br><span class="line">10:60 郑 431009199606233566</span><br><span class="line">10:70 王 47001320060315X365%</span><br></pre></td></tr></table></figure></li><li><p>删除第<code>n</code>行到第<code>m</code>行  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts sed <span class="string">&#x27;5,8d&#x27;</span> ./sed_test.txt</span><br><span class="line">10:00 赵 211324198705244720</span><br><span class="line">10:10 钱 500224197105168312</span><br><span class="line">10:20 孙 1233211234569sunSS</span><br><span class="line">10:30 李 liliangcheng</span><br></pre></td></tr></table></figure></li><li><p>查找符合<code>regular</code>的行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts sed -r <span class="string">&#x27;/[0-9]&#123;17&#125;[0-9xX]/d&#x27;</span> ./sed_test.txt</span><br><span class="line">10:20 孙 1233211234569sunSS</span><br><span class="line">10:30 李 liliangcheng</span><br><span class="line">10:40 周 zhou21132693130593</span><br><span class="line">10:70 王 47001320060315X365% </span><br></pre></td></tr></table></figure></li><li><p>表示范围过滤</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts sed -r <span class="string">&#x27;/10:20/,/10:50/d&#x27;</span> ./sed_test.txt</span><br><span class="line">10:00 赵 211324198705244720</span><br><span class="line">10:10 钱 500224197105168312</span><br><span class="line">10:60 郑 431009199606233566</span><br><span class="line">10:70 王 47001320060315X365%</span><br></pre></td></tr></table></figure></li><li><p>删除空行或则带<code>#</code>号的行<br><strong>方法一</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts sed -r <span class="string">&#x27;/^$|#/d&#x27;</span> /etc/ssh/sshd_config</span><br><span class="line">Include /etc/ssh/sshd_config.d/*.conf</span><br><span class="line">ChallengeResponseAuthentication no</span><br><span class="line">UsePAM yes</span><br><span class="line">X11Forwarding yes</span><br><span class="line">PrintMotd no</span><br><span class="line">AcceptEnv LANG LC_*</span><br><span class="line">Subsystem       sftp    /usr/lib/openssh/sftp-server</span><br></pre></td></tr></table></figure><p><strong>方法二</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts egrep -v <span class="string">&#x27;^$|#&#x27;</span> /etc/ssh/sshd_config</span><br><span class="line">Include /etc/ssh/sshd_config.d/*.conf</span><br><span class="line">ChallengeResponseAuthentication no</span><br><span class="line">UsePAM yes</span><br><span class="line">X11Forwarding yes</span><br><span class="line">PrintMotd no</span><br><span class="line">AcceptEnv LANG LC_*</span><br><span class="line">Subsystem       sftp    /usr/lib/openssh/sftp-server</span><br></pre></td></tr></table></figure><p><code>!</code><strong>的妙用</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts sed -rn <span class="string">&#x27;/^$|#/!p&#x27;</span> /etc/ssh/sshd_config</span><br><span class="line">Include /etc/ssh/sshd_config.d/*.conf</span><br><span class="line">ChallengeResponseAuthentication no</span><br><span class="line">UsePAM yes</span><br><span class="line">X11Forwarding yes</span><br><span class="line">PrintMotd no</span><br><span class="line">AcceptEnv LANG LC_*</span><br><span class="line">Subsystem       sftp    /usr/lib/openssh/sftp-server</span><br></pre></td></tr></table></figure><blockquote><p><code>-r</code>表示扩展,<code>-n</code>表示符合的才打印,<code>!</code>表示取反;</p></blockquote></li></ul></li></ul><h3 id="sed-增加cai"><a href="#sed-增加cai" class="headerlink" title="sed-增加cai"></a>sed-增加<code>cai</code></h3><div class="table-container"><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>c</code></td><td style="text-align:center"><code>replace</code>替代</td></tr><tr><td style="text-align:center"><code>a</code></td><td style="text-align:center"><code>append</code>追加</td></tr><tr><td style="text-align:center"><code>i</code></td><td style="text-align:center"><code>insert</code>插入</td></tr></tbody></table></div><blockquote><p><code>cai</code>同样可以使用以下表格的格式, 但是要把<code>d</code>改为<code>cai</code></p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">查找格式</th><th style="text-align:center">说明</th><th style="text-align:center">示例</th></tr></thead><tbody><tr><td style="text-align:center"><code>xd</code></td><td style="text-align:center">删除第<code>x</code>行</td><td style="text-align:center"><code>demo0</code></td></tr><tr><td style="text-align:center"><code>m,nd</code></td><td style="text-align:center">删除第<code>n</code>行到第<code>m</code>行</td><td style="text-align:center"><code>demo1</code></td></tr><tr><td style="text-align:center"><code>/regular/d</code></td><td style="text-align:center">查找符合<code>regular</code>的行,<code>//</code>里面可以写正则表达式</td><td style="text-align:center"><code>demo2</code></td></tr><tr><td style="text-align:center"><code>/10:00/,/11:00/d</code></td><td style="text-align:center">表示范围过滤</td><td style="text-align:center"><code>demo3</code></td></tr></tbody></table></div><ul><li><p>示例</p><ul><li><p><code>append</code>追加,在第二行后添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts sed <span class="string">&#x27;2a 10:15 谭 63269199308363956x&#x27;</span> ./sed_test.txt</span><br><span class="line">10:00 赵 211324198705244720</span><br><span class="line">10:10 钱 500224197105168312</span><br><span class="line">10:15 谭 63269199308363956x</span><br><span class="line">10:20 孙 1233211234569sunSS</span><br><span class="line">10:30 李 liliangcheng</span><br><span class="line">10:40 周 zhou21132693130593</span><br><span class="line">10:50 吴 14052219961008852X</span><br><span class="line">10:60 郑 431009199606233566</span><br><span class="line">10:70 王 47001320060315X365% </span><br></pre></td></tr></table></figure><blockquote><p><code>2a</code>后面的空格可有可无</p></blockquote></li><li><p><code>insert</code>插入,在第二行前添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts sed <span class="string">&#x27;2i 10:15 谭 63269199308363956x&#x27;</span> ./sed_test.txt</span><br><span class="line">10:00 赵 211324198705244720</span><br><span class="line">10:15 谭 63269199308363956x</span><br><span class="line">10:10 钱 500224197105168312</span><br><span class="line">10:20 孙 1233211234569sunSS</span><br><span class="line">10:30 李 liliangcheng</span><br><span class="line">10:40 周 zhou21132693130593</span><br><span class="line">10:50 吴 14052219961008852X</span><br><span class="line">10:60 郑 431009199606233566</span><br><span class="line">10:70 王 47001320060315X365%</span><br></pre></td></tr></table></figure></li><li><p><code>replace</code>替代,把第二行替换为指定内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts sed <span class="string">&#x27;2c 10:15 谭 63269199308363956x&#x27;</span> ./sed_test.txt</span><br><span class="line">10:00 赵 211324198705244720</span><br><span class="line">10:15 谭 63269199308363956x</span><br><span class="line">10:20 孙 1233211234569sunSS</span><br><span class="line">10:30 李 liliangcheng</span><br><span class="line">10:40 周 zhou21132693130593</span><br><span class="line">10:50 吴 14052219961008852X</span><br><span class="line">10:60 郑 431009199606233566</span><br><span class="line">10:70 王 47001320060315X365% </span><br></pre></td></tr></table></figure></li><li><p>运用-在文件结尾添加<br><strong>方法</strong>-<code>cat</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts cat &gt;&gt;ascii.txt&lt;&lt;<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">heredoc&gt; </span><br><span class="line">heredoc&gt; ABCDEFGHIJKLMNOPKRSTUVWXYZ</span><br><span class="line">heredoc&gt; EOF </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">000   0     00    NUL &#x27;\0&#x27; (null character)   100   64    40    @</span><br><span class="line">001   1     01    SOH (start of heading)      101   65    41    A</span><br><span class="line">ABCDEFGHIJKLMNOPQRSNUVWXYZEOF</span><br></pre></td></tr></table></figure><p><strong>方法</strong>-<code>sed</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts sed <span class="string">&#x27;$a ABCDEFGHIJKLMNOPKRSTUVWXYZ\nabcdefghijklmnopqrstuvwxyz&#x27;</span> ./ascii.txt</span><br><span class="line">000   0     00    NUL <span class="string">&#x27;\0&#x27;</span> (null character)   100   64    40    @</span><br><span class="line">001   1     01    SOH (start of heading)      101   65    41    A</span><br><span class="line">ABCDEFGHIJKLMNOPKRSTUVWXYZ</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="sed-替换s"><a href="#sed-替换s" class="headerlink" title="sed-替换s"></a>sed-替换s</h3><ul><li><p>demo1</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts sed <span class="string">&#x27;s# ##g&#x27;</span> ./ascii.txt                                                   </span><br><span class="line">000000NUL<span class="string">&#x27;\0&#x27;</span>(nullcharacter)1006440@</span><br><span class="line">001101SOH(startofheading)1016541A% </span><br></pre></td></tr></table></figure><blockquote><p>把<code>空格替换为空</code>,第一个<code>#</code>和第二个<code>#</code>之间用于查找,第二个<code>#</code>和第三个<code>#</code>之间用于替换<br>‘-g’表示全局替换, 否则默认替换每行第一个匹配的对象</p></blockquote></li><li><p>demo2</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts sed <span class="string">&#x27;s#00#XX#g&#x27;</span> ./ascii.txt</span><br><span class="line">XX0   0     XX    NUL <span class="string">&#x27;\0&#x27;</span> (null character)   1XX   64    40    @</span><br><span class="line">XX1   1     01    SOH (start of heading)      101   65    41    A%</span><br></pre></td></tr></table></figure></li><li><p>后向引用</p><ul><li><p>把<code>123456</code>变成<code>&lt;123456&gt;</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts <span class="built_in">echo</span> 123456 | sed -r <span class="string">&#x27;s#(.*)#&lt;\1&gt;#g&#x27;</span></span><br><span class="line">&lt;123456&gt;</span><br></pre></td></tr></table></figure><blockquote><p><code>()</code>表示把括号内的内容保护起来</p></blockquote></li><li><p>把<code>123456</code>变成<code>12&lt;34&gt;56</code><br>把<code>34</code>替换为<code>&lt;34&gt;</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts <span class="built_in">echo</span> 123456 | sed -r <span class="string">&#x27;s#(34)#&lt;\1&gt;#g&#x27;</span></span><br><span class="line">12&lt;34&gt;56</span><br></pre></td></tr></table></figure><blockquote><p><code>-r</code>表示使用扩展正则</p></blockquote></li><li><p>把表情<code>@_^</code>变成<code>^_@</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts <span class="built_in">echo</span> @_^ | sed -r <span class="string">&quot;s#(^.*)_(.*$)#\2_\1#g&quot;</span></span><br><span class="line">^_@</span><br></pre></td></tr></table></figure><blockquote><p><code>\1</code>和<code>\2</code>分别表示第一个括号和第二个括号</p></blockquote></li><li><p>获取<code>ip</code>地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts ip a s eth0   </span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000</span><br><span class="line">link/ether dc:a6:32:f1:16:3e brd ff:fe:fe:af:ff:ff</span><br><span class="line">inet 122.138.3.43/24 brd 152.148.4.255 scope global dynamic noprefixroute eth0</span><br><span class="line">   valid_lft 84618sec preferred_lft 84618sec</span><br><span class="line">inet6 2408:8352:440:30b1:d734:3ba9:b69f:465c/64 scope global dynamic noprefixroute </span><br><span class="line">   valid_lft 189380sec preferred_lft 102980sec</span><br><span class="line">inet6 fe80::cbc3:d989:ae00:fc7c/64 scope link noprefixroute </span><br><span class="line">   valid_lft forever preferred_lft forever</span><br><span class="line"></span><br><span class="line">➜  Scripts ip a s eth0 | sed -n <span class="string">&#x27;3p&#x27;</span> | sed -r <span class="string">&#x27;s#(^.*inet )(.*)(/24 .*)#\2#&#x27;</span></span><br><span class="line">122.138.3.43</span><br><span class="line"><span class="comment"># 精简</span></span><br><span class="line">➜  Scripts ip a s eth0 | sed -rn <span class="string">&#x27;3s#(^.*inet )(.*)(/24 .*)#\2#gp&#x27;</span></span><br><span class="line">122.138.3.43</span><br></pre></td></tr></table></figure><p><img src="/images/shell/regular_jet.png" alt="结果"></p><p><a href="https://jex.im/regulex/">jex.im/regulex</a></p></li><li><p>获取文件权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts <span class="built_in">stat</span> /etc/hosts                                                     </span><br><span class="line">  File: /etc/hosts</span><br><span class="line">  Size: 230             Blocks: 8          IO Block: 4096   regular file</span><br><span class="line">Device: b302h/45826d    Inode: 475         Links: 1</span><br><span class="line">Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2020-10-29 10:04:22.858250738 +0800</span><br><span class="line">Modify: 2020-04-02 01:26:24.731999903 +0800</span><br><span class="line">Change: 2020-04-02 01:26:24.731999903 +0800</span><br><span class="line"> Birth: -</span><br><span class="line"></span><br><span class="line">➜  Scripts <span class="built_in">stat</span> /etc/hosts | sed -n <span class="string">&#x27;4p&#x27;</span> | sed -r <span class="string">&#x27;s#^.*\(0(.*)/-r.*$#\1#g&#x27;</span></span><br><span class="line">644</span><br><span class="line"></span><br><span class="line">➜  Scripts <span class="built_in">stat</span> /etc/hosts | sed -n <span class="string">&#x27;4p&#x27;</span> | sed -r <span class="string">&#x27;s#^.*\(0(.*)\)  Uid.*$#\1#g&#x27;</span> </span><br><span class="line">644/-rw-r--r--</span><br><span class="line"></span><br><span class="line">➜  Scripts <span class="built_in">stat</span> -c%a /etc/hosts </span><br><span class="line">644</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="三剑客-awk"><a href="#三剑客-awk" class="headerlink" title="三剑客-awk"></a>三剑客-awk</h2><p><code>awk</code>是一门语言, 类似于<code>c</code>语言,一般用于过滤、统计、计算、过滤/统计日志,<code>man awk</code>可知<br><code>Gawk  is  the GNU Project&#39;s implementation of the AWK programming language.  It conforms to the definition of the language in the POSIX 1003.1 standard.  Thisversion in turn is based on the description in The AWK Programming Language, by Aho, Kernighan, and Weinberger.  Gawk provides the additional  features  foundin the current version of Brian Kernighan&#39;s awk and numerous GNU-specific extensions.</code></p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><ul><li>格式<br><code>条件&#123;动作&#125;</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts awk  <span class="string">&#x27;BEGIN&#123;print &quot;begin of awk&quot;&#125;NR&gt;=2&amp;&amp;NR&lt;=4&#123;print $1&#125;END&#123;print &quot;end of file&quot;&#125;&#x27;</span> ./id.txt</span><br><span class="line">begin of awk</span><br><span class="line">钱</span><br><span class="line">孙</span><br><span class="line">李</span><br><span class="line">end of file</span><br></pre></td></tr></table></figure><blockquote><p>1、<code>BEGIN&#123;&#125;</code> 是<strong>预处理</strong><br>2、<code>END&#123;&#125;</code>   是<strong>后处理</strong><br>3、<code>NR&gt;=2&amp;&amp;NR&lt;=4&#123;print $1&#125;</code> <strong>条件{动作}</strong>, 表示取出[2,4]行中第1列数据<br>4、<code>$0</code>表示整行</p></blockquote><h3 id="行和列"><a href="#行和列" class="headerlink" title="行和列"></a>行和列</h3><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center"><code>awk</code>中的名称</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">行</td><td style="text-align:center">记录-<code>record</code></td><td style="text-align:center">每一行默认通过回车分割</td></tr><tr><td style="text-align:center">列</td><td style="text-align:center">字段,域-<code>field</code></td><td style="text-align:center">每一列默认通过空格分割</td></tr></tbody></table></div><ul><li><strong>取行</strong></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">取行</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>NR==1</code></td><td style="text-align:center">取出第1行</td></tr><tr><td style="text-align:center"><code>NR&gt;=1&amp;&amp;NR&lt;=5</code></td><td style="text-align:center">取出第1-5行</td></tr><tr><td style="text-align:center"><code>/regular/</code></td><td style="text-align:center">正则</td></tr><tr><td style="text-align:center"><code>/start_row/,/end_row/</code></td><td style="text-align:center">对应的行区间</td></tr><tr><td style="text-align:center"><code>&lt;,&gt;,&lt;=,&gt;=,==,!=</code></td><td style="text-align:center">逻辑判断</td></tr></tbody></table></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts awk <span class="string">&#x27;NR==1&#x27;</span> ./sed_test.txt                                                               </span><br><span class="line">10:00 赵 211324198705244720</span><br><span class="line"></span><br><span class="line">➜  Scripts awk <span class="string">&#x27;NR&gt;=1 &amp;&amp; NR&lt;=4&#x27;</span> ./sed_test.txt</span><br><span class="line">10:00 赵 211324198705244720</span><br><span class="line">10:10 钱 500224197105168312</span><br><span class="line">10:20 孙 1233211234569sunSS</span><br><span class="line">10:30 李 liliangcheng</span><br><span class="line"></span><br><span class="line">➜  Scripts awk <span class="string">&#x27;/li/&#x27;</span> ./sed_test.txt</span><br><span class="line">10:30 李 liliangcheng</span><br><span class="line"></span><br><span class="line">➜  Scripts awk <span class="string">&#x27;/10:20/,/10:40/&#x27;</span> ./sed_test.txt</span><br><span class="line">10:20 孙 1233211234569sunSS</span><br><span class="line">10:30 李 liliangcheng</span><br><span class="line">10:40 周 zhou21132693130593</span><br></pre></td></tr></table></figure><ul><li><p><strong>取列</strong><br>通过<code>-F</code>指定分隔符,指定每一列的结束符标记(默认是空格,连续的空格,<code>tab</code>键), <code>$x</code>表示第<code>x</code>列; </p><ul><li><p>取出<code>ls -lh</code>的结果中的第<code>[1,end)</code>行第5,9列的内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts ls -lh | awk <span class="string">&#x27;NR&gt;1&#123;print $5,$9&#125;&#x27;</span> | column -t</span><br><span class="line">40   0-debug.sh</span><br><span class="line">131  ascii.txt</span><br><span class="line">137  bracket.txt</span><br><span class="line">56   echo_a.txt</span><br><span class="line">603  grep_help.txt</span><br><span class="line">10   id_card_list.txt</span><br><span class="line">177  id.txt</span><br><span class="line">78   p.py</span><br><span class="line">72   question_mark.txt</span><br><span class="line">225  sed_test.txt</span><br></pre></td></tr></table></figure><blockquote><p><code>column -t</code>用作对齐,参考<a href="/2021/08/15/Linux-命令/">column -t</a></p></blockquote></li><li><p>取出<code>ls -lh</code>的结果中的第<code>[1,end)</code>行第1,最后一列的内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts ls -lh | awk <span class="string">&#x27;NR&gt;1&#123;print $1,$NF&#125;&#x27;</span>            </span><br><span class="line">-rw-rw-r-- 0-debug.sh</span><br><span class="line">-rw-rw-r-- ascii.txt</span><br><span class="line">-rw-rw-r-- bracket.txt</span><br><span class="line">-rw-rw-r-- echo_a.txt</span><br><span class="line">-rw-rw-r-- grep_help.txt</span><br><span class="line">-rw-rw-r-- id_card_list.txt</span><br><span class="line">-rw-rw-r-- id.txt</span><br><span class="line">-rw-rw-r-- p.py</span><br><span class="line">-rw-rw-r-- question_mark.txt</span><br><span class="line">-rw-rw-r-- sed_test.txt</span><br></pre></td></tr></table></figure></li><li><p>指定分隔符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts head -5 /etc/passwd                                   </span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</span><br><span class="line">bin:x:2:2:bin:/bin:/usr/sbin/nologin</span><br><span class="line">sys:x:3:3:sys:/dev:/usr/sbin/nologin</span><br><span class="line">sync:x:4:65534:sync:/bin:/bin/sync</span><br><span class="line"></span><br><span class="line">➜  Scripts head -5 /etc/passwd | awk -F: <span class="string">&#x27;&#123;print $1,$NF&#125;&#x27;</span> | column -t  </span><br><span class="line">root    /bin/bash</span><br><span class="line">daemon  /usr/sbin/nologin</span><br><span class="line">bin     /usr/sbin/nologin</span><br><span class="line">sys     /usr/sbin/nologin</span><br><span class="line">sync    /bin/sync</span><br></pre></td></tr></table></figure><blockquote><p><code>-F</code>支持扩展正则, 且默认支持扩展正则表达式</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts ip a s eth0 | awk <span class="string">&quot;NR==3&quot;</span>                             </span><br><span class="line">    inet 192.168.5.49/24 brd 192.168.5.255 scope global dynamic noprefixroute eth0</span><br><span class="line"></span><br><span class="line">➜  Scripts ip a s eth0 | awk <span class="string">&quot;NR==3&quot;</span> | awk -F<span class="string">&quot;[ /]+&quot;</span> <span class="string">&#x27;&#123;print $3&#125;&#x27;</span></span><br><span class="line">192.168.5.49</span><br><span class="line"></span><br><span class="line">➜  Scripts ip a s eth0 | awk -F<span class="string">&quot;[ /]+&quot;</span> <span class="string">&#x27;NR==3&#123;print $3&#125;&#x27;</span></span><br><span class="line">192.168.5.49</span><br></pre></td></tr></table></figure><blockquote><p>1、第二个<code>awk</code>后的<code>print</code>必须使用<strong>单引号</strong><br>2、因为要指定分隔符为<strong>空格</strong>或则<code>/</code>,且可能需要多个空格,所以<code>-F</code>的参数要指定为<code>&quot;[ /]+&quot;</code><br>3、<code>inet</code>左边有<code>4</code>个空格, 这4个空格的左边对应<code>$1</code>, 所以<code>ip</code>地址对应着<code>$3</code></p></blockquote></li></ul></li></ul><pre><code>- 保留原分隔符输出<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts head -5 /etc/passwd | awk -F: <span class="string">&#x27;&#123;print $1,&quot;:&quot;,$NF&#125;&#x27;</span></span><br><span class="line">root : /bin/bash</span><br><span class="line">daemon : /usr/sbin/nologin</span><br><span class="line">bin : /usr/sbin/nologin</span><br><span class="line">sys : /usr/sbin/nologin</span><br><span class="line">sync : /bin/sync</span><br><span class="line"></span><br><span class="line">➜  Scripts head-5 /etc/passwd | awk -F: -v OFS=: <span class="string">&#x27;&#123;print $1,$NF&#125;&#x27;</span>            </span><br><span class="line">root:/bin/bash</span><br><span class="line">daemon:/usr/sbin/nologin</span><br><span class="line">bin:/usr/sbin/nologin</span><br><span class="line">sys:/usr/sbin/nologin</span><br><span class="line">sync:/bin/sync</span><br></pre></td></tr></table></figure></code></pre><h3 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h3><div class="table-container"><table><thead><tr><th style="text-align:center">内置变量</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>NR</code></td><td style="text-align:center"><code>Number of Record</code>记录号, 行号</td></tr><tr><td style="text-align:center"><code>NF</code></td><td style="text-align:center"><code>Number of Field</code>每行总共多少列,<code>$NF</code>表示最后一列</td></tr><tr><td style="text-align:center"><code>FS</code></td><td style="text-align:center">等同于<code>-F: === -v FS=:</code>,字段分隔符</td></tr><tr><td style="text-align:center"><code>OFS</code></td><td style="text-align:center"><code>Output Field separateor</code>输出字段分隔符</td></tr></tbody></table></div><h3 id="正则与awk"><a href="#正则与awk" class="headerlink" title="正则与awk"></a>正则与<code>awk</code></h3><ul><li><code>awk</code>使用正则时,需要使用<code>//</code></li><li><code>awk</code>可以精确到某一列是否包含<code>XXX</code><ul><li><code>~</code>表示<strong>包含</strong></li><li><code>!~</code>表示<strong>不包含</strong></li></ul></li><li>正则和<code>awk</code>正则对比</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">正则</th><th style="text-align:center"><code>awk</code>正则</th></tr></thead><tbody><tr><td style="text-align:center"><code>^xxx</code>表示以<code>xxx</code>开头的行</td><td style="text-align:center"><code>$3~/^xxx/</code>第3列以<code>xxx</code>开头</td></tr><tr><td style="text-align:center"><code>xxx$</code>表示以<code>xxx</code>结尾的行</td><td style="text-align:center"><code>$4~/xxx$/</code>第3列以<code>xxx</code>结尾</td></tr><tr><td style="text-align:center"><code>^$</code>表示空行</td><td style="text-align:center"><code>$2~/^$/</code>第2列为空</td></tr></tbody></table></div><ul><li><p>第三列以2开头的行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts hheawk -F: <span class="string">&#x27;$3~/^2/&#x27;</span> /etc/passwd</span><br><span class="line">bin:x:2:2:bin:/bin:/usr/sbin/nologin</span><br></pre></td></tr></table></figure></li><li><p>第2列为空的行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1::2</span><br><span class="line">1:2:3</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts awk -F: <span class="string">&#x27;$2~/^$/&#x27;</span> ./test.ini  </span><br><span class="line">1::2</span><br></pre></td></tr></table></figure></li><li><p>找到第3列以<code>2</code>开头的行,并打印第1列和第3列</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts awk -F: <span class="string">&#x27;NR==3&#123;print $0&#125;&#x27;</span> /etc/passwd</span><br><span class="line">bin:x:2:2:bin:/bin:/usr/sbin/nologin</span><br><span class="line">➜  Scripts awk -F: <span class="string">&#x27;$3~/^2/&#123;print $1 $3&#125;&#x27;</span> /etc/passwd</span><br><span class="line">bin2</span><br></pre></td></tr></table></figure></li><li><p>找到第3列以<code>2</code>或则<code>3</code>开头的行,并打印第1列和第3列</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts awk -F: <span class="string">&#x27;$3~/^[23]/&#123;print $0&#125;&#x27;</span> /etc/passwd</span><br><span class="line">bin:x:2:2:bin:/bin:/usr/sbin/nologin</span><br><span class="line">sys:x:3:3:sys:/dev:/usr/sbin/nologin</span><br><span class="line">www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin</span><br><span class="line">backup:x:34:34:backup:/var/backups:/usr/sbin/nologin</span><br><span class="line">list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin</span><br><span class="line">irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin</span><br><span class="line">➜  Scripts awk -F: <span class="string">&#x27;$3~/^[23]/&#123;print $1 $3&#125;&#x27;</span> /etc/passwd</span><br><span class="line">bin2</span><br><span class="line">sys3</span><br><span class="line">www-data33</span><br><span class="line">backup34</span><br><span class="line">list38</span><br><span class="line">irc39</span><br></pre></td></tr></table></figure></li></ul><h3 id="awk范围"><a href="#awk范围" class="headerlink" title="awk范围"></a><code>awk</code>范围</h3><ul><li>找到指定时间范围内的内容, 并精确定位指定列<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts awk <span class="string">&#x27;/10:30/,/10:60/&#123;print $2&#125;&#x27;</span> ./sed_test.txt</span><br><span class="line">李</span><br><span class="line">周</span><br><span class="line">吴</span><br><span class="line">郑</span><br></pre></td></tr></table></figure></li></ul><h3 id="BEGIN和END"><a href="#BEGIN和END" class="headerlink" title="BEGIN和END"></a><code>BEGIN</code>和<code>END</code></h3><ul><li><code>BEGIN</code>和<code>END</code>的运用场景</li></ul><div class="table-container"><table><thead><tr><th>模式</th><th>说明</th><th>运用场景</th></tr></thead><tbody><tr><td><code>BEGIN&#123;&#125;</code></td><td>里面的内容会在<code>awk</code>读取文件之前执行</td><td>进行简单统计,计算,通常不涉及读取文件;用来处理文件前,添加表头;用来定位<code>awk</code>变量(很少用,因为可以使用<code>-v</code>);</td></tr><tr><td><code>END&#123;&#125;</code></td><td>里面的内容会在<code>awk</code>读取文件之后执行</td><td><code>awk</code>进行统计,一般过程：先进行计算,最后<code>END</code>里面输出结果；<code>awk</code>使用数组,在<code>END</code>中输出结果</td></tr></tbody></table></div><ul><li><code>END&#123;&#125;</code>统计计算</li></ul><div class="table-container"><table><thead><tr><th>统计方法</th><th>说明</th></tr></thead><tbody><tr><td><code>i++</code></td><td>计数</td></tr><tr><td><code>sum = sum + x</code></td><td>累加</td></tr></tbody></table></div><blockquote><p><code>i</code>和<code>sum</code>都是变量</p></blockquote><ul><li><p><strong>示例</strong></p><ul><li><p><strong>统计空行的数量</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts awk <span class="string">&#x27;/^$/&#x27;</span> /etc/services </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">➜  Scripts awk <span class="string">&#x27;/^$/&#123;i++&#125;END&#123;print i&#125;&#x27;</span> /etc/services</span><br><span class="line">6</span><br></pre></td></tr></table></figure></li><li><p><strong>求和</strong><br><code>test.csv</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1,2,3,4,5</span><br><span class="line">2,3,4,5,6</span><br><span class="line">3,4,5,6,7</span><br><span class="line">4,5,6,7,8</span><br><span class="line">5,6,7,8,9</span><br><span class="line">6,7,8,9,10</span><br><span class="line">7,8,9,10,11</span><br><span class="line">8,9,10,11,12</span><br><span class="line">9,10,11,12,13</span><br><span class="line">10,11,12,13,14</span><br><span class="line">11,12,13,14,15</span><br><span class="line">12,13,14,15,16</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts awk -F, <span class="string">&#x27;&#123;sum = sum + $2&#125;END&#123;print sum&#125;&#x27;</span> ./test.csv</span><br><span class="line">90</span><br><span class="line">➜  Scripts awk -F, <span class="string">&#x27;&#123;sum = sum + $2;print sum&#125;END&#123;print sum&#125;&#x27;</span> ./test.csv </span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">9</span><br><span class="line">14</span><br><span class="line">20</span><br><span class="line">27</span><br><span class="line">35</span><br><span class="line">44</span><br><span class="line">54</span><br><span class="line">65</span><br><span class="line">77</span><br><span class="line">90</span><br><span class="line">90</span><br></pre></td></tr></table></figure><blockquote><p>在<code>$2</code>后面添加<code>输出</code>,即可显示过程</p></blockquote></li></ul></li></ul><h3 id="awk数组"><a href="#awk数组" class="headerlink" title="awk数组"></a><code>awk</code>数组</h3><p><code>awk</code>数组被用于统计日志, 统计<code>ip</code>出现次数,统计状态码出现次数,统计系统中每个用户被攻击的次数;累加统计每个<code>ip</code>消耗的流量</p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th><strong>shell</strong>数组</th><th><strong>awk</strong>数组</th></tr></thead><tbody><tr><td style="text-align:center">形式</td><td><code>array[0]=value</code></td><td><code>array[0]=value</code></td></tr><tr><td style="text-align:center">使用</td><td><code>echo $&#123;array[0]&#125;</code></td><td><code>print array[0]</code></td></tr><tr><td style="text-align:center">批量输出数组的内容</td><td><code>for i in $&#123;array[*]&#125;</code><br><code>do</code><br><code>----echo $i</code><br><code>done</code></td><td><code>for(i in array)</code><br><code>----print i</code></td></tr></tbody></table></div><blockquote><p>其中<code>i</code>是索引</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts awk <span class="string">&#x27;BEGIN&#123;arr[0]=&quot;str1&quot;;arr[1]=&quot;str2&quot;; for(i in arr) print i&#125;&#x27;</span> </span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">➜  Scripts awk <span class="string">&#x27;BEGIN&#123;arr[0]=&quot;str1&quot;;arr[1]=&quot;str2&quot;; for(i in arr) print arr[i]&#125;&#x27;</span></span><br><span class="line">str1</span><br><span class="line">str2</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts awk <span class="string">&#x27;BEGIN&#123;arr[0]=str1;arr[1]=str2;print arr[0],arr[1]&#125;&#x27;</span>    </span><br><span class="line"> </span><br></pre></td></tr></table></figure><blockquote><p>字符串<code>str1</code>和<code>str2</code>都被认为是<strong>变量</strong>, 导致打印是都是<strong>空</strong>,如果使用字符串,参考如下:</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts awk <span class="string">&#x27;BEGIN&#123;arr[0]=&quot;str1&quot;;arr[1]=&quot;str2&quot;;print arr[0],arr[1]&#125;&#x27;</span></span><br><span class="line">str1 str2</span><br></pre></td></tr></table></figure><h3 id="awk数组经典案例"><a href="#awk数组经典案例" class="headerlink" title="awk数组经典案例"></a><code>awk</code><strong>数组经典案例</strong></h3><p>从以下网址中获取<strong>域名</strong>并<strong>统计访问次数</strong></p><ul><li><strong>素材</strong><code>url.txt</code><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/</span><br><span class="line">http://www.open3d.org/docs/release/index.html</span><br><span class="line">https://leetcode-cn.com/</span><br><span class="line">https://github.com/</span><br><span class="line">https://realpython.com/beginners-guide-python-turtle</span><br><span class="line">https://python3-cookbook.readthedocs.io/zh_CN/latest/</span><br><span class="line">https://github.com/</span><br><span class="line">https://leetcode-cn.com/</span><br></pre></td></tr></table></figure></li><li><p><strong>解答</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts awk -F/ <span class="string">&#x27;&#123;array[$3]++&#125;END&#123;for(i in array)print i,array[i]&#125;&#x27;</span> ./url.txt | column -t</span><br><span class="line">python3-cookbook.readthedocs.io  1</span><br><span class="line">github.com                       3</span><br><span class="line">realpython.com                   1</span><br><span class="line">www.open3d.org                   1</span><br><span class="line">leetcode-cn.com                  2</span><br></pre></td></tr></table></figure><blockquote><p>该案例中索引不是<strong>整数</strong>,而是<strong>字符串</strong>,类似于<code>key-value</code>; 其中<code>i</code>对应<code>key</code>,即为域名, <code>array[i]</code>对应<code>value</code>,即为<strong>访问次数</strong></p></blockquote></li><li><p><strong>输出结果排序</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts awk -F/ <span class="string">&#x27;&#123;array[$3]++&#125;END&#123;for(i in array)print i,array[i]&#125;&#x27;</span> ./url.txt | column -t | sort -rnk2</span><br><span class="line">github.com                       3</span><br><span class="line">leetcode-cn.com                  2</span><br><span class="line">www.open3d.org                   1</span><br><span class="line">realpython.com                   1</span><br><span class="line">python3-cookbook.readthedocs.io  1</span><br></pre></td></tr></table></figure><blockquote><p><code>sort</code>用于排序; 参考<a href="/2021/08/15/Linux-命令/">sort参数说明</a></p></blockquote></li></ul><h3 id="awk循环与判断"><a href="#awk循环与判断" class="headerlink" title="awk循环与判断"></a><code>awk</code><strong>循环与判断</strong></h3><ul><li><code>awk</code><strong>循环</strong></li></ul><div class="table-container"><table><thead><tr><th><code>shell for</code>循环</th><th><code>awk for</code>循环</th></tr></thead><tbody><tr><td><code>for(i=1;i&lt;=10;i++)</code><br><code>do</code><br><code>----echo $i</code><br><code>done</code></td><td><code>for(i=1;i&lt;=10;i++)</code><br><code>&#123;</code><br><code>----print i</code><br><code>&#125;</code></td></tr></tbody></table></div><ul><li><p><code>awk</code><strong>求和</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts awk <span class="string">&#x27;BEGIN&#123;for(i=1;i&lt;=10;i++)sum+=i;print sum&#125;&#x27;</span></span><br><span class="line">55</span><br></pre></td></tr></table></figure></li><li><p><code>if</code><strong>条件</strong></p></li></ul><div class="table-container"><table><thead><tr><th></th><th><code>shell if</code>判断</th><th><code>awk if</code>判断</th></tr></thead><tbody><tr><td>单分支</td><td><code>if[ &quot;arg&quot; -eq &quot;push&quot; ]</code><br><code>----echo &quot;PUSH&quot;</code><br><code>fi</code></td><td><code>if(conditon)</code><br><code>----print &quot;PUSH&quot;</code></td></tr><tr><td>双分支</td><td><code>if[ &quot;arg&quot; -eq &quot;push&quot; ]</code><br><code>----echo &quot;PUSH&quot;</code><br><code>else</code><br><code>----echo &quot;POP&quot;</code><br><code>fi</code></td><td><code>if(conditon)</code><br><code>----print &quot;PUSH&quot;</code><br><code>else</code><br><code>----print &quot;POP&quot;</code></td></tr></tbody></table></div><ul><li><p>当磁盘<strong>使用率</strong>小于<code>50%</code>时,打印<code>disk is enough</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts df -h                                                                         </span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">udev            3.7G     0  3.7G   0% /dev</span><br><span class="line">tmpfs           776M  7.7M  769M   1% /run</span><br><span class="line">/dev/mmcblk0p2  118G   23G   95G  20% /</span><br><span class="line">tmpfs           3.8G     0  3.8G   0% /dev/shm</span><br><span class="line">tmpfs           5.0M     0  5.0M   0% /run/lock</span><br><span class="line">tmpfs           3.8G     0  3.8G   0% /sys/fs/cgroup</span><br><span class="line">/dev/loop0       49M   49M     0 100% /snap/core18/2127</span><br><span class="line">/dev/loop1       49M   49M     0 100% /snap/core18/2248</span><br><span class="line">/dev/loop2       29M   29M     0 100% /snap/snapd/13643</span><br><span class="line">/dev/loop5      128K  128K     0 100% /snap/ubuntu-mate-pi/11</span><br><span class="line">/dev/loop3      128K  128K     0 100% /snap/software-boutique/56</span><br><span class="line">/dev/loop6       16M   16M     0 100% /snap/ubuntu-mate-welcome/641</span><br><span class="line">/dev/loop4       29M   29M     0 100% /snap/snapd/13171</span><br><span class="line">/dev/loop7       16M   16M     0 100% /snap/ubuntu-mate-welcome/648</span><br><span class="line">/dev/mmcblk0p1  255M  119M  137M  47% /boot/firmware</span><br><span class="line">tmpfs           776M  4.0K  776M   1% /run/user/1000</span><br><span class="line"></span><br><span class="line">➜  Scripts df -h | awk -F<span class="string">&quot;[ %]+&quot;</span> <span class="string">&#x27;NR&gt;=2&#123;if($5&lt;50)print $6,&quot;disk enough[&quot;,$5,&quot;%]&quot;&#125;&#x27;</span> | column -t</span><br><span class="line">/dev            disk  enough[  0   %]</span><br><span class="line">/run            disk  enough[  1   %]</span><br><span class="line">/               disk  enough[  20  %]</span><br><span class="line">/dev/shm        disk  enough[  0   %]</span><br><span class="line">/run/lock       disk  enough[  0   %]</span><br><span class="line">/sys/fs/cgroup  disk  enough[  0   %]</span><br><span class="line">/boot/firmware  disk  enough[  47  %]</span><br><span class="line">/run/user/1000  disk  enough[  1   %]</span><br></pre></td></tr></table></figure></li><li><p>统计语句中单词长度小于<code>6</code>的单词,并显示该单词</p><ul><li><strong>素材</strong><code>Avatar.txt</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If you wish to survive you need to cultivate a strong mental attitude.</span><br></pre></td></tr></table></figure></li><li><strong>答案</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts awk -F<span class="string">&quot;[ .,]&quot;</span> <span class="string">&#x27;&#123;for(i=1;i&lt;NF;i++)if(length($i)&lt;6)print $i&#125;&#x27;</span> ./Avatar.txt</span><br><span class="line">If</span><br><span class="line">you</span><br><span class="line">wish</span><br><span class="line">to</span><br><span class="line">you</span><br><span class="line">need</span><br><span class="line">to</span><br><span class="line">a</span><br><span class="line">12345</span><br></pre></td></tr></table></figure><blockquote><p><code>length($i)</code>用于求取字符长度;<code>length()</code>用于表示整行字符长度</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts <span class="built_in">echo</span> 12345 67890 | awk <span class="string">&#x27;&#123;print length()&#125;&#x27;</span></span><br><span class="line">11</span><br></pre></td></tr></table></figure></blockquote></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux的基本使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-内核学习-08</title>
      <link href="/2021/10/31/Linux-%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0-08/"/>
      <url>/2021/10/31/Linux-%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0-08/</url>
      
        <content type="html"><![CDATA[<h1 id="运用程序"><a href="#运用程序" class="headerlink" title="运用程序"></a>运用程序</h1><p>运用层通过调用<code>mmap</code>函数,<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">          <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure></p><h1 id="mmap参数"><a href="#mmap参数" class="headerlink" title="mmap参数"></a>mmap参数</h1><h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><p><code>CPU</code>在读写操作时，无法区分<strong>内存</strong>还是<strong>寄存器</strong>; 如果<code>CPU</code>采用<strong>时间局部性</strong>和<strong>空间局部性</strong>的策略, 间接采用<code>Cache</code>来访问<strong>内存</strong>的话, 写入<strong>Cache</strong>的数据不会马上写入<strong>内存或则寄存器</strong>,需要<strong>若干时间后</strong>,才会<strong>写入到寄存器</strong>;所以以下情况下,应考虑<strong>不使用</strong><code>Cache</code>;对于一般的<code>RAM</code>/变量可以使用<code>Cache</code>。</p><ul><li>内存(<code>RAM</code>)、<code>Register</code></li><li><strong>显存</strong>(<code>Framebuffer</code>-显卡会往显存上读数据,然后显示在屏幕上)</li><li><code>DMA</code>(通过<code>DMA</code>的形式读取<strong>某块区域</strong>的数据时,<code>CPU</code>不能通过<code>Cache</code>的方式往<strong>该区域</strong>写数据)</li></ul><p><img src="/images/CacheSystem.png" alt="Cache,处理器内核与主存的关系"></p><h3 id="写缓冲器"><a href="#写缓冲器" class="headerlink" title="写缓冲器"></a>写缓冲器</h3><p>使用<code>Cache</code>的工作方式有两种:</p><ul><li><strong>写通</strong>(<code>write through</code>): <code>Cache</code>拿到处理器<strong>新构造的数据</strong>后, <strong>同时</strong>写到<strong>主存</strong>中, <strong>处理器内核</strong>与<strong>主存</strong>是通的;<ul><li>使用<code>Cache</code><strong>读数据时很高效</strong>, 但是<strong>写数据</strong>的<strong>写通方式低效</strong></li></ul></li><li><strong>写回</strong>(<code>write back</code>): <strong>处理器内核</strong>把数据写入<code>Cache</code>后, 不着急把数据写到<strong>内存</strong>, 只是把相应的<strong>行标记为脏</strong>,等<code>Cache</code><strong>写满后</strong>,一块把数据<strong>写入到主存</strong>中。<ul><li>写数据时, 高效, 但<code>Cache</code>和主存的<strong>数据可能不一致</strong></li></ul></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">是否启用cache</th><th style="text-align:center">是否启用buffer</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:left"><code>Non-cached, non-buffered (NCNB)</code>读、写都直达外设硬件</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:left"><code>Non-cached buffered (NCB)</code>读、写都直达外设硬件; 写操作通过<code>buffer</code>实现, <code>CPU</code>不等待写操作完成,<code>CPU</code>会马上执行下一条指令</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:left"><code>Cached, write-through mode (WT)</code>, 写通读; <code>cache hit</code>时从<code>cahce</code>读数据; <code>cache miss</code>时已入一行数据到<code>cache</code>; 写: 通过<code>buffer</code>实现, <code>CPU</code>不等待写操作完成，<code>CPU</code>会马上执行下一条指令</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:left"><code>Cached, write-back mode (WB)</code>, 写回读; <code>cache hit</code>时从cahce读数据; <code>cache miss</code>时已入一行数据到<code>cache</code>; 写: 通过<code>buffer</code>实现, <code>cache hit</code>时新数据不会到达硬件, 而是在<code>cahce</code>中被标为<strong>脏</strong>; <code>cache miss</code>时, 通过<code>buffer</code>写入硬件, <code>CPU</code>不等待写操作完成, <code>CPU</code>会马上执行下一条指令</td></tr></tbody></table></div><ul><li>第1种是不使用<code>cache</code>也不使用<code>buffer</code>, 读写时都直达硬件, 这适合<strong>寄存器</strong>的读写。</li><li>第2种是不使用<code>cache</code>但是使用<code>buffer</code>, 写数据时会用<code>buffer</code>进行优化, 可能会有<strong>写合并</strong>, 这适合<strong>显存</strong>的操作。因为对显存很少有读操作, 基本都是写操作, 而写操作即使被<strong>合并</strong>也没有关系。</li><li>第3种是使用<code>cache</code>不使用<code>buffer</code>, 就是<code>write through</code>, 适用于只读设备, 在读数据时用<code>cache</code>加速, 基本不需要写。</li><li>第4种是既使用<code>cache</code>又使用<code>buffer</code>, 适合一般的内存读写。</li></ul><h2 id="MAP-PRIVATE"><a href="#MAP-PRIVATE" class="headerlink" title="MAP_PRIVATE"></a><code>MAP_PRIVATE</code></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">➜  07_mmap sudo ./mmap_test&amp;</span><br><span class="line">[1] 5846</span><br><span class="line">address of buf: 0xffffaf00d000</span><br><span class="line">compare err!</span><br><span class="line">buf is wiki.100ask.net</span><br><span class="line">str is</span><br><span class="line">➜  07_mmap ps -ef | grep mmap_test</span><br><span class="line">root        5846    3281  0 16:22 pts/0    00:00:00 sudo ./mmap_test</span><br><span class="line">root        5848    5846  0 16:22 pts/0    00:00:00 ./mmap_test</span><br><span class="line">tangshp     5859    3281  0 16:23 pts/0    00:00:00 grep --color=auto mmap_test</span><br><span class="line">➜  07_mmap ps</span><br><span class="line">    PID TTY          TIME CMD</span><br><span class="line">   3281 pts/0    00:00:11 zsh</span><br><span class="line">   5865 pts/0    00:00:00 ps</span><br><span class="line">➜  07_mmap sudo cat /proc/5848/maps</span><br><span class="line">aaaad3a55000-aaaad3a56000 r-xp 00000000 b3:02 1703529                    /home/tangshp/Code_ws/Linux_ws/<span class="built_in">source</span>/07_mmap/mmap_test</span><br><span class="line">aaaad3a66000-aaaad3a67000 r--p 00001000 b3:02 1703529                    /home/tangshp/Code_ws/Linux_ws/<span class="built_in">source</span>/07_mmap/mmap_test</span><br><span class="line">aaaad3a67000-aaaad3a68000 rw-p 00002000 b3:02 1703529                    /home/tangshp/Code_ws/Linux_ws/<span class="built_in">source</span>/07_mmap/mmap_test</span><br><span class="line">aaab10948000-aaab10969000 rw-p 00000000 00:00 0                          [heap]</span><br><span class="line">ffffaee5b000-ffffaefb5000 r-xp 00000000 b3:02 132332                     /usr/lib/aarch64-linux-gnu/libc-2.31.so</span><br><span class="line">ffffaefb5000-ffffaefc5000 ---p 0015a000 b3:02 132332                     /usr/lib/aarch64-linux-gnu/libc-2.31.so</span><br><span class="line">ffffaefc5000-ffffaefc8000 r--p 0015a000 b3:02 132332                     /usr/lib/aarch64-linux-gnu/libc-2.31.so</span><br><span class="line">ffffaefc8000-ffffaefcb000 rw-p 0015d000 b3:02 132332                     /usr/lib/aarch64-linux-gnu/libc-2.31.so</span><br><span class="line">ffffaefcb000-ffffaefce000 rw-p 00000000 00:00 0</span><br><span class="line">ffffaefe2000-ffffaf003000 r-xp 00000000 b3:02 132328                     /usr/lib/aarch64-linux-gnu/ld-2.31.so</span><br><span class="line">ffffaf00d000-ffffaf00f000 rw-p 1f3d44000 00:06 1927                      /dev/hello</span><br><span class="line">ffffaf00f000-ffffaf011000 rw-p 00000000 00:00 0</span><br><span class="line">ffffaf011000-ffffaf012000 r--p 00000000 00:00 0                          [vvar]</span><br><span class="line">ffffaf012000-ffffaf013000 r-xp 00000000 00:00 0                          [vdso]</span><br><span class="line">ffffaf013000-ffffaf014000 r--p 00021000 b3:02 132328                     /usr/lib/aarch64-linux-gnu/ld-2.31.so</span><br><span class="line">ffffaf014000-ffffaf016000 rw-p 00022000 b3:02 132328                     /usr/lib/aarch64-linux-gnu/ld-2.31.so</span><br><span class="line">ffffd91c5000-ffffd91e6000 rw-p 00000000 00:00 0                          [stack]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux内核 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C, 驱动开发, Linux内核 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统-01</title>
      <link href="/2021/10/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-01/"/>
      <url>/2021/10/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-01/</url>
      
        <content type="html"><![CDATA[<h1 id="ELF二进制文件"><a href="#ELF二进制文件" class="headerlink" title="ELF二进制文件"></a>ELF二进制文件</h1><ul><li><code>C</code>语言编译流程<br><img src="/images/build_link.png" alt="C语言编译流程"><ul><li>asdf</li></ul></li><li><p><code>elf</code>文件<br>使用<code>file</code>查看<strong>文件类型</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜  P2 file a.out               </span><br><span class="line">a.out: ELF 64-bit LSB shared object, ARM aarch64, version 1 (SYSV), dynamically linked, </span><br><span class="line">        interpreter /lib/ld-linux-aarch64.so.1, BuildID[sha1]=6acaf043b3b59d957f11f4a551</span><br><span class="line">        73ebf2a9992c58, <span class="keyword">for</span> GNU/Linux 3.7.0, not stripped</span><br><span class="line">➜  P2 file a.o  </span><br><span class="line">a.o: ELF 64-bit LSB relocatable, ARM aarch64, version 1 (SYSV), not stripped</span><br><span class="line">➜  P2 file a.c</span><br><span class="line">a.c: C <span class="built_in">source</span>, ASCII text</span><br><span class="line">➜  P2 file a.txt</span><br><span class="line">a.txt: ASCII text, with no line terminators</span><br><span class="line">➜  aarch64-linux-gnu file ./libstdc++.so.6.0.28</span><br><span class="line">./libstdc++.so.6.0.28: ELF 64-bit LSB shared object, ARM aarch64, version 1 (GNU/Linux),</span><br><span class="line"> dynamically linked, BuildID[sha1]=eac118da2026b956ca08055b04e86081d446cb6a, stripped</span><br></pre></td></tr></table></figure></li><li><p>使用<code>xxd</code>打开<code>elf</code>文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  P2 xxd /bin/ls | less</span><br><span class="line">00000000: 7f45 4c46 0201 0100 0000 0000 0000 0000  .ELF............</span><br><span class="line">00000010: 0300 b700 0100 0000 4059 0000 0000 0000  ........@Y......</span><br><span class="line">00000020: 4000 0000 0000 0000 e013 0200 0000 0000  @...............</span><br><span class="line">00000030: 0000 0000 4000 3800 0900 4000 1b00 1a00  ....@.8...@.....</span><br><span class="line">00000040: 0600 0000 0400 0000 4000 0000 0000 0000  ........@.......</span><br></pre></td></tr></table></figure><blockquote><p>1、使用<code>man ascii</code>查看<code>ASCII</code>码可知; <code>45</code>对应<code>E</code>,<code>4c</code>对应<code>L</code>,<code>46</code>对应<code>F</code>,第一个字节<code>7F</code>是个固定的数<br>2、左边第一列表示地址偏移,以<code>16</code>进制表示<br>3、同样可以使用<code>hexdump -x /bin/ls | less</code>查看,但是字节顺序不同</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  P2 hexdump -x /bin/ls | less</span><br><span class="line">0000000    457f    464c    0102    0001    0000    0000    0000    0000</span><br><span class="line">0000010    0003    00b7    0001    0000    5940    0000    0000    0000</span><br><span class="line">0000020    0040    0000    0000    0000    13e0    0002    0000    0000</span><br><span class="line">0000030    0000    0000    0040    0038    0009    0040    001b    001a</span><br></pre></td></tr></table></figure></blockquote></li><li><p>使用<code>readelf</code>解析<code>elf</code>文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00</span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2<span class="string">&#x27;s complement, little endian</span></span><br><span class="line"><span class="string">  Version:                           1 (current)</span></span><br><span class="line"><span class="string">  OS/ABI:                            UNIX - System V</span></span><br><span class="line"><span class="string">  ABI Version:                       0</span></span><br><span class="line"><span class="string">  Type:                              DYN (Shared object file)</span></span><br><span class="line"><span class="string">  Machine:                           AArch64</span></span><br><span class="line"><span class="string">  Version:                           0x1</span></span><br><span class="line"><span class="string">  Entry point address:               0x610</span></span><br><span class="line"><span class="string">  Start of program headers:          64 (bytes into file)</span></span><br><span class="line"><span class="string">  Start of section headers:          7376 (bytes into file)</span></span><br><span class="line"><span class="string">  Flags:                             0x0</span></span><br><span class="line"><span class="string">  Size of this header:               64 (bytes)</span></span><br><span class="line"><span class="string">  Size of program headers:           56 (bytes)</span></span><br><span class="line"><span class="string">  Number of program headers:         9</span></span><br><span class="line"><span class="string">  Size of section headers:           64 (bytes)</span></span><br><span class="line"><span class="string">  Number of section headers:         28</span></span><br><span class="line"><span class="string">  Section header string table index: 27</span></span><br></pre></td></tr></table></figure></li></ul><div class="table-container"><table><thead><tr><th style="text-align:right">关键字</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:right"><code>ELF Header</code></td><td>指名<code>ELF</code>文件头开始</td></tr><tr><td style="text-align:right"><code>Magic</code></td><td>用来指名该文件是一个<code>ELF</code>目标文件。第一个字节<code>7F</code>是个固定的数；后面的<code>3</code>个字节正是<code>E, L, F</code>三个字母的<code>ASCII</code>形式。</td></tr><tr><td style="text-align:right"><code>CLASS</code></td><td>表示文件类型，这里是<code>64</code>位的<code>ELF</code>格式</td></tr><tr><td style="text-align:right"><code>Data</code></td><td>表示文件中的数据是按照什么格式组织的(大端或小端)，不同处理器平台数据组织格式可能就不同，如x86平台为小端存储格式</td></tr><tr><td style="text-align:right"><code>Version</code></td><td><code>ELF</code>文件头版本号，这里版本号为<code>1</code></td></tr><tr><td style="text-align:right"><code>OS/ABI</code></td><td>指出操作系统类型，<code>ABI</code>是<code>Application Binary Interface</code>的缩写</td></tr><tr><td style="text-align:right"><code>ABI Version</code></td><td><code>ABI</code>版本号，当前为<code>0</code></td></tr><tr><td style="text-align:right"><code>Type</code></td><td>文件类型。<code>ELF</code>文件有<code>3</code>种类型，一种是如上所示的<code>Executable</code>可执行文件， 一种是可重定位目标文件<code>(Relocatable file)</code>，另外一种是共享库<code>(Shared Library)</code></td></tr><tr><td style="text-align:right"><code>Machine</code></td><td>机器平台类型, <code>arm 64</code></td></tr><tr><td style="text-align:right"><code>Version</code></td><td>当前目标文件的版本号</td></tr><tr><td style="text-align:right"><code>Entry point address</code></td><td>程序的虚拟地址入口点，这里是<code>0x610</code></td></tr><tr><td style="text-align:right"><code>Start of program headers</code></td><td>程序头开始处，这里是<code>64</code>个字节,表示偏移量</td></tr><tr><td style="text-align:right"><code>Start of section headers</code></td><td><code>section</code>头开始处，这里<code>7376</code>是十进制,表示偏移量</td></tr><tr><td style="text-align:right"><code>Flags</code></td><td>一个与处理器相关联的标志</td></tr><tr><td style="text-align:right"><code>Size of this header</code></td><td><code>ELF</code>文件头的字节数，这里为<code>64</code></td></tr><tr><td style="text-align:right"><code>Size of program headers</code></td><td>程序头字节数，这里为<code>56</code></td></tr><tr><td style="text-align:right"><code>Number of program headers</code></td><td>程序头数量，这里为<code>9</code>个</td></tr><tr><td style="text-align:right"><code>Size of section headers</code></td><td><code>sections header</code>的大小，这里每个<code>section</code>头大小为<code>64</code>个字节</td></tr><tr><td style="text-align:right"><code>Number of section headers</code></td><td>一共有多少个<code>section</code>头，这里是<code>28</code>个</td></tr><tr><td style="text-align:right"><code>Section header string table index</code></td><td><code>section</code>头字符串表索引号，从<code>Section Headers</code>输出部分可以看到其内容的偏移在<code>64</code>个字节处，从此处开始到<code>0x50</code>结束保存着各个<code>sections</code>的名字，如<code>.data，.text，.bss</code>等。</td></tr></tbody></table></div><ul><li><code>Section</code><br>由上表可知<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">➜  P2 readelf -SW ./a.out | less</span><br><span class="line">There are 28 section headers, starting at offset 0x1cd0:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  [ 0]                   NULL            0000000000000000 000000 000000 00      0   0  0</span><br><span class="line">  [ 1] .interp           PROGBITS        0000000000000238 000238 00001b 00   A  0   0  1</span><br><span class="line"> ...</span><br><span class="line">  [13] .text             PROGBITS        0000000000000610 000610 00019c 00  AX  0   0  8</span><br><span class="line"> ...</span><br><span class="line">  [20] .dynamic          DYNAMIC         0000000000010d98 000d98 0001f0 10  WA  6   0  8</span><br><span class="line">  [21] .got              PROGBITS        0000000000010f88 000f88 000078 08  WA  0   0  8</span><br><span class="line">  [22] .data             PROGBITS        0000000000011000 001000 000010 00  WA  0   0  8</span><br><span class="line">  [23] .bss              NOBITS          0000000000011010 001010 000008 00  WA  0   0  1</span><br><span class="line">  [24] .comment          PROGBITS        0000000000000000 001010 00002a 01  MS  0   0  1</span><br><span class="line">  [25] .symtab           SYMTAB          0000000000000000 001040 000888 18     26  68  8</span><br><span class="line">  [26] .strtab           STRTAB          0000000000000000 0018c8 000308 00      0   0  1</span><br><span class="line">  [27] .shstrtab         STRTAB          0000000000000000 001bd0 0000fa 00      0   0  1</span><br></pre></td></tr></table></figure>上表<code>Section Headers</code>中的各字段,由头文件<code>/usr/include/elf.h</code>中结构体<code>Elf64_Shdr</code>定义<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Word    sh_name;        <span class="comment">/* Section name (string tbl index) */</span></span><br><span class="line">  Elf64_Word    sh_type;        <span class="comment">/* Section type */</span></span><br><span class="line">  Elf64_Xword   sh_flags;       <span class="comment">/* Section flags */</span></span><br><span class="line">  Elf64_Addr    sh_addr;        <span class="comment">/* Section virtual addr at execution */</span></span><br><span class="line">  Elf64_Off sh_offset;      <span class="comment">/* Section file offset */</span></span><br><span class="line">  Elf64_Xword   sh_size;        <span class="comment">/* Section size in bytes */</span></span><br><span class="line">  Elf64_Word    sh_link;        <span class="comment">/* Link to another section */</span></span><br><span class="line">  Elf64_Word    sh_info;        <span class="comment">/* Additional section information */</span></span><br><span class="line">  Elf64_Xword   sh_addralign;       <span class="comment">/* Section alignment */</span></span><br><span class="line">  Elf64_Xword   sh_entsize;     <span class="comment">/* Entry size if section holds table */</span></span><br><span class="line">&#125; Elf64_Shdr;</span><br></pre></td></tr></table></figure><blockquote><p>1、结构体<code>Elf64_Shdr</code>中的每个成员都是<code>64</code>位大小,即<code>8 bytes</code>, 共</p></blockquote></li></ul><h1 id="最小的hello-world"><a href="#最小的hello-world" class="headerlink" title="最小的hello world"></a><strong>最小</strong>的<code>hello world</code></h1><h2 id="失败的尝试-1"><a href="#失败的尝试-1" class="headerlink" title="失败的尝试#1"></a>失败的尝试#1</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  P2 cat ./hello.c</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> agrc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello world!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>针对以上代码进行编译<ul><li>编译 <code>gcc -c hello.c -o hello.o</code></li><li>链接<code>ld hello.o</code><br>链接时报错, 如下所示<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  P2 gcc -c ./hello.c -o hello.o</span><br><span class="line">➜  P2 ld ./hello.o</span><br><span class="line">ld: warning: cannot find entry symbol _start; defaulting to 00000000004000b0</span><br><span class="line">ld: ./hello.o: <span class="keyword">in</span> <span class="keyword">function</span> `main<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">hello.c:(.text+0x18): undefined reference to `puts&#x27;</span></span><br></pre></td></tr></table></figure><blockquote><p>1.尽管使用<code>gcc -oo</code>,<strong>编译器</strong>也会把<code>printf</code>优化为<code>puts</code>函数(该优化有一点性能提升);因为没有链接<code>libc</code>,所以找不到<code>puts</code>函数;但是链接<code>libc</code>就不是<strong>最小</strong>的<code>hello world</code>了<br>2.<code>main</code>函数不是程序在二进制意义上的入口, <code>_start</code>是连接器默认的入口; 可以使用<code>-e main</code>指定入口函数</p></blockquote></li></ul></li></ul><h2 id="失败的尝试-2"><a href="#失败的尝试-2" class="headerlink" title="失败的尝试#2"></a>失败的尝试#2</h2><p>为了不链接<code>glibc</code>, 不调用<code>printf</code>,改为如下代码:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  P2 cat ./hello.<span class="function">c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> agrc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>重新编译:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  P2 gcc -c -o0  ./hello.c -o hello.o</span><br><span class="line">➜  P2 ld -e main ./hello.o</span><br></pre></td></tr></table></figure><br>运行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  P2 ./a.out</span><br><span class="line">[1]    24658 segmentation fault (core dumped)  ./a.out</span><br></pre></td></tr></table></figure></p><blockquote><p>运行时却会报错</p></blockquote><h2 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a><code>gdb</code>调试</h2><p>使用<code>gdb</code>参考<a href="https://sourceware.org/gdb/documentation/">gdb手册</a></p><ul><li><code>starti</code>跳转到第一条指令开始执行程序</li><li><code>layout asm</code>查看汇编</li><li><code>info register</code>查看寄存器</li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C, 驱动开发, Linux内核 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法分析-02</title>
      <link href="/2021/10/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-02/"/>
      <url>/2021/10/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-02/</url>
      
        <content type="html"><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1].<a href="http://data.biancheng.net/view/8.html">双向链表(双向循环链表)的建立及C语言实现</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构,算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法分析-01</title>
      <link href="/2021/10/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-01/"/>
      <url>/2021/10/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-01/</url>
      
        <content type="html"><![CDATA[<h1 id="斐波那契数列数列"><a href="#斐波那契数列数列" class="headerlink" title="斐波那契数列数列"></a>斐波那契数列数列</h1><h2 id="指数时间复杂度计算"><a href="#指数时间复杂度计算" class="headerlink" title="指数时间复杂度计算"></a>指数时间复杂度计算</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fib</span><span class="params">(<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(N &lt;= <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> Fib(N<span class="number">-1</span>) + Fib(N<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以$T_n$表示计算<code>Fib(N)</code>所需运行时间,由此可知$T_n=2+T_{n-1}+T_{n-2},n\ge2$,其中<code>2</code>表示第<code>3</code>行的比较运算与第<code>5</code>行的加法运算;</p><script type="math/tex; mode=display">\begin{pmatrix}T_n \\T_{n+1}\end{pmatrix} = \begin{pmatrix}T_n \\T_{n}+T_{n-1} + 2\end{pmatrix} = \begin{pmatrix} 0 & 1\\1 & 1\end{pmatrix}\begin{pmatrix} T_{n-1} \\T_{n}\end{pmatrix} + \begin{pmatrix} 0 \\2\end{pmatrix}</script><p>取$\begin{pmatrix}T_n \\T_{n+1}\end{pmatrix}$为$Y_n$ ,  取$\begin{pmatrix}T_{n-1} \\T_n\end{pmatrix}$为$Y_{n-1}$ , 则$Y_0 = \begin{pmatrix}1 \\1\end{pmatrix}$ 取$\begin{pmatrix} 0 &amp; 1\\1 &amp; 1\end{pmatrix}$为$M$; 设$\begin{pmatrix} 0 \\2\end{pmatrix}$为$\beta$;  ($M=PDP^{-1}$)</p><script type="math/tex; mode=display">\begin{equation}\begin{split}Y_n &= MY_{n-1} + \beta\\\\&=M(MY_{n-2} + \beta) + \beta\\\\&=M^2Y_{n-2} + (M+E)\beta\\\\&=M^nY_0 + (M^{n-1}+M^{n-2}+...+M+E)\beta\\&=PD^nP^{-1}Y_0 + P(D^{n-1}+D^{n-2}+...+D+E)P^{-1}\beta\end{split}\end{equation}</script><p><strong>由此可求解</strong>$T_n$</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1].<a href="https://blog.csdn.net/weixin_44227356/article/details/118558257?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-3.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-3.no_search_link">斐波那契数列的时间复杂度</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构,算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake-02</title>
      <link href="/2021/10/06/CMake-02/"/>
      <url>/2021/10/06/CMake-02/</url>
      
        <content type="html"><![CDATA[<h1 id="Googletest"><a href="#Googletest" class="headerlink" title="Googletest"></a>Googletest</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/google/googletest.git -b release-1.11.0</span><br><span class="line"><span class="built_in">cd</span> googletest        <span class="comment"># Main directory of the cloned repository.</span></span><br><span class="line">mkdir build          <span class="comment"># Create a directory to hold the build output.</span></span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..             <span class="comment"># Generate native build scripts for GoogleTest.</span></span><br><span class="line">make</span><br><span class="line">sudo make install    <span class="comment"># Install in /usr/local/ by default</span></span><br></pre></td></tr></table></figure><h2 id="CMake配置"><a href="#CMake配置" class="headerlink" title="CMake配置"></a>CMake配置</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(GTest CONFIG REQUIRED)</span><br><span class="line"><span class="keyword">add_executable</span>(test_linked_list test_linked_list.cc)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(test_linked_list linked_list GTest::gtest_main)</span><br></pre></td></tr></table></figure><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;gtest/gtest.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(list, DeleteList)</span><br><span class="line">&#123;</span><br><span class="line">    List list = <span class="built_in">test</span>();</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(<span class="number">10</span>, list-&gt;Element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="target"><a href="#target" class="headerlink" title="target"></a>target</h1><h2 id="PRIVATE-INTERFACE-PUBLIC"><a href="#PRIVATE-INTERFACE-PUBLIC" class="headerlink" title="PRIVATE/INTERFACE/PUBLIC"></a>PRIVATE/INTERFACE/PUBLIC</h2><ul><li><code>cmake-test</code>项目结构如下<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">➜  cmake-test git:(master) tree</span><br><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── hello_world</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── hello</span><br><span class="line">│   │   ├── CMakeLists.txt</span><br><span class="line">│   │   ├── hello.c</span><br><span class="line">│   │   └── hello.h</span><br><span class="line">│   ├── hello_world.c</span><br><span class="line">│   ├── hello_world.h</span><br><span class="line">│   └── world</span><br><span class="line">│       ├── CMakeLists.txt</span><br><span class="line">│       ├── world.c</span><br><span class="line">│       └── world.h</span><br><span class="line">└── main.c</span><br><span class="line"></span><br><span class="line">3 directories, 11 files</span><br></pre></td></tr></table></figure></li><li><p>项目源文件如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _HELLO_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _HELLO_H_</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">date_hello</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> data[<span class="number">10</span>];</span><br><span class="line">&#125; <span class="keyword">data_hello_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">// hello.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;hello.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s::%s::%d\n&quot;</span>, __FILE__, __func__, __LINE__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// world.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _WORLD_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _WORLD_H_</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">world</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">date_world</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> data[<span class="number">10</span>];</span><br><span class="line">&#125; <span class="keyword">date_world_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">// world.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;world.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">world</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s::%s::%d\n&quot;</span>, __FILE__, __func__, __LINE__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// hello_world.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _HELLO_WORLD_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _HELLO_WORLD_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;world.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello_world</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">data_helloworld</span>&#123;</span></span><br><span class="line">    <span class="keyword">date_world_t</span> *pTworld;</span><br><span class="line">    <span class="keyword">char</span> data[<span class="number">10</span>];</span><br><span class="line">&#125; <span class="keyword">data_helloworld_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">// hello_world.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;hello.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello_world</span><span class="params">()</span></span>&#123;</span><br><span class="line">    hello();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s::%s::%d\n&quot;</span>, __FILE__, __func__, __LINE__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hello_world统计CMakeLists.txt</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(hello)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(world)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(hello_world hello_world.c)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(hello_world PRIVATE hello)</span><br><span class="line"><span class="keyword">target_include_directories</span>(hello_world PRIVATE hello)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(hello_world INTERFACE  world)</span><br><span class="line"><span class="keyword">target_include_directories</span>(hello_world INTERFACE  world)</span><br></pre></td></tr></table></figure></li><li><p>&#x1F349;<strong>不难看出</strong></p><ul><li><code>hello_world</code>依赖了<code>hello</code>,但只在<code>hello_world.c</code>中调用了<code>hello.h</code></li><li><code>hello_world</code>依赖了<code>world</code>,但只在<code>hello_world.h</code>中调用了<code>world.h</code></li></ul></li><li><p>结论</p><ul><li>如果<code>target</code><strong>仅</strong>在对应的<strong>源文件</strong>(<code>hello_world.c</code>)中调用了依赖对象(<code>hello</code>)的<strong>头文件</strong>(<code>hello.h</code>),则使用<code>PRIVATE</code></li><li>如果<code>target</code><strong>仅</strong>在对应的<strong>头文件</strong>(<code>hello_world.h</code>)中调用了依赖对象(<code>world</code>)的<strong>头文件</strong>(<code>world.h</code>),则使用<code>INTERFACE</code></li><li>而<code>PUBLIC</code>则等同于<code>PRIVATE+PUBLIC</code></li></ul></li></ul><h1 id="add-custom-command"><a href="#add-custom-command" class="headerlink" title="add_custom_command"></a>add_custom_command</h1><p>这是一个用来定义生成<strong>输出文件</strong>的命令,在本目录的<code>CMakeLists.txt</code>中的<strong>任何一个目标</strong>,如果这个<strong>目标使用的源文件</strong>是在<code>add_custom_command</code>的输出文件中的,那么<code>add_custom_command</code>将被执行。</p><h1 id="install"><a href="#install" class="headerlink" title="install"></a>install</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cpack -G ZIP Debug # 二进制的发表方式</span><br><span class="line">cpack </span><br><span class="line">cpack --config CPackSourceConfig.cmake # 源文件的发表方式</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CMake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统编程-04-Pthreads</title>
      <link href="/2021/10/02/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-04-Pthreads/"/>
      <url>/2021/10/02/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-04-Pthreads/</url>
      
        <content type="html"><![CDATA[<p><code>Pthreads</code>和<code>OpenMP</code>是为<strong>共享内存系统</strong>编程而设计的,它们提供了访问共享内存的机制;<code>MPI</code>是为<strong>分布式内存系统</strong>编程而设计的,它提供了发送消息的机制。对<strong>共享内存区域</strong>更新的代码段称为<strong>临界区域</strong>(<code>critical section</code>)。<code>POSIX</code>线程库也被称为<code>Pthreads</code>线程库,拥有一个可以链接到C程序的库,其只支持<code>POSIX</code>的系统(<code>Linux, Mac OS X, Solaris,HPUX</code>);</p><p>在<code>Pthreads</code>程序中, <strong>全局变量</strong>被所有线程所<strong>共享</strong>, 而函数中声明的<strong>局部变量则</strong>(通常)由执行该程序的线程所<strong>私有</strong>。如果多个线程都要运行同一个函数,则每个线程都拥有自己的<strong>私有局部变量</strong>和<strong>函数参数的副本</strong>。每个线程都有自己<strong>私有的栈</strong>。</p><p>使用<code>Pthreads</code>需要包含头文件<code>pthread.h</code>, 编译时需要添加链接库<code>pthread</code>。</p><p><img src="/images/memory_system.png" alt="Shared memory system"></p><h1 id="Hello-World程序"><a href="#Hello-World程序" class="headerlink" title="Hello World程序"></a>Hello World程序</h1><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> thread_count;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">foo</span><span class="params">(<span class="keyword">void</span> *rank)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> *pTthread = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> != argc)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s thread_number\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    thread_count = strtol(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread_count:%d\n\n&quot;</span>, thread_count);</span><br><span class="line">    <span class="keyword">pthread_t</span> *thread_handles = <span class="literal">NULL</span>;</span><br><span class="line">    thread_handles = (<span class="keyword">pthread_t</span> *)<span class="built_in">malloc</span>(thread_count * <span class="keyword">sizeof</span>(<span class="keyword">pthread_t</span>));</span><br><span class="line">    pTthread = (<span class="keyword">long</span> *)<span class="built_in">malloc</span>(thread_count * <span class="keyword">sizeof</span>(<span class="keyword">long</span>));</span><br><span class="line">    <span class="keyword">int</span> iRet = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; thread_count; index++)</span><br><span class="line">    &#123;</span><br><span class="line">        pTthread[index] = index;</span><br><span class="line">        iRet = pthread_create(&amp;(thread_handles[index]), <span class="literal">NULL</span>, foo, (<span class="keyword">void</span> *)(&amp;pTthread[index]));</span><br><span class="line">        <span class="comment">// printf(&quot;pthread_t:%ld\n&quot;, thread_handles[thread]);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nHello from the main thread\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; thread_count; index++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(thread_handles[index], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(thread_handles);</span><br><span class="line">    <span class="built_in">free</span>(pTthread);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">foo</span><span class="params">(<span class="keyword">void</span> *rank)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> my_rank = *((<span class="keyword">long</span> *)(rank));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello from thread %ld of %d\n&quot;</span>, my_rank, thread_count);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">===</span><br><span class="line">➜  draft_ws ./build/<span class="number">4.2</span>.mian <span class="number">4</span></span><br><span class="line">thread_count:<span class="number">4</span></span><br><span class="line"></span><br><span class="line">Hello from thread <span class="number">0</span> of <span class="number">4</span></span><br><span class="line">Hello from thread <span class="number">1</span> of <span class="number">4</span></span><br><span class="line"></span><br><span class="line">Hello from the main thread</span><br><span class="line">Hello from thread <span class="number">3</span> of <span class="number">4</span></span><br><span class="line">Hello from thread <span class="number">2</span> of <span class="number">4</span></span><br></pre></td></tr></table></figure><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -lpthread -o main</span><br></pre></td></tr></table></figure><h2 id="示例说明"><a href="#示例说明" class="headerlink" title="示例说明"></a>示例说明</h2><ul><li><code>pthread_t</code>对象其实是<code>unsigned long int</code>类型, 需要事先为该类型变量分配内存</li><li><code>pthread_create</code><br>函数<code>pthread_create</code>被用作创建新的线程,原型如下:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *thread, <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr,<span class="keyword">void</span> *(*start_routine) (<span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure>该函数会更新参数<code>thread</code>, 该参数被用作标识新创建的线程;第二个参数<code>attr</code>不用, 所以填入<code>NULL</code>即可;第三个参数<code>start_routine</code>即为新创建的线程要运行的函数,该函数的原型应该为<code>void *thread_start(void *arg)</code>;第四个参数<code>arg</code>,为执行函数<code>start_routine</code>要传递的参数;<br>新线程创建成功,则会返回<code>0</code>,同时也就运行函数<code>start_routine</code>;创建失败则返回一个错误值,具体可参考<code>man pthread-create</code>中的<code>ERRORS</code>字段。</li><li><code>pthread_join</code><br>函数<code>pthread_join</code>用作<strong>等待</strong><code>pthread_t</code>对象所关联的那个线程结束,原型如下:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">void</span> **retval)</span></span>;</span><br></pre></td></tr></table></figure>参数说明可查看<code>man pthread_join</code>。</li></ul><h1 id="矩阵-向量乘法"><a href="#矩阵-向量乘法" class="headerlink" title="矩阵-向量乘法"></a>矩阵-向量乘法</h1><p>可以把矩阵向量乘法看作分块矩阵的乘法,$y_i$的值只和行向量$A[i][:]$与列向量$x$有关;</p><script type="math/tex; mode=display">    \begin{pmatrix}    y_1 \\    y_2 \\    ...\\    y_{MAX} \\    \end{pmatrix}    =    \begin{pmatrix}    a_{11} & a_{12} & ... & a_{1*MAX} \\    a_{21} & a_{22} & ... & a_{2*MAX} \\    ...    &  ...   & ... & ...      \\    a_{MAX*1} & a_{MAX*2} & ... & a_{MAX*MAX} \\    \end{pmatrix}    *    \begin{pmatrix}    x_1 \\    x_2 \\    ...\\    x_{MAX} \\    \end{pmatrix}</script><p>把分块计算的任务平坦到<code>thread_count</code>个线程中执行, 每个线程承担<code>local_m = MAX / thread_count</code>个元素的计算;<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">Pth_mat_vect</span><span class="params">(<span class="keyword">void</span> *rank)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (thread_count &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> my_rank = *((<span class="keyword">long</span> *)rank);</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> local_m = MAX / thread_count;</span><br><span class="line">    <span class="keyword">int</span> my_first_row = my_rank * local_m;</span><br><span class="line">    <span class="keyword">int</span> my_last_row = (my_rank + <span class="number">1</span>) * local_m;</span><br><span class="line">    <span class="keyword">for</span> (i = my_first_row; i &lt; my_last_row; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; MAX; j++)</span><br><span class="line">            y[i] = A[i][j] * x[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="临界区域"><a href="#临界区域" class="headerlink" title="临界区域"></a>临界区域</h1><h2 id="临界区域的概念"><a href="#临界区域的概念" class="headerlink" title="临界区域的概念"></a>临界区域的概念</h2><p>根据幂级数展开$arctan(x)=\sum_{n=0}^\infty \frac{(-1)^nx^(2n+1)}{2n+1}$,可知$\pi = 4\sum_{n=0}^\infty \frac{(-1)^n}{2n+1}$;即</p><script type="math/tex; mode=display">\pi = 4(1-\frac{1}{3}+\frac{1}{5}-\frac{1}{7} + ... + \frac{(-1)^n}{2n+1})</script><p>用以下代码承担计算工作, 每个线程承担<code>my_n = MAX_N / thread_count</code>项计算工作;其中变量<code>sum</code>是<strong>全局变量</strong>,<code>my_sum</code>是<strong>局部变量</strong>,在多线程的场景下,多个线程<strong>尝试</strong>更新同一个<strong>全局变量</strong><code>sum</code>,那么<strong>第12行</strong>就是<strong>临界区域</strong>;<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calc_PI</span><span class="params">(<span class="keyword">void</span> *rank)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> my_rank = *(<span class="keyword">long</span> *)(rank);</span><br><span class="line">    <span class="keyword">double</span> factor = (my_rank % <span class="number">2</span>) ? <span class="number">-1.0</span> : <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> my_n = MAX_N / thread_count;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> my_first_i = my_n * my_rank;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> my_last_i = my_n * my_rank + my_n;</span><br><span class="line">    <span class="keyword">double</span> my_sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = my_first_i; i &lt; my_last_i; i++, factor *= <span class="number">-1</span>)</span><br><span class="line">        my_sum += factor / (<span class="number">1</span> + i * <span class="number">2</span>);</span><br><span class="line">    sum += my_sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上代码可以用以下代码来描述<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_sum = Compute(my_rank);</span><br><span class="line">sum = sum + my_sum;</span><br></pre></td></tr></table></figure><br>变量<code>my_sum</code>和变量<code>sum</code>都在<strong>主存</strong>中,加法的执行过程如下:</p><ul><li>把两个变量从主存中加载到<code>CPU</code>的寄存器中(<strong>取值</strong>);</li><li>进行加法运算(<strong>运算</strong>)</li><li>把结果从寄存器中重新存储到主存中(<strong>写入</strong>);</li></ul><p>如果<strong>线程1</strong>在<strong>写入</strong>主存之前,<strong>线程2</strong>已<strong>取值</strong>,则<strong>线程1</strong>的计算结果被<strong>线程2</strong>覆盖,而没有起到两个线程计算结果之和的作用。<strong>当多个线程尝试更新同一个共享资源(此处是共享的全局变量)时,结果可能是无法预测的。</strong></p><h2 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h2><p>可是设置一个<strong>标志位</strong>,以<strong>忙等待</strong>的方式来决定哪个线程<strong>有权执行临界区域的代码</strong>,参考&lt;&lt;并行程序设计导论&gt;&gt;-4.5,处于<strong>忙等待</strong>的线程仍然在持续使用<code>CPU</code>,所以<strong>忙等待</strong>不是解决<strong>限制临界区访问</strong>的最理想方法;<strong>互斥量(互斥锁)</strong>和<strong>信号量</strong>可以解决该问题;</p><p><strong>互斥量</strong>是一个特殊的变量, <code>Pthreads</code>中通过一个联合体来定义, 可以把它看作一个特殊类型的变量;通过相关的函数,<strong>互斥量可以限制每次只有一个线程能进入临界区域,保证了一个线程独享临界区域的访问权,其它线程在有线程进入该临界区域后,不能同时进入;</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">pthread_mutex_s</span> __<span class="title">data</span>;</span></span><br><span class="line">  <span class="keyword">char</span> __size[__SIZEOF_PTHREAD_MUTEX_T];</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">int</span> __align;</span><br><span class="line">&#125; <span class="keyword">pthread_mutex_t</span>;</span><br></pre></td></tr></table></figure></p><ul><li><p><strong>互斥量</strong>类型<code>pthread_mutex_t</code>必须是全局变量,使得每个线程都可以访问;</p></li><li><p><strong>互斥量</strong>使用前必须先初始化, 使用函数<code>pthread_mutex_init</code>,原型如下;第二个参数不使用,赋值为<code>NULL</code>即可;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span> <span class="params">(<span class="keyword">pthread_mutex_t</span> *__mutex,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *__mutexattr)</span></span></span><br></pre></td></tr></table></figure></li><li><p>使用完<strong>互斥量</strong>后,必须调用<strong>销毁函数</strong><code>pthread_mutex_destroy</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span> <span class="params">(<span class="keyword">pthread_mutex_t</span> *__mutex)</span></span></span><br></pre></td></tr></table></figure></li><li><p>进入临界区域前,调用函数<code>pthread_mutex_lock</code>;如当前没有线程进入<strong>临界区域</strong>,则可以进入<strong>临界区</strong>;否则阻塞于此,直到<strong>有权访问临界区的线程退出后</strong>,系统才会把访问权<strong>交付</strong>给当前阻塞于此的<strong>线程们中的一个</strong>(多个线程进入<strong>临界区</strong>的顺序是随机的);进入<strong>临界区域</strong>后,就会对临界区<strong>上锁</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span> <span class="params">(<span class="keyword">pthread_mutex_t</span> *__mutex)</span></span></span><br></pre></td></tr></table></figure></li><li><p>当线程退出<strong>临界区</strong>后,调用函数<code>pthread_mutex_unlock</code>,为<strong>临界区解锁</strong>,把访问权让给其它线程;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span> <span class="params">(<span class="keyword">pthread_mutex_t</span> *__mutex)</span></span></span><br></pre></td></tr></table></figure></li></ul><h2 id="互斥量示例"><a href="#互斥量示例" class="headerlink" title="互斥量示例"></a>互斥量示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;utils.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calc_PI</span><span class="params">(<span class="keyword">void</span> *rank)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 1e8</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> thread_count = <span class="number">64</span>;</span><br><span class="line"><span class="keyword">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">pthread_t</span> *pthread_handles = (<span class="keyword">pthread_t</span> *)<span class="built_in">malloc</span>(thread_count * <span class="keyword">sizeof</span>(<span class="keyword">pthread_t</span>));</span><br><span class="line">    <span class="keyword">long</span> *pTarr = (<span class="keyword">long</span> *)<span class="built_in">malloc</span>(thread_count * <span class="keyword">sizeof</span>(<span class="keyword">long</span>));</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    init_time();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; thread_count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pTarr[i] = i;</span><br><span class="line">        pthread_create(&amp;pthread_handles[i], <span class="literal">NULL</span>, calc_PI, &amp;pTarr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; thread_count; i++)</span><br><span class="line">        pthread_join(pthread_handles[i], <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pi:%.12f(use time:%f ms)\n&quot;</span>, sum * <span class="number">4</span>, use_milliseconds());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(pthread_handles);</span><br><span class="line">    <span class="built_in">free</span>(pTarr);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calc_PI</span><span class="params">(<span class="keyword">void</span> *rank)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> my_rank = *(<span class="keyword">long</span> *)(rank);</span><br><span class="line">    <span class="keyword">double</span> factor = (my_rank % <span class="number">2</span>) ? <span class="number">-1.0</span> : <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> my_n = MAX_N / thread_count;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> my_first_i = my_n * my_rank;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> my_last_i = my_n * my_rank + my_n;</span><br><span class="line">    <span class="keyword">double</span> my_sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = my_first_i; i &lt; my_last_i; i++, factor *= <span class="number">-1</span>)</span><br><span class="line">        my_sum += factor / (<span class="number">1</span> + i * <span class="number">2</span>);</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    sum += my_sum;</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当线程的数量<strong>增加到超过核的数量</strong>时,那么使用<strong>互斥量</strong>的程序性能仍然保持不变,但<strong>忙等待</strong>程序的性能就会下降。</p></blockquote><h1 id="生产者-消费者同步模型"><a href="#生产者-消费者同步模型" class="headerlink" title="生产者-消费者同步模型"></a>生产者-消费者同步模型</h1><h2 id="互斥量与交换律"><a href="#互斥量与交换律" class="headerlink" title="互斥量与交换律"></a>互斥量与交换律</h2><p>使用<strong>互斥量</strong>,无法决定哪个线程先进入<strong>临界区</strong>以及此后的<strong>顺序由系统随机选取</strong>;由于在前面示例中计算$\pi$时<strong>临界区</strong>内执行加法操作,而加法具有<strong>交换律</strong>,<strong>哪个个线程先进入临界区,哪个线程后进入临界区无所谓</strong>;但是遇到<strong>矩阵乘法这样不具有乘法交换率的运算时,使用互斥量就存在问题</strong>。</p><h2 id="消息发送示例"><a href="#消息发送示例" class="headerlink" title="消息发送示例"></a>消息发送示例</h2><p>在一个消息发送的场景下,描述如下:</p><ul><li><strong>线程0</strong>发消息给<strong>线程1</strong></li><li><strong>线程1</strong>发消息给<strong>线程2</strong></li><li>、、、</li><li><strong>线程t-1</strong>发消息给<strong>线程t</strong></li><li><strong>线程t</strong>发消息给<strong>线程0</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;utils.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">Send_msg</span><span class="params">(<span class="keyword">void</span> *rank)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG_MAX 30</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> thread_count = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> **messages;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> *pthread_handles = (<span class="keyword">pthread_t</span> *)<span class="built_in">malloc</span>(thread_count * <span class="keyword">sizeof</span>(<span class="keyword">pthread_t</span>));</span><br><span class="line">    <span class="keyword">long</span> *pTarr = (<span class="keyword">long</span> *)<span class="built_in">malloc</span>(thread_count * <span class="keyword">sizeof</span>(<span class="keyword">long</span>));</span><br><span class="line">    messages = (<span class="keyword">char</span> **)<span class="built_in">malloc</span>(thread_count * <span class="keyword">sizeof</span>(<span class="keyword">char</span> *));</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; thread_count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pTarr[i] = i;</span><br><span class="line">        pthread_create(&amp;pthread_handles[i], <span class="literal">NULL</span>, Send_msg, &amp;pTarr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; thread_count; i++)</span><br><span class="line">        pthread_join(pthread_handles[i], <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; thread_count; i++)</span><br><span class="line">        <span class="built_in">free</span>(messages[i]);</span><br><span class="line">    <span class="built_in">free</span>(messages);</span><br><span class="line">    <span class="built_in">free</span>(pthread_handles);</span><br><span class="line">    <span class="built_in">free</span>(pTarr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">Send_msg</span><span class="params">(<span class="keyword">void</span> *rank)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> my_rank = *(<span class="keyword">long</span> *)(rank);</span><br><span class="line">    <span class="keyword">long</span> dest = (my_rank + <span class="number">1</span>) % thread_count;</span><br><span class="line">    <span class="keyword">long</span> source = (my_rank - <span class="number">1</span> + thread_count) % thread_count;</span><br><span class="line">    <span class="keyword">char</span> *my_msg = <span class="built_in">malloc</span>(MSG_MAX * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="built_in">snprintf</span>(my_msg, MSG_MAX, <span class="string">&quot;Hello to %ld from %ld&quot;</span>, dest, my_rank);</span><br><span class="line">    messages[dest] = my_msg;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != messages[my_rank])</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread %ld &gt; %s\n&quot;</span>, my_rank, messages[my_rank]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread %ld &gt; No message from %ld\n&quot;</span>, my_rank, source);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">===</span><br><span class="line">Thread <span class="number">0</span> &gt; No message from <span class="number">9</span></span><br><span class="line">Thread <span class="number">2</span> &gt; Hello to <span class="number">2</span> from <span class="number">1</span></span><br><span class="line">Thread <span class="number">3</span> &gt; Hello to <span class="number">3</span> from <span class="number">2</span></span><br><span class="line">Thread <span class="number">4</span> &gt; Hello to <span class="number">4</span> from <span class="number">3</span></span><br><span class="line">Thread <span class="number">5</span> &gt; Hello to <span class="number">5</span> from <span class="number">4</span></span><br><span class="line">Thread <span class="number">6</span> &gt; Hello to <span class="number">6</span> from <span class="number">5</span></span><br><span class="line">Thread <span class="number">1</span> &gt; Hello to <span class="number">1</span> from <span class="number">0</span></span><br><span class="line">Thread <span class="number">9</span> &gt; No message from <span class="number">8</span></span><br><span class="line">Thread <span class="number">7</span> &gt; Hello to <span class="number">7</span> from <span class="number">6</span></span><br><span class="line">Thread <span class="number">8</span> &gt; Hello to <span class="number">8</span> from <span class="number">7</span></span><br></pre></td></tr></table></figure><p>由上面的运行结果可知:总有线程没有收到消息(<strong>线程0</strong>没有收到来自<strong>线程9</strong>的消息,<strong>线程0</strong>没有收到来自<strong>线程9</strong>的消息); 可使用<strong>信号量</strong>(<code>semaphore</code>)来解决该问题。</p><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p><strong>信号量</strong>是一种特殊类型的变量,具体定义如下,头文件位于<code>#include &lt;semaphore.h&gt;</code>;可以赋值为<code>0,1,2,、、、</code>,大多数情况下,只给它赋值为<code>0</code>和<code>1</code>，这种只有<code>0</code>和<code>1</code>值的<strong>信号量</strong>称为<strong>二元信号量</strong>。信号量的<strong>状态</strong>:</p><ul><li><code>0</code>-对应<strong>上了锁的互斥量</strong></li><li><code>1</code>-对应<strong>未上锁的互斥量</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">char</span> __size[__SIZEOF_SEM_T];</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> __align;</span><br><span class="line">&#125; <span class="keyword">sem_t</span>;</span><br></pre></td></tr></table></figure><blockquote><p>把一个<strong>信号量</strong>作为互斥量使用时,按如下流程处理:</p><ul><li>定义一个<strong>全局变量</strong><code>sem_t sem;</code>;</li><li>调用初始化函数<code>sem_init(&amp;sem, 0, 1);</code>(第二个参数传入常数<code>0</code>即可)把<strong>信号量</strong>的值初始化为<code>1</code>,即设置为<strong>开锁状态</strong>;</li><li>在<strong>临界区</strong>前调用函数<code>sem_wait</code>;线程运行到<code>sem_wait</code>时,<strong>信号量</strong>为<code>0</code>，<strong>线程就被阻塞</strong>;<strong>线程</strong>运行到<code>sem_wait</code>时,<strong>信号量</strong>非<code>0</code>,就减<code>1</code>后进入<strong>临界区</strong>;</li><li>执行完临界区的操作后,在调用<code>sem_post</code>对信号量加<code>1</code>,使得在<code>sem_wait</code>中阻塞的其它线程能够继续运行;</li><li>最终调用<code>sem_destroy(&amp;sem);</code>销毁;</li></ul></blockquote><p>各函数的<strong>函数原型</strong>如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_init</span> <span class="params">(<span class="keyword">sem_t</span> *__sem, <span class="keyword">int</span> __pshared, <span class="keyword">unsigned</span> <span class="keyword">int</span> __value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_wait</span> <span class="params">(<span class="keyword">sem_t</span> *__sem)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_post</span> <span class="params">(<span class="keyword">sem_t</span> *__sem)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_destroy</span> <span class="params">(<span class="keyword">sem_t</span> *__sem)</span></span>;</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>二元信号量</strong>和<strong>互斥量</strong>的<strong>区别</strong>在于:<strong>信号量</strong>在整个系统可以<strong>被任意线程**</strong>获取并释放<strong>;而</strong>互斥量<strong>则要求</strong>谁获取,则由谁释放**;</p><h2 id="使用信号量解决消息发送问题"><a href="#使用信号量解决消息发送问题" class="headerlink" title="使用信号量解决消息发送问题"></a>使用信号量解决消息发送问题</h2><p><strong>消息发送问题</strong>中不存在多个线程尝试访问同一内存区域的问题,即<strong>不是临界区问题</strong>;</p><ul><li>把信号量数组<code>semaphores</code>初始化为<code>0</code>(即设置为<strong>上锁状态</strong>),各线程在<strong>数据写入之前</strong>都处于<strong>阻塞状态</strong></li><li>数据准备好后(<code>messages[dest] = my_msg;</code>),调用<code>sem_post(&amp;semaphores[dest]);</code><strong>开锁</strong></li><li>数据读取之前调用<code>sem_wait(&amp;semaphores[my_rank]);</code>查看数据是否<strong>准备好</strong>(等待写入线程调用<code>sem_post</code>函数<strong>开锁</strong>)</li><li>这种<strong>一个线程</strong>需要<strong>等待</strong>另外<strong>一个线程执行某种操作</strong>的<strong>同步方式</strong>被称为<strong>生产者-消费者同步模式</strong></li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span> <span class="comment">/* Semaphores are not part of Pthreads */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_THREADS = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MSG_MAX = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Global variables:  accessible to all threads */</span></span><br><span class="line"><span class="keyword">int</span> thread_count;</span><br><span class="line"><span class="keyword">char</span> **messages;</span><br><span class="line"><span class="keyword">sem_t</span> *semaphores;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Usage</span><span class="params">(<span class="keyword">char</span> *prog_name)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">Send_msg</span><span class="params">(<span class="keyword">void</span> *rank)</span></span>; <span class="comment">/* Thread function */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> thread;</span><br><span class="line">    <span class="keyword">pthread_t</span> *thread_handles;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">        Usage(argv[<span class="number">0</span>]);</span><br><span class="line">    thread_count = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (thread_count &lt;= <span class="number">0</span> || thread_count &gt; MAX_THREADS)</span><br><span class="line">        Usage(argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    thread_handles = <span class="built_in">malloc</span>(thread_count * <span class="keyword">sizeof</span>(<span class="keyword">pthread_t</span>));</span><br><span class="line">    messages = <span class="built_in">malloc</span>(thread_count * <span class="keyword">sizeof</span>(<span class="keyword">char</span> *));</span><br><span class="line">    semaphores = <span class="built_in">malloc</span>(thread_count * <span class="keyword">sizeof</span>(<span class="keyword">sem_t</span>));</span><br><span class="line">    <span class="keyword">long</span> *arrL = (<span class="keyword">long</span> *)<span class="built_in">malloc</span>(thread_count * <span class="keyword">sizeof</span>(<span class="keyword">long</span>));</span><br><span class="line">    <span class="keyword">for</span> (thread = <span class="number">0</span>; thread &lt; thread_count; thread++)&#123;</span><br><span class="line">        messages[thread] = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">/* Initialize all semaphores to 0 -- i.e., locked */</span></span><br><span class="line">        sem_init(&amp;semaphores[thread], <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (thread = <span class="number">0</span>; thread &lt; thread_count; thread++)&#123;</span><br><span class="line">        arrL[thread] = thread;</span><br><span class="line">        pthread_create(&amp;thread_handles[thread], (<span class="keyword">pthread_attr_t</span> *)<span class="literal">NULL</span>,</span><br><span class="line">                       Send_msg, (<span class="keyword">void</span> *)&amp;(arrL[thread]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (thread = <span class="number">0</span>; thread &lt; thread_count; thread++)</span><br><span class="line">        pthread_join(thread_handles[thread], <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (thread = <span class="number">0</span>; thread &lt; thread_count; thread++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(messages[thread]);</span><br><span class="line">        sem_destroy(&amp;semaphores[thread]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(messages);</span><br><span class="line">    <span class="built_in">free</span>(semaphores);</span><br><span class="line">    <span class="built_in">free</span>(thread_handles);</span><br><span class="line">    <span class="built_in">free</span>(arrL);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">/* main */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Usage</span><span class="params">(<span class="keyword">char</span> *prog_name)</span></span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;usage: %s &lt;number of threads&gt;\n&quot;</span>, prog_name);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125; <span class="comment">/* Usage */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">Send_msg</span><span class="params">(<span class="keyword">void</span> *rank)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> my_rank = *(<span class="keyword">long</span> *)rank;</span><br><span class="line">    <span class="keyword">long</span> dest = (my_rank + <span class="number">1</span>) % thread_count;</span><br><span class="line">    <span class="keyword">char</span> *my_msg = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(MSG_MAX * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(my_msg, <span class="string">&quot;Hello to %ld from %ld&quot;</span>, dest, my_rank);</span><br><span class="line">    messages[dest] = my_msg;</span><br><span class="line">    sem_post(&amp;semaphores[dest]); <span class="comment">/* &quot;Unlock&quot; the semaphore of dest */</span></span><br><span class="line"></span><br><span class="line">    sem_wait(&amp;semaphores[my_rank]); <span class="comment">/* Wait for our semaphore to be unlocked */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Thread %ld &gt; %s\n&quot;</span>, my_rank, messages[my_rank]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125; <span class="comment">/* Send_msg */</span></span><br></pre></td></tr></table></figure><h2 id="用信号量求解-pi"><a href="#用信号量求解-pi" class="headerlink" title="用信号量求解$\pi$"></a>用信号量求解$\pi$</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// 全局变量,使得各线程都可以访问</span></span><br><span class="line"><span class="keyword">sem_t</span> sem;</span><br><span class="line">...</span><br><span class="line">sem_init(&amp;sem, <span class="number">0</span>, <span class="number">1</span>);<span class="comment">// 初始化为开锁状态</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calc_PI</span><span class="params">(<span class="keyword">void</span> *rank)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> my_rank = *(<span class="keyword">long</span> *)(rank);</span><br><span class="line">    <span class="keyword">double</span> factor = (my_rank % <span class="number">2</span>) ? <span class="number">-1.0</span> : <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> my_n = MAX_N / thread_count;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> my_first_i = my_n * my_rank;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> my_last_i = my_n * my_rank + my_n;</span><br><span class="line">    <span class="keyword">double</span> my_sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = my_first_i; i &lt; my_last_i; i++, factor *= <span class="number">-1</span>)</span><br><span class="line">        my_sum += factor / (<span class="number">1</span> + i * <span class="number">2</span>);</span><br><span class="line">    sem_wait(&amp;sem);<span class="comment">// 等待其它互斥量变为非0</span></span><br><span class="line">    sum += my_sum;</span><br><span class="line">    sem_post(&amp;sem);<span class="comment">// 把互斥量变为非0(开锁)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="信号量与互斥量的区别"><a href="#信号量与互斥量的区别" class="headerlink" title="信号量与互斥量的区别"></a>信号量与互斥量的区别</h2><ul><li><p><strong>信号量</strong>和<strong>互斥量</strong>最大的<strong>区别</strong>在于<strong>信号量没有个体拥有权</strong>,主线程把所有<strong>信号量</strong>初始化为<code>0</code>,即<strong>加锁</strong>,<strong>其它线程</strong>都能对<strong>任何信号量</strong>调用<code>sem_post</code>和<code>sem_wait</code>函数。</p></li><li><p><strong>互斥量</strong>消耗的<code>CPU</code>资源很小，但是<strong>性能不高</strong>(因为会引起线程切换)</p></li><li>线程被阻塞在<code>sem_wait</code>时,不会消耗<code>CPU</code>周期</li></ul><h1 id="路障和条件变量"><a href="#路障和条件变量" class="headerlink" title="路障和条件变量"></a>路障和条件变量</h1><h2 id="路障"><a href="#路障" class="headerlink" title="路障"></a>路障</h2><p>通过<strong>保证所有线程</strong>在程序中处于<strong>同一个位置</strong>来<strong>同步线程</strong>,这个同步点被称为<strong>路障</strong>;只有所有线程都抵达该路障,线程才能继续运行下去,否则会阻塞在路障点。</p><p>许多多线程不提供路障;有许多方法来实现路障,常见的方法如下:</p><ul><li><strong>忙等待</strong>+<strong>互斥量</strong></li><li><strong>信号量</strong></li><li><strong>条件变量</strong></li></ul><p>要实现<strong>一个路障</strong>的功能时,前两种方法都没有问题;但是要实现<strong>多个路障的功能</strong>时,前两种方法存在不足(&lt;&lt;并行程序设计导论&gt;&gt;-<code>4.8.1</code>至<code>4.8.2</code>有详细讨论);</p><h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><p><code>Pthreads</code>中实现路障的更好方法是采用<strong>条件变量</strong>,<strong>条件变量</strong>是一个<strong>数据对象</strong>,允许线程在某个<strong>特定条件</strong>或者<strong>事件</strong>发生前都处于<strong>挂起状态</strong>。当事件或者条件<strong>发生时</strong>,另外一个线程可以通过<strong>信号</strong>来<strong>唤醒挂起的线程</strong>。<code>Pthreads</code>并没有实现这一系列的函数,需要通过一个<strong>互斥量</strong>和一个<strong>条件变量</strong>组合来实现这一系列功能(一个<strong>条件变量</strong>总是和一个<strong>互斥量</strong>相关联)。</p><p>先和盘托出一系列函数的函数原型:</p><ul><li><strong>条件变量</strong>初始化函数<code>pthread_cond_init</code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span> <span class="params">(<span class="keyword">pthread_cond_t</span> *__restrict __cond,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> *__restrict __cond_attr)</span></span>;</span><br></pre></td></tr></table></figure></li><li><strong>条件变量</strong>销毁函数<code>pthread_cond_destroy</code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span> <span class="params">(<span class="keyword">pthread_cond_t</span> *__cond)</span></span>;</span><br></pre></td></tr></table></figure></li><li>解锁<strong>一个被阻塞的线程</strong>的函数<code>pthread_cond_signal</code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span> <span class="params">(<span class="keyword">pthread_cond_t</span> *__cond)</span></span></span><br></pre></td></tr></table></figure></li><li>解锁<strong>所有被阻塞的线程</strong>的函数<code>pthread_cond_broadcast</code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span> <span class="params">(<span class="keyword">pthread_cond_t</span> *__cond)</span></span></span><br></pre></td></tr></table></figure></li><li><code>pthread_cond_wait</code>通过互斥量<code>__mutex</code>来阻塞线程<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span> <span class="params">(<span class="keyword">pthread_cond_t</span> *__restrict __cond,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="keyword">pthread_mutex_t</span> *__restrict __mutex)</span></span></span><br></pre></td></tr></table></figure>其中函数<code>pthread_cond_wait</code>相当于执行了以下<code>3</code>个函数:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_unlock(__mutex);</span><br><span class="line">wait_on_signal(__cond);</span><br><span class="line">pthread_mutex_lock(__mutex);</span><br></pre></td></tr></table></figure></li></ul><h2 id="用条件变量实现路障"><a href="#用条件变量实现路障" class="headerlink" title="用条件变量实现路障"></a>用条件变量实现路障</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> thread_count;</span><br><span class="line"><span class="keyword">int</span> barrier_thread_count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> barrier_mutex;</span><br><span class="line"><span class="keyword">pthread_cond_t</span> ok_to_proceed;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">Thread_work</span><span class="params">(<span class="keyword">void</span> *rank)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> thread;</span><br><span class="line">    <span class="keyword">pthread_t</span> *thread_handles;</span><br><span class="line">    thread_count = strtol(argv[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    thread_handles = <span class="built_in">malloc</span>(thread_count * <span class="keyword">sizeof</span>(<span class="keyword">pthread_t</span>));</span><br><span class="line">    pthread_mutex_init(&amp;barrier_mutex, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;ok_to_proceed, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (thread = <span class="number">0</span>; thread &lt; thread_count; thread++)</span><br><span class="line">        pthread_create(&amp;thread_handles[thread], <span class="literal">NULL</span>,</span><br><span class="line">                       Thread_work, (<span class="keyword">void</span> *)thread);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (thread = <span class="number">0</span>; thread &lt; thread_count; thread++)</span><br><span class="line">        pthread_join(thread_handles[thread], <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;barrier_mutex);</span><br><span class="line">    pthread_cond_destroy(&amp;ok_to_proceed);</span><br><span class="line">    <span class="built_in">free</span>(thread_handles);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">/* main */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">Thread_work</span><span class="params">(<span class="keyword">void</span> *rank)</span></span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;barrier_mutex);</span><br><span class="line">    barrier_thread_count++;</span><br><span class="line">    <span class="keyword">if</span> (barrier_thread_count == thread_count)&#123;</span><br><span class="line">        barrier_thread_count = <span class="number">0</span>;</span><br><span class="line">        pthread_cond_broadcast(&amp;ok_to_proceed);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (pthread_cond_wait(&amp;ok_to_proceed,</span><br><span class="line">                                 &amp;barrier_mutex) != <span class="number">0</span>)</span><br><span class="line">            ;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;barrier_mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对<code>Thread_work</code>函数分析可知:</p><ul><li><strong>线程0</strong>执行到第<code>36</code>行,<strong>获得锁</strong><code>barrier_mutex</code>,递增<code>barrier_thread_count</code>;继续执行<code>else</code>中的语句, 执行<code>pthread_cond_wait</code>,执行<code>pthread_cond_wait</code>函数的第一个等效函数<code>pthread_mutex_unlock</code><strong>释放锁</strong>(使得其它线程可执行路障<strong>前</strong>的代码);然后执行<code>pthread_cond_wait</code>函数的第二个等效函数<code>wait_on_signal</code>,使得<strong>线程0</strong>阻塞于此<strong>等待信号来唤醒</strong>。</li><li><strong>其它线程</strong>(除了最后一个线程外)分别和<strong>线程0</strong>一样,分别经历<strong>获得锁</strong><code>barrier_mutex</code>、<strong>递增</strong><code>barrier_thread_count</code>、<strong>释放锁</strong><code>barrier_mutex</code>、执行<code>wait_on_signal</code><strong>阻塞并等待信号来唤醒</strong>四个过程;</li><li><strong>最后一个线程</strong>执行<code>pthread_mutex_lock(&amp;barrier_mutex);</code><strong>获得锁</strong><code>barrier_mutex</code>;<strong>递增</strong><code>barrier_thread_count</code>;执行<code>if</code>,<strong>重置</strong><code>count</code>为<code>0</code>;执行<code>pthread_cond_broadcast(&amp;ok_to_proceed);</code><strong>广播唤醒其它线程的信号</strong>;最终退出<code>if</code>并执行<code>pthread_mutex_unlock(&amp;barrier_mutex);</code>来<strong>释放锁</strong><code>barrier_mutex</code>;<strong>最终第一个通过路障</strong>;</li><li><strong>其它线程</strong>逐个地<strong>获得锁</strong><code>barrier_mutex</code>,退出<code>if</code>,执行<code>pthread_mutex_unlock(&amp;barrier_mutex);</code>来<strong>释放锁</strong><code>barrier_mutex</code>,最终<strong>通过路障</strong>;</li></ul><blockquote><p><strong>1</strong>.由此可知<strong>某些线程先被唤醒并超前运行</strong>;<br><strong>2</strong>.<strong>循环调用<code>pthread_cond_wait</code>的原因</strong>:如果阻塞于此等待信号唤醒的线程不是被函数<code>pthread_cond_broadcast</code>或<code>pthread_cond_signal</code>广播的信号释放的话,则函数<code>pthread_cond_wait</code>的返回值不为<code>0</code>,被解除阻塞的线程还会再次执行函数<code>pthread_cond_wait</code>,直到被这两个函数广播的信号释放;</p></blockquote><h1 id="设置-获取线程名"><a href="#设置-获取线程名" class="headerlink" title="设置/获取线程名"></a>设置/获取线程名</h1><h2 id="Pthreads方法"><a href="#Pthreads方法" class="headerlink" title="Pthreads方法"></a>Pthreads方法</h2><p>可以使用<code>pthread_setname_np</code>和<code>pthread_getname_np</code>方法,但是这两个方法可能不被<code>glibc</code>所支持,可以通过宏<code>_GNU_SOURCE</code>来查看是否支持这两个函数;函数申明如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE             <span class="comment">/* See feature_test_macros(7) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setname_np</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_getname_np</span><span class="params">(<span class="keyword">pthread_t</span> thread,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">char</span> *name, <span class="keyword">size_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure></p><blockquote><p><code>pthread_setname_np</code>和<code>pthread_getname_np</code>方法的具体使用可查看<code>man</code></p></blockquote><h2 id="系统方法"><a href="#系统方法" class="headerlink" title="系统方法"></a>系统方法</h2><p><code>prctl</code>是个<strong>系统调用</strong>,函数声明如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prctl</span><span class="params">(<span class="keyword">int</span> option, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg2, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg3,</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="keyword">unsigned</span> <span class="keyword">long</span> arg4, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg5)</span></span>;</span><br></pre></td></tr></table></figure></p><p>其中<code>option</code>的取值可以是如下宏:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PR_SET_NAME    15       <span class="comment">/* Set process name */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PR_GET_NAME    16       <span class="comment">/* Get process name */</span></span></span><br></pre></td></tr></table></figure></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">parse_args</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">do_something</span><span class="params">(<span class="keyword">void</span> *flag)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> isInRun = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> input = parse_args();</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">true</span> == input &amp;&amp; <span class="literal">false</span> == isInRun)</span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            isInRun = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;start new thread.\n&quot;</span>);</span><br><span class="line">            <span class="keyword">pthread_t</span> handle;</span><br><span class="line">            pthread_create(&amp;handle, <span class="literal">NULL</span>, do_something, &amp;flag);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _GNU_SOURCE</span></span><br><span class="line">            pthread_setname_np(handle, <span class="string">&quot;do_something&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t set process name.\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            pthread_detach(handle);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="literal">true</span> == input &amp;&amp; <span class="literal">true</span> == isInRun)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;Already running, don&#x27;t repeat.\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="literal">false</span> == input &amp;&amp; <span class="literal">true</span> == isInRun)</span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            isInRun = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;Thread closed.\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;Not turned on yet.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">parse_args</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> cmd[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, cmd);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">strcmp</span>(<span class="string">&quot;start&quot;</span>, cmd))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">strcmp</span>(<span class="string">&quot;stop&quot;</span>, cmd))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">do_something</span><span class="params">(<span class="keyword">void</span> *flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    prctl(PR_SET_NAME, <span class="string">&quot;do_something&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span> thread_name[<span class="number">30</span>];</span><br><span class="line">    prctl(PR_GET_NAME, thread_name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;process name is %s.\n&quot;</span>, thread_name);</span><br><span class="line">    <span class="keyword">bool</span> *pTflag = flag;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">false</span> != *pTflag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;do something %d\n&quot;</span>, count++);</span><br><span class="line">        usleep(<span class="number">1000</span> * <span class="number">100</span>); <span class="comment">// sleep 20 ms</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>stdout</code>和<code>stderr</code>的使用<br>让标准输出<code>stdout</code>输出到终端,让错误输出输出到文件<code>thread_log.txt</code>;可参考如下操作<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./test_top 2&gt;thread_log.txt</span><br></pre></td></tr></table></figure><blockquote><p>注意<code>&gt;</code>左右<strong>不能有空格</strong>;其中文件描述符0,1,2分别对应<code>stdin</code>,<code>stdout</code>和<code>stderr</code></p></blockquote></li></ul><p>[1].<a href="https://hpc-tutorials.llnl.gov/posix/creating_and_terminating/">Creating and Terminating Threads</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux系统编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C, Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统编程-03-工具</title>
      <link href="/2021/10/01/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-03-%E5%B7%A5%E5%85%B7/"/>
      <url>/2021/10/01/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-03-%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h1><h2 id="获取系统时间"><a href="#获取系统时间" class="headerlink" title="获取系统时间"></a>获取系统时间</h2><ul><li>gettimeofday<br>函数获取至<code>1970</code>年至今的时间, 并将其保存在<code>tv</code>中; 函数原型为<code>int gettimeofday(struct timeval *tv, struct timezone *tz);</code>,头文件位于<code>#include &lt;sys/time.h&gt;</code>, 其中对应的两个结构体如下:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">   <span class="keyword">time_t</span>      tv_sec;     <span class="comment">/* seconds */</span></span><br><span class="line">   <span class="keyword">suseconds_t</span> tv_usec;    <span class="comment">/* microseconds */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timezone</span> &#123;</span></span><br><span class="line">   <span class="keyword">int</span> tz_minuteswest;     <span class="comment">/* minutes west of Greenwich */</span></span><br><span class="line">   <span class="keyword">int</span> tz_dsttime;         <span class="comment">/* type of DST correction */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><ul><li>参数<code>tz</code>是一个历史产物, 在早期的<code>UNIX</code>系统实现中使用其来获取系统的时区信息, 目前已被废弃, 因此在调用时始终置为<code>NULL</code>;</li><li><code>return 0 for success, or -1 for failure</code></li></ul></blockquote></li></ul><h2 id="时间戳和年月日时分秒的转换"><a href="#时间戳和年月日时分秒的转换" class="headerlink" title="时间戳和年月日时分秒的转换"></a>时间戳和年月日时分秒的转换</h2><ul><li>时间戳转化为年月日时分秒使用<code>struct tm *localtime(const time_t *timep);</code>, 头文件位于<code>#include &lt;time.h&gt;</code>, 结构体<code>tm</code>定义如下:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> &#123;</span></span><br><span class="line">   <span class="keyword">int</span> tm_sec;    <span class="comment">/* Seconds (0-60) */</span></span><br><span class="line">   <span class="keyword">int</span> tm_min;    <span class="comment">/* Minutes (0-59) */</span></span><br><span class="line">   <span class="keyword">int</span> tm_hour;   <span class="comment">/* Hours (0-23) */</span></span><br><span class="line">   <span class="keyword">int</span> tm_mday;   <span class="comment">/* Day of the month (1-31) */</span></span><br><span class="line">   <span class="keyword">int</span> tm_mon;    <span class="comment">/* Month (0-11) */</span></span><br><span class="line">   <span class="keyword">int</span> tm_year;   <span class="comment">/* Year - 1900 */</span></span><br><span class="line">   <span class="keyword">int</span> tm_wday;   <span class="comment">/* Day of the week (0-6, Sunday = 0) */</span></span><br><span class="line">   <span class="keyword">int</span> tm_yday;   <span class="comment">/* Day in the year (0-365, 1 Jan = 0) */</span></span><br><span class="line">   <span class="keyword">int</span> tm_isdst;  <span class="comment">/* Daylight saving time */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>注意以上时间的区间</p></blockquote></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">man localtime</span><br><span class="line">tm_sec    The number of seconds after the minute, normally <span class="keyword">in</span> the range 0 to 59, but can be up to 60 to allow <span class="keyword">for</span> leap seconds.</span><br><span class="line"></span><br><span class="line">tm_min    The number of minutes after the hour, <span class="keyword">in</span> the range 0 to 59.</span><br><span class="line"></span><br><span class="line">tm_hour   The number of hours past midnight, <span class="keyword">in</span> the range 0 to 23.</span><br><span class="line"></span><br><span class="line">tm_mday   The day of the month, <span class="keyword">in</span> the range 1 to 31.</span><br><span class="line"></span><br><span class="line">tm_mon    The number of months since January, <span class="keyword">in</span> the range 0 to 11.</span><br><span class="line"></span><br><span class="line">tm_year   The number of years since 1900.</span><br><span class="line"></span><br><span class="line">tm_wday   The number of days since Sunday, <span class="keyword">in</span> the range 0 to 6.</span><br><span class="line"></span><br><span class="line">tm_yday   The number of days since January 1, <span class="keyword">in</span> the range 0 to 365.</span><br><span class="line"></span><br><span class="line">tm_isdst  A  flag that indicates whether daylight saving time is <span class="keyword">in</span> effect at the time described.  The value is positive <span class="keyword">if</span> daylight saving time is <span class="keyword">in</span> ef‐</span><br><span class="line">         fect, zero <span class="keyword">if</span> it is not, and negative <span class="keyword">if</span> the information is not available.</span><br></pre></td></tr></table></figure><ul><li>年月日时分秒转化为时间戳使用<code>time_t mktime(struct tm *tm);</code>, 头文件位于<code>#include &lt;time.h&gt;</code>, 结构体<code>time_t</code>实际上是<code>long int</code></li></ul><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timezone</span> <span class="title">zone</span>;</span></span><br><span class="line">    gettimeofday(&amp;tv, &amp;zone);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tz_minuteswest:%d tz_dsttime:%d\n&quot;</span>, zone.tz_minuteswest, zone.tz_dsttime);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">ptLt</span> =</span> localtime(&amp;(tv.tv_sec));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%04d-%02d-%02d %02d:%02d:%02d\n&quot;</span>, ptLt-&gt;tm_year + <span class="number">1900</span>, ptLt-&gt;tm_mon + <span class="number">1</span>, ptLt-&gt;tm_mday,</span><br><span class="line">           ptLt-&gt;tm_hour, ptLt-&gt;tm_min, ptLt-&gt;tm_sec);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;wday:%d yday:%d\n&quot;</span>, ptLt-&gt;tm_wday, ptLt-&gt;tm_yday);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == ptLt-&gt;tm_isdst)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;is dst.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> == ptLt-&gt;tm_isdst)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;is not dst.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;the information is not available.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">time_t</span> stamp = mktime(ptLt);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tv_sec:%ld\n&quot;</span>, tv.tv_sec);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stamp :%ld\n&quot;</span>, stamp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line">tz_minuteswest:<span class="number">0</span> tz_dsttime:<span class="number">0</span></span><br><span class="line"><span class="number">2021</span><span class="number">-10</span><span class="number">-02</span> <span class="number">09</span>:<span class="number">39</span>:<span class="number">23</span></span><br><span class="line">wday:<span class="number">6</span> yday:<span class="number">274</span></span><br><span class="line">is <span class="keyword">not</span> dst.</span><br><span class="line">tv_sec:<span class="number">1633138763</span></span><br><span class="line">stamp :<span class="number">1633138763</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux系统编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C, Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-内核学习-07</title>
      <link href="/2021/10/01/Linux-%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0-07/"/>
      <url>/2021/10/01/Linux-%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0-07/</url>
      
        <content type="html"><![CDATA[<p>以下内容以<code>x86 CPU</code>为例进行笔记整理,本文以[1]为学习来源;</p><h1 id="概念区分"><a href="#概念区分" class="headerlink" title="概念区分"></a>概念区分</h1><h2 id="中英文对照"><a href="#中英文对照" class="headerlink" title="中英文对照"></a>中英文对照</h2><p>逻辑地址,虚拟地址,线性地址和物理地址中英文对照:<br>逻辑地址 —- <code>logical address</code></p><p>虚拟地址 —- <code>virtual address</code></p><p>线性地址 —- <code>linear address</code></p><p>物理地址 —- <code>physical address</code></p><h2 id="区分"><a href="#区分" class="headerlink" title="区分"></a>区分</h2><p><code>CPU</code>读取指令或则数据时, 只有<strong>逻辑地址</strong>; 根据<strong>逻辑地址</strong>获取<strong>线性地址</strong>, 根据<strong>线性地址</strong>获取<strong>物理地址</strong>;<strong>虚拟地址</strong>是获取<strong>线性地址</strong>时的一个偏置<code>Offset</code>, 详细将后文;</p><h1 id="线性地址"><a href="#线性地址" class="headerlink" title="线性地址"></a>线性地址</h1><p>线性地址获取步骤靠图<code>Logic_virtual_linear_phy_address</code>中左侧虚框所示</p><ul><li><code>CPU</code>拿到<strong>逻辑地址</strong>后, 取出其中的<strong>段选择器</strong>(<code>Segment Selector</code>)和<strong>偏置</strong>(虚拟内存-<code>Offset</code>);</li><li>以<strong>段选择器</strong>为地址, 在<strong>全局符号器表</strong>(<code>Global Descriptor Table</code>)中获取<strong>段基地址</strong>(<code>Segment Base Address</code>);</li><li>以<strong>段基地址</strong>+<strong>偏置</strong>在<strong>线性地址空间</strong>(<code>Linear Address Space</code>)中找到<strong>线性地址</strong></li></ul><blockquote><p>把这个过程称作<strong>段式内存管理</strong></p></blockquote><p><img src="/images/Logic_virtual_linear_phy.png" alt="Logic_virtual_linear_phy_address"></p><h1 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h1><p>把<strong>逻辑地址</strong>分为<code>Dir</code>,<code>Table</code>和<code>Offset</code>字段; 在<code>x86 CPU</code>中有一个<code>CR3</code>寄存器, 保存了<strong>页目录</strong>(<code>Page Directory</code>)的地址;<strong>页目录</strong>中存放<strong>页表</strong>(<code>Page Table</code>)的地址; <code>Linux</code>内核有一个<strong>页目录</strong>, 每个进程有一个单独的<strong>页目录</strong>;<strong>页目录</strong>中有<code>1024</code>条数据, 每条数据占有<code>4 bytes</code>, <code>4 bytes</code>刚好可以描述<code>1024</code>的内存大小;</p><ul><li>在<strong>页目录</strong>(<code>Page Directory</code>)中取出<code>Dir</code>地址中保存的地址; 该地址保存了<strong>页表</strong>(<code>Page Table</code>)的地址;</li><li>在<strong>页表</strong>找到地址为<code>Table</code>的地址的内容; 该内容代表着<strong>物理块编号</strong>(系统对物理内存进行编号, 一个编号对应一个页, 每个页中保存了$2^{12}$个地址)</li><li><strong>物理块编号</strong>+<strong>Offset</strong>即为<strong>物理地址</strong><blockquote><p>把这个过程称作<strong>页式内存管理</strong></p></blockquote></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>所以，x86采用的是<strong>段页式内存管理的方式</strong>。</p><p>按照 Intel 的设计，段式内存管理中的段类型分为三种：代码段、数据段、系统段(TSS之类的),实在是太麻烦了。我们只靠页式内存管理就已经可以完成Linux内核需要的所有功能(关闭段式内存管理),根本不需要段映射,但是段映射这玩意儿又关不掉,那就只能上点手段了。 </p><p>Linux内核将所有类型的段的<code>segment base address</code>都设成0;由于段基地址变为了0,那么线性地址=逻辑地址=虚拟地址。 </p><p>[1].<a href="https://www.bilibili.com/read/cv8114824?spm_id_from=333.999.0.0">简说linux</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux内核 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C, 驱动开发, Linux内核 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python-01</title>
      <link href="/2021/09/29/python-01/"/>
      <url>/2021/09/29/python-01/</url>
      
        <content type="html"><![CDATA[<h1 id="python的基本工具"><a href="#python的基本工具" class="headerlink" title="python的基本工具"></a>python的基本工具</h1><h2 id="pip3"><a href="#pip3" class="headerlink" title="pip3"></a>pip3</h2><ul><li><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install --reinstall python3-pip</span><br></pre></td></tr></table></figure><ul><li>查看库路径<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> ➜  ~ pip3 show numpy</span><br><span class="line">Name: numpy</span><br><span class="line">Version: 1.21.2</span><br><span class="line">Summary: NumPy is the fundamental package <span class="keyword">for</span> array computing with Python.</span><br><span class="line">Home-page: https://www.numpy.org</span><br><span class="line">Author: Travis E. Oliphant et al.</span><br><span class="line">Author-email: None</span><br><span class="line">License: BSD</span><br><span class="line">Location: /usr/<span class="built_in">local</span>/lib/python3.8/dist-packages</span><br><span class="line">Requires:</span><br><span class="line">Required-by:</span><br></pre></td></tr></table></figure></li></ul></li><li><p>更换下载源</p><ul><li>常用下载源<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">清华：https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"></span><br><span class="line">阿里云：http://mirrors.aliyun.com/pypi/simple/</span><br><span class="line"></span><br><span class="line">中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/</span><br><span class="line"></span><br><span class="line">华中理工大学：http://pypi.hustunique.com/</span><br><span class="line"></span><br><span class="line">山东理工大学：http://pypi.sdutlinux.org/ </span><br><span class="line"></span><br><span class="line">豆瓣：http://pypi.douban.com/simple/</span><br></pre></td></tr></table></figure></li><li>临时更换<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple pyspider</span><br></pre></td></tr></table></figure></li><li>一劳永逸<br>修改<code>~/.pip/pip.conf</code> (没有就创建一个文件夹及文件)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">timeout =6000</span><br><span class="line">index-url =http://pypi.douban.com/simple/</span><br><span class="line">[install]</span><br><span class="line">use-mirrors =<span class="literal">true</span></span><br><span class="line">mirrors =http://pypi.douban.com/simple/</span><br><span class="line">trusted-host =pypi.douban.com</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="matplotlib"><a href="#matplotlib" class="headerlink" title="matplotlib"></a>matplotlib</h1><h2 id="Times-New-Roman字体问题"><a href="#Times-New-Roman字体问题" class="headerlink" title="Times New Roman字体问题"></a><code>Times New Roman</code>字体问题</h2><ul><li>使用<code>Times New Roman</code>时, 报找不到 [‘Times New Roman’]的错误<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.ylabel(<span class="string">&#x27;Clocks($\mu S$)&#x27;</span>, fontdict=&#123;<span class="string">&#x27;family&#x27;</span> : <span class="string">&#x27;Times New Roman&#x27;</span>, <span class="string">&#x27;size&#x27;</span>   : <span class="number">16</span>&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">findfont: Font family [<span class="string">&#x27;Times New Roman&#x27;</span>] not found. Falling back to DejaVu Sans.</span><br></pre></td></tr></table></figure></li><li>解决方法<ul><li>把<code>windows</code>中<code>C:\Windows\Fonts</code>的<code>Times New Roman</code>字体拷贝到以下路径中(使用<code>pip3 show matplotlib</code>查看<code>matplotlib</code>的安装路径)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls ./time*</span><br><span class="line">./timesbd.ttf  ./timesbi.ttf  ./timesi.ttf  ./times.ttf</span><br><span class="line">sudo cp ./<span class="built_in">times</span>* /usr/<span class="built_in">local</span>/lib/python3.8/dist-packages/matplotlib/mpl-data/fonts/ttf</span><br></pre></td></tr></table></figure></li><li>删除matplotlib的缓存:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf ~/.cache/matplotlib</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="networkx"><a href="#networkx" class="headerlink" title="networkx"></a>networkx</h1><p><img src="/images/networkx_logo.svg" alt="networkx_logo"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install networkx -i http://pypi.douban.com/simple --trusted-host pypi.douban.com</span><br></pre></td></tr></table></figure><h1 id="pygraphviz"><a href="#pygraphviz" class="headerlink" title="pygraphviz"></a>pygraphviz</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install graphviz</span><br><span class="line">sudo apt-get install graphviz libgraphviz-dev pkg-config</span><br><span class="line">pip install pygraphviz</span><br></pre></td></tr></table></figure><h1 id="pydot"><a href="#pydot" class="headerlink" title="pydot"></a>pydot</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install pydot</span><br></pre></td></tr></table></figure><h1 id="python3-tk"><a href="#python3-tk" class="headerlink" title="python3-tk"></a>python3-tk</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ModuleNotFoundError: No module named <span class="string">&#x27;tkinter&#x27;</span></span><br><span class="line">sudo apt install python3-tk</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统编程-02-操作系统</title>
      <link href="/2021/09/24/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-02-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2021/09/24/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-02-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统的位数与内存指针"><a href="#操作系统的位数与内存指针" class="headerlink" title="操作系统的位数与内存指针"></a>操作系统的位数与内存指针</h1><p> cpu不能直接访问硬盘的数据呢, 只能通过把硬盘的数据先放到内存里, 然后再从内存里访问硬盘的数据, 所以<code>内存才是计算机系统的主存储器,而硬盘是、光盘、u盘一类都是外部存储器</code>;</p><p> 实际上内存是把8个8个bit排成1组, 每1组成为1个单位, 大小是1 byte(字节), cpu每一次只能访问1个byte, 而不能单独去访问具体的1个小格子(bit),<code>1个byte字节就是内存的最小的IO单位</code>;如下图所示:<br> <img src="/images/memory.png" alt="memory"></p><p><strong>计算机操作系统</strong>会给内存每1个字节分配1个内存地址, <code>cpu</code>只需要知道某个数据类型的地址, 就可以直接去到内存地址中去提取数据了</p><ul><li><p>直接寻址技术<br>假如你知道你要找的人住在那栋大楼的17楼 1702, 但是你还是需要从1楼走到17楼去找他, 这个过程还是需要时间成本的。但是如果你具有了直接寻址技术,  就能直接跳到17楼 1702门前,  如果你找的下1个人在2楼, 又能从17楼直接跳到2楼, 而直接寻址技术已经成为当代计算机软硬件的标准技术之一, 也就是说只要cpu知道要访问数据的内存地址, 就能直接到内存的对应位置去访问数据!</p></li><li><p>内存地址的表示方式<br>跟门牌号一样, 其实内存地址也是由1个2进制数字来表示的; 每1个地址对应内存里的1个<code>byte</code>字节, 如果地址的值加1, 那么这个地址就对应下1个字节了;在32位操作系统中, 总线有32根，根据每根高低电平的不同可以有2的32次方次不同情况, 所以32位的地址范围就是从<br><code>0000 0000 0000 0000 0000 0000 0000 0000</code><br>到<br><code>1111 1111 1111 1111 1111 1111 1111 1111</code></p><p>64位系统的内存地址是64位的二进制数, 也就是<code>4G × 4G</code>个地址; </p><ul><li>关于指针<br>指针是用来存放内存地址的, 那么对于32位系统来讲,内存地址是1个32位长度的2进制数, 而每1个内存单位长度只有1 byte = 8 bit(位),所以1个指针就需要4byte的内存来存放该指针的内容; 同理64位操作系统也就需要8bytes的内容来存放指针的内容了。</li></ul></li></ul><h1 id="冯-诺依曼结构"><a href="#冯-诺依曼结构" class="headerlink" title="冯 * 诺依曼结构"></a>冯 * 诺依曼结构</h1><h2 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h2><script type="math/tex; mode=display">    \begin{pmatrix}    y_1 \\    y_2 \\    ...\\    y_{MAX} \\    \end{pmatrix}    =    \begin{pmatrix}    a_{11} & a_{12} & ... & a_{1*MAX} \\    a_{21} & a_{22} & ... & a_{2*MAX} \\    ...    &  ...   & ... & ...         \\    a_{MAX*1} & a_{MAX*2} & ... & a_{MAX*MAX} \\    \end{pmatrix}    *    \begin{pmatrix}    x_1 \\    x_2 \\    ...\\    x_{MAX} \\    \end{pmatrix}</script><ul><li>初始化<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST_TIMES 300</span></span><br><span class="line"><span class="keyword">double</span> A[MAX][MAX], x[MAX], y[MAX];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; MAX; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; MAX; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        A[i][j] = rand() / RAND_MAX * <span class="number">100.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x[i] = rand() / RAND_MAX * <span class="number">100.0</span>;</span><br><span class="line">    y[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>算法1<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; MAX; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; MAX; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        y[i] += A[i][j] * x[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>算法2<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; MAX; j++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; MAX; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        y[i] += A[i][j] * x[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>用时对比<br>算法1和算法2的对比用时<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use time: 11.288730 ms.</span><br><span class="line">use time: 24.910040 ms.</span><br></pre></td></tr></table></figure><br><img src="/images/cache_test.png" alt="效果"></p><h1 id="5个不同的数据区域"><a href="#5个不同的数据区域" class="headerlink" title="5个不同的数据区域"></a>5个不同的数据区域</h1><p>该部分笔记参考<a href="https://blog.csdn.net/weixin_38233274/article/details/80321719?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2.no_search_link">数据段、代码段、BSS段、堆栈段</a><br><code>linux</code>中使用<code>size</code>命令可以查看可知执行程序的3个数据区域, 如下所示; 其中<strong>正文段</strong>(<code>Text Segment</code>)用于存储指令, <strong>数据段</strong>(<code>Data Segment</code>)用于存储已初始化的<strong>全局变量</strong>, <strong>BSS段</strong>(<code>BSS Segment-Block Started by Symbol</code>)用于存储未赋值的全局变量;<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  build size ./main          </span><br><span class="line">   text    data     bss     dec     hex filename</span><br><span class="line">   1707     648       8    2363     93b ./main</span><br></pre></td></tr></table></figure></p><blockquote><p><code>dec</code>的大小是<code>text</code>、<code>data</code>和<code>bss</code>的大小之和; 这三个区域在程序被编译完成后就确定好了。</p></blockquote><h2 id="c语言知识点复习"><a href="#c语言知识点复习" class="headerlink" title="c语言知识点复习"></a>c语言知识点复习</h2><p>参考<code>C Primer Plus第六版-12.4.4</code>可知, 可以把程序中变量分为3部分:</p><ul><li>具有外部链接、内部链接和无链接的静态变量;</li><li>自动变量; 程序进入定义变量的块时存在, 程序离开块时消失。通过<strong>栈</strong>来管理, 意味着新创建变量的顺序加入内存中, 然后以相反的顺序销毁;</li><li>动态内存分配的变量; 使用<code>malloc</code>和相关函数分配内存时存在, 使用<code>free</code>后释放, 分配的内存区域被叫做<strong>内存堆或自由内存</strong></li></ul><p><strong>全局变量</strong>在定义时不初始化则初始值是0，<strong>局部变量</strong>在定义时不初始化则初始值是不确定的。</p><h2 id="5个数据段"><a href="#5个数据段" class="headerlink" title="5个数据段"></a>5个数据段</h2><p>进程对内存的管理方式因内存用途不一而不尽相同,有些内存是事先<strong>静态分配和统一回收</strong>的,而有些却是按需要<strong>动态分配和回收</strong>的。对任何一个普通进程来讲,它都会涉及到5种不同的数据段。</p><ul><li><p><strong>BSS段</strong>:<strong>BSS段</strong>（<code>bss segment</code>）通常是指用来存放程序中<strong>未初始化的全局变量</strong>的一块内存区域。<strong>BSS</strong>是英文<code>Block Started by Symbol</code>的简称。BSS段属于<strong>静态内存分配</strong>。</p></li><li><p><strong>数据段</strong>:<strong>数据段</strong>(<code>data segment</code>)通常是指用来存放程序中<strong>已初始化的全局变量</strong>与<strong>静态局部变量</strong>的一块内存区域。数据段属于<strong>静态内存分配</strong>。</p></li><li><p><strong>代码段</strong>:<strong>代码段</strong>(<code>code segment/text segment</code>)通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小<strong>在程序运行前就已经确定</strong>，并且内存区域通常属于只读, 某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些<strong>只读的常数变量</strong>，例如<strong>字符串常量</strong>等。</p></li><li><p><strong>堆</strong>(<code>heap</code>)：堆是用于存放进程运行中<strong>被动态分配的内存段</strong>,它的大小并不固定，可动态扩张或缩减。当进程调用<code>malloc</code>等函数分配内存时，新分配的内存就被动态添加到堆上(堆被扩张);当利用<code>free</code>等函数释放内存时，被释放的内存从堆中被剔除(堆被缩减), 若程序员不释放，则会有内存泄漏, 系统会不稳定, <code>Windows</code>系统在该进程退出时由<code>OS</code>释放，<code>Linux</code>则只在整个系统关闭时<code>OS</code>才去释放（参考<strong>Linux内存管理</strong>）。</p></li><li><p><strong>栈</strong>(<code>stack</code>)：<strong>栈又称堆栈</strong>, 是用户存放程序<strong>临时创建的局部变量</strong>, 也就是说我们函数括弧<code>&#123;&#125;</code>中定义的变量(但不包括<code>static</code>声明的变量，<code>static</code>意味着在数据段中存放变量)。 除此以外, 在函数被调用时,其参数也会被压入发起调用的进程栈中, 并且待到调用结束后, 函数的返回值也会被存放回栈中。由于<strong>栈的先进后出特点</strong>, 所以栈特别方便用来保存/恢复调用现场。从这个意义上讲, 我们可以把堆栈看成一个寄存、交换临时数据的内存区。</p></li></ul><blockquote><p><strong>栈溢出</strong>不一定是递归调用太多, 也可能时局部变量太大了; 所以较大的数组放在<code>main</code>函数外定义;</p></blockquote><h2 id="bss与data的说明"><a href="#bss与data的说明" class="headerlink" title="bss与data的说明"></a><code>bss</code>与<code>data</code>的说明</h2><p><strong>全局的未初始化变量</strong>存在于<code>bss</code>段中, 具体体现为一个<strong>占位符</strong>;<strong>全局的已初始化变量</strong>存于<code>data</code>段中；而函数内的<code>自动变量</code>都在<strong>栈上分配空间</strong>。<code>bss</code>是不占用可执行程序的文件空间, 其内容由操作系统初始化(清零), 而<code>data</code>却需要占 用文件空间, 其内容由程序初始化，因此造成了上述情况。</p><hr><h1 id="fork-exec-clone"><a href="#fork-exec-clone" class="headerlink" title="fork, exec, clone"></a><code>fork, exec, clone</code></h1><h2 id="fork"><a href="#fork" class="headerlink" title="fork"></a><code>fork</code></h2><p><code>fork</code>函数用来创建一个子进程, 函数声明如下, 返回值为<code>0</code>时,用作引导进入新进程;返回值非零(新进程的<code>pid</code>)用作引导进入原来的进程继续执行任务;<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure></p><blockquote><p><code>fork</code>产生新任务的速度特别快,因为<code>fork</code>并不复制原任务的内存空间,而是和原任务共享一个<strong>写时复制</strong>的内存空间;</p></blockquote><h2 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a><code>exec</code>函数族</h2><p><code>exec</code>不是一个函数,而是一个<strong>函数族</strong>,具体是如下函数;它们都是以<code>exec</code>为前缀，那么不同的之后后面的一些字符，<code>l</code>表示命令行参数列表、<code>p</code>表示<code>PATH</code>环境变量、<code>v</code>表示使用参数数组、<code>e</code>使用环境变量数组。其中<code>execvpe</code>和<code>execle</code>一般不常用;<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line">extern char **environ;</span><br><span class="line">int execl(const char *pathname, const char *arg, ...</span><br><span class="line">               /* (char  *) NULL */);</span><br><span class="line">int execlp(const char *file, const char *arg, ...</span><br><span class="line">               /* (char  *) NULL */);</span><br><span class="line">int execle(const char *pathname, const char *arg, ...</span><br><span class="line">               /*, (char *) NULL, char *const envp[] */);</span><br><span class="line">int execv(const char *pathname, char *const argv[]);</span><br><span class="line">int execvp(const char *file, char *const argv[]);</span><br><span class="line">int execvpe(const char *file, char *const argv[],</span><br><span class="line">               char *const envp[]);</span><br></pre></td></tr></table></figure></p><h3 id="execl"><a href="#execl" class="headerlink" title="execl"></a><code>execl</code></h3><p>由于<code>execl</code><strong>成功调用后</strong>这个进程的代码段都被替换了,自然下面的代码就不会再执行了,所以也就没有返回值了,但是<strong>当调用失败后</strong>就会返回<code>-1</code>并设置<code>errno</code>值。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        execl(<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        perror(<span class="string">&quot;execl&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><code>pathname</code>代表可执行程序的路径;</li><li><code>ls</code>参数其实没有实际意义,该参数其实没有实际意义</li><li><code>-l</code>是可执行程序执行时的参数</li><li>最后用<code>NULL</code>表示结束</li></ul><h3 id="execlp"><a href="#execlp" class="headerlink" title="execlp"></a><code>execlp</code></h3><p>如果是用<code>execlp</code>，那么第一个参数就可以不用加<code>ls</code>的路径了，直接是<code>ls</code>就可以了，因为系统会去<code>PATH</code>中查找<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    execlp(<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="string">&quot;../&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    perror(<span class="string">&quot;execlp&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="execv"><a href="#execv" class="headerlink" title="execv"></a><code>execv</code></h3><p>如果是<code>execv</code>的话，后面的参数就要是一个<strong>指针数组</strong>的形式，可以看下面的代码:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *argv[] = &#123;<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    execv(<span class="string">&quot;/bin/ls&quot;</span>, argv);</span><br><span class="line">    perror(<span class="string">&quot;execl&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="execle"><a href="#execle" class="headerlink" title="execle"></a><code>execle</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello pid=%d\n&quot;</span>, getpid());</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; environ[i] != <span class="literal">NULL</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, environ[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *<span class="keyword">const</span> envp[] = &#123;<span class="string">&quot;AA=11&quot;</span>, <span class="string">&quot;BB=22&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Entering main ...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    execle(<span class="string">&quot;./hello&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="literal">NULL</span>, envp);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">        perror(<span class="string">&quot;execl error&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Exiting main ...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Entering main ...</span><br><span class="line">hello pid=26290</span><br><span class="line">AA=11</span><br><span class="line">BB=22</span><br></pre></td></tr></table></figure></p><h2 id="clone"><a href="#clone" class="headerlink" title="clone"></a><code>clone</code></h2><p>暂时没写</p><h2 id="大端与小端"><a href="#大端与小端" class="headerlink" title="大端与小端"></a>大端与小端</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> data = <span class="number">0x12345678</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)&amp;data;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(unsigned):%lu\n&quot;</span>, <span class="keyword">sizeof</span>(data));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n%-16s %-5s\n&quot;</span>, <span class="string">&quot;address&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(data); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%-16lX %02X\n&quot;</span>, (<span class="keyword">uint64_t</span>)p, *p);</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜  bigLittle git:(master) ✗ ./main           </span><br><span class="line">sizeof(unsigned):4</span><br><span class="line"></span><br><span class="line">address          value</span><br><span class="line">FFFFF6D49AD4     78</span><br><span class="line">FFFFF6D49AD5     56</span><br><span class="line">FFFFF6D49AD6     34</span><br><span class="line">FFFFF6D49AD7     12</span><br><span class="line">➜  bigLittle git:(master) ✗ readelf -h ./main | grep Data</span><br><span class="line">  Data:                              2<span class="string">&#x27;s complement, little endian</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>小端</strong>:数据的<strong>低位</strong>(<code>0X78</code>)存放在<strong>低地址</strong><code>(0XFFFFF6D49AD4)</code><br><strong>大端</strong>:数据的<strong>低位</strong>(<code>0X78</code>)存放在<strong>高地址</strong><code>(0XFFFFF6D49AD7)</code></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux系统编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C, Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统编程-01-字符串处理</title>
      <link href="/2021/09/20/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-01-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"/>
      <url>/2021/09/20/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-01-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="strcpy和strdup"><a href="#strcpy和strdup" class="headerlink" title="strcpy和strdup"></a>strcpy和strdup</h1><p><code>strcpy</code>和<code>strdup</code>都是拷贝字符串的内容(<code>duplicate a string</code>)<br>1.函数声明对比<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strdup</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;</span><br><span class="line">----------------------------</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcpy</span><span class="params">(<span class="keyword">char</span> *dest, <span class="keyword">const</span> <span class="keyword">char</span> *src)</span></span>;</span><br></pre></td></tr></table></figure><br>2.使用对比<br>使用<code>strcpy</code>之前必须为<code>dest</code>分配足够的内存;而<code>strdup</code>内部实现了内存的分配</p><p>3.示例<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> src[] = <span class="string">&quot;compare strdup to strcpy.&quot;</span>;</span><br><span class="line"><span class="keyword">size_t</span> len = <span class="keyword">sizeof</span>(src);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *dest_cpy = <span class="literal">NULL</span>;</span><br><span class="line">dest_cpy = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(len); <span class="comment">// 内存分配</span></span><br><span class="line"><span class="built_in">strcpy</span>(dest_cpy, src);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;dest_src:[%s]\n&quot;</span>, dest_cpy);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *dest_dup = <span class="literal">NULL</span>;</span><br><span class="line">dest_dup = strdup(src);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;dest_dup:[%s]\n&quot;</span>, dest_dup);</span><br></pre></td></tr></table></figure></p><h1 id="malloc-alloc-remalloc-free"><a href="#malloc-alloc-remalloc-free" class="headerlink" title="malloc, alloc, remalloc, free"></a>malloc, alloc, remalloc, free</h1><h2 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h2><p>这四个函数在<code>stdlib.h</code>中被声明<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> nmemb, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure></p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul><li><strong>1</strong>.<code>malloc</code>分配指定字节数<code>size</code>的存储区, <code>此存储区中的初始值不确定</code>;<code>malloc</code>分配的是<strong>一块连续的内存</strong>,<code>malloc(size)</code>分配的内存可能比实际的<code>size</code>要多一点(这取决于编译器,不要指望一定会多一点);如果<strong>内存池</strong>中没能提供指定数量的内存,则返回<code>NULL</code>(确定<code>malloc</code>的返回值是否为<code>NULL</code>非常重要);</li><li><strong>2</strong>.<code>alloc</code>向内存池申请<code>nmemb</code>个大小为<code>size</code>的内存区域, <code>并给内存区域填充0</code></li><li><strong>3</strong>.<code>realloc</code>被用作重新分配内存; <ul><li><strong>3.1</strong>.原来的内存块可以<strong>扩大缩小</strong>, 则原地址ptr和返回地址值相等; 如果是缩小一块内存块，则将该内存块的<strong>后半部分直接拿掉</strong>，<strong>剩余部分内存块及其内容保留</strong>; 如果是扩大一个内存块，则将原来的内存块保留,<strong>原内存原先的内容保留</strong>,在他的后边新增一块内存块（但是<strong>新增的内存块并未初始化</strong>）</li><li><strong>3.2</strong>.原来的内存块<strong>无法扩大缩小</strong>, <code>realloc</code>会重新开辟一个新的内存空间，并把原来的内存空间的<strong>内容拷贝到新的内存空间里</strong>(在调用完<code>realloc</code>后就<strong>不能使用指向就内存的指针</strong><code>ptr</code>，而是用<strong>返回的新的指针</strong>。)</li><li><strong>3.3</strong>.<code>realloc</code>在<strong>内存缩小</strong>时,内部实现了对其<strong>尾部内存</strong>的释放工作;</li><li><strong>3.4</strong>.如果<code>realloc</code>的第二个参数为<code>NULL</code>,则<code>realloc</code><strong>等于</strong><code>malloc</code></li></ul></li></ul><blockquote><p>给<code>free</code>传入一个<code>NULL</code>参数<strong>不会产生任何效果</strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi;</span><br><span class="line">pi = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == pi)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Out of memory.\n&quot;</span>);<span class="comment">// 内存不足 = Out of space</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><ul><li>对<code>NULL</code>进行<strong>解引用操作</strong></li><li>对分配的内存进行操作时<strong>越过边界</strong>:例如,<code>pi = (int *)malloc(25*sizeof(int))</code>,进行下标引用操作时,下标小于<code>0</code>或则大于<code>24</code>将引起两种类型的问题;<ul><li><strong>第一种</strong>:被访问的内存可能保存了其它变量的值,对它进行修改将破坏那个变量的值,这种<code>bug</code>很难发现</li><li><strong>第二种</strong>:在<code>malloc</code>和<code>free</code>的有些实现中,使用<strong>链表</strong>来<strong>维护可用的内存池</strong>,对分配之外的内存区域进行访问<strong>可能破坏这链表</strong>,这可能产生<strong>异常而导致退出</strong>;</li></ul></li><li>释放<strong>并非动态内存分配的</strong>内存,传递给<code>free</code>的值必须是<code>malloc</code>、<code>alloc</code>、<code>realloc</code>返回的值</li><li><strong>释放</strong>动态内存分配的<strong>内存的一部分</strong>:例如,<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="number">25</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="built_in">free</span>(pi+<span class="number">5</span>);</span><br></pre></td></tr></table></figure></li><li>一块动态内存<strong>被释放后被继续使用</strong>,可能有<strong>多个指针</strong>指向同一片由动态分配的内存区域,这些指针<strong>散布</strong>在程序的各处,确保对其中任一个指针进行<code>free</code>操作前,停止对<strong>其余指针的使用</strong>;</li><li><strong>内存泄露</strong>(<code>memory leak</code>):由动态内存分配的内存区域,在不需要使用时,应该及时释放;<ul><li>在那些执行程序<strong>共用一片内存区域</strong>的<strong>操作系统</strong>,<strong>内存泄露</strong>将一点点地<strong>榨干可用内存</strong>,此时只能<strong>重启操作系统</strong>才能释放内存;</li><li>在那些能够<strong>记住每个可执行程序的内存段</strong>的<strong>操作系统</strong>,当程序中止时,将<strong>回收</strong>分配给<strong>该可执行程序的内存</strong>;尽管如此,内存被耗尽时,该可执行程序无法执行下去,已完成的工作将统统丢失</li></ul></li></ul><h2 id="编码小技巧"><a href="#编码小技巧" class="headerlink" title="编码小技巧"></a>编码小技巧</h2><ul><li>设置<code>free</code>后的指针为<code>NULL</code><br>被<code>free</code>后的指针,只是<strong>放弃</strong>了指针对<strong>这个内存的占用</strong>, 放弃之后,内存的值会改写成随机值。但是<strong>指针本身并没有被删除</strong>,<strong>指针</strong>仍然<strong>指向原来的那块内存</strong>;例如:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *pi = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    *pi = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;address: %p, value: %3d.\n&quot;</span>, pi, *pi);</span><br><span class="line">    <span class="built_in">free</span>(pi);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;address: %p, value: %d.\n&quot;</span>, pi, *pi);</span><br><span class="line">&#125;</span><br><span class="line">===</span><br><span class="line">address: <span class="number">0xaaab1e1eb2a0</span>, value: <span class="number">100.</span></span><br><span class="line">address: <span class="number">0xaaab1e1eb2a0</span>, value: <span class="number">0.</span></span><br></pre></td></tr></table></figure><blockquote><p>如果指针<strong>没有被设置</strong>为<code>NULL</code>,如果同时不小心<strong>再次被</strong><code>free</code>,则会出现<code>double free</code>的<code>core dumped</code>;<strong>如下</strong>:</p></blockquote></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">*pi = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;address: %p, value: %3d.\n&quot;</span>, pi, *pi);</span><br><span class="line"><span class="built_in">free</span>(pi);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;address: %p, value: %d.\n&quot;</span>, pi, *pi);</span><br><span class="line"><span class="built_in">free</span>(pi);</span><br><span class="line">===</span><br><span class="line">address: <span class="number">0xaaaada6ac2a0</span>, value: <span class="number">100.</span></span><br><span class="line">address: <span class="number">0xaaaada6ac2a0</span>, value: <span class="number">0.</span></span><br><span class="line"><span class="built_in">free</span>(): <span class="keyword">double</span> <span class="built_in">free</span> detected in tcache <span class="number">2</span></span><br><span class="line">[<span class="number">1</span>]    <span class="number">20014</span> <span class="built_in">abort</span> (core dumped)  ./draft</span><br></pre></td></tr></table></figure><blockquote><p><code>double free</code>的详细说明<strong>参考</strong>参考链接[2]</p></blockquote><h1 id="带颜色输出"><a href="#带颜色输出" class="headerlink" title="带颜色输出"></a>带颜色输出</h1><p><code>c</code>语言的<code>printf</code>和<code>shell</code>的<code>echo</code>和<code>printf</code>都可以遵循以下规则输出<br><img src="/images/color_print.png" alt="颜色输出"></p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">背景/字体颜色</th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">背景颜色字符3</td><td style="text-align:center">字体颜色字符4</td><td style="text-align:center">颜色</td><td style="text-align:center">1,2,6</td><td style="text-align:center">意义</td></tr><tr><td style="text-align:center">40</td><td style="text-align:center">30</td><td style="text-align:center">黑</td><td style="text-align:center"><code>\033[0m</code></td><td style="text-align:center">关闭所有属性</td></tr><tr><td style="text-align:center">41</td><td style="text-align:center">31</td><td style="text-align:center">红</td><td style="text-align:center"><code>\033[1m</code></td><td style="text-align:center">设置高亮度</td></tr><tr><td style="text-align:center">42</td><td style="text-align:center">32</td><td style="text-align:center">绿</td><td style="text-align:center"><code>\033[4m</code></td><td style="text-align:center">下划线</td></tr><tr><td style="text-align:center">43</td><td style="text-align:center">33</td><td style="text-align:center">黄</td><td style="text-align:center"><code>\033[5m</code></td><td style="text-align:center">闪烁</td></tr><tr><td style="text-align:center">44</td><td style="text-align:center">34</td><td style="text-align:center">蓝</td><td style="text-align:center"><code>\033[7m</code></td><td style="text-align:center">反显</td></tr><tr><td style="text-align:center">45</td><td style="text-align:center">35</td><td style="text-align:center">蓝</td><td style="text-align:center"><code>\033[8m</code></td><td style="text-align:center">消隐</td></tr><tr><td style="text-align:center">46</td><td style="text-align:center">36</td><td style="text-align:center">深蓝</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">47</td><td style="text-align:center">37</td><td style="text-align:center">白色</td><td style="text-align:center"></td></tr></tbody></table></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  build <span class="built_in">echo</span> -n <span class="string">&quot;\033[5m\033[4m\033[40;34mhello,world\033[0m\n&quot;</span></span><br><span class="line">hello,world</span><br><span class="line">➜  build <span class="built_in">printf</span> <span class="string">&quot;\033[5m\033[4m\033[40;34mhello,world\033[0m\n&quot;</span></span><br><span class="line">hello,world</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[5m\033[4m\033[40;34mhello,world\033[0m\n&quot;</span>);</span><br></pre></td></tr></table></figure><h1 id="变参数"><a href="#变参数" class="headerlink" title="变参数"></a>变参数</h1><h2 id="变参数资料"><a href="#变参数资料" class="headerlink" title="变参数资料"></a>变参数资料</h2><p><a href="https://blog.csdn.net/f110300641/article/details/83822290">参考1-va_list、va_start、va_arg、va_end使用说明</a><br><a href="https://www.cnblogs.com/justinzhang/archive/2011/09/29/2195969.html">参考2-va_list/va_start/va_arg/va_end深入分析</a></p><h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><ul><li><strong>函数/参数说明</strong><ul><li><code>va_list list</code>用作定位函数的参数</li><li><code>va_start(list, format);</code>初始化<code>list</code>,同时让<code>list</code>指向当前变参数的第一个参数(即”this”)</li><li><code>va_arg(list, char *);</code>找到了第一个参数是<code>char *</code>类型,取出第一个参数,并指向下一个变参数;</li><li><code>va_end(list);</code>释放指针类型<code>list</code>(等同于<code>ap = (va_list)0</code>)</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">var_test</span><span class="params">(<span class="keyword">char</span> *format, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list <span class="built_in">list</span>;</span><br><span class="line">    va_start(<span class="built_in">list</span>, format);</span><br><span class="line">    <span class="keyword">char</span> *ch;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%s]\n&quot;</span>, format);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ch = va_arg(<span class="built_in">list</span>, <span class="keyword">char</span> *);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(ch, <span class="string">&quot;&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%s]\n&quot;</span>, ch);</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    var_test(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;this&quot;</span>, <span class="string">&quot;is&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变参数示例"><a href="#变参数示例" class="headerlink" title="变参数示例"></a>变参数示例</h2><ul><li><code>printf</code>实现和自定义日志<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Log_Level</span>&#123;</span></span><br><span class="line">    I,</span><br><span class="line">    E,</span><br><span class="line">    W</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Log</span><span class="params">(<span class="keyword">int</span> log_level, ...)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (log_level)&#123;</span><br><span class="line">    <span class="keyword">case</span> I:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[ \033[1m\033[32mI\033[0m ] : &quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> E:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[ \033[1m\033[31mE\033[0m ] : &quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> W:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[ \033[1m\033[33mW\033[0m ] : &quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args, log_level); <span class="comment">// 初始化 args</span></span><br><span class="line">    <span class="keyword">char</span> *format;</span><br><span class="line">    format = va_arg(args, <span class="keyword">char</span> *);<span class="comment">// 获取变参数的第一个参数</span></span><br><span class="line">    <span class="built_in">vprintf</span>(format, args);</span><br><span class="line">    va_end(args);<span class="comment">// 置空 args</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span> *format, ...)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args, format);</span><br><span class="line">    result = <span class="built_in">vprintf</span>(format, args);</span><br><span class="line">    va_end(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    print(<span class="string">&quot;%-s :%-s\n&quot;</span>, <span class="string">&quot;level&quot;</span>, <span class="string">&quot;       content&quot;</span>);</span><br><span class="line">    Log(I, <span class="string">&quot;%-5s, hello world\n&quot;</span>, <span class="string">&quot;Info&quot;</span>);</span><br><span class="line">    Log(E, <span class="string">&quot;%-5s, hello world\n&quot;</span>, <span class="string">&quot;Error&quot;</span>);</span><br><span class="line">    Log(W, <span class="string">&quot;%-5s, hello world\n&quot;</span>, <span class="string">&quot;Warn&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/images/myCustomLog.png" alt="自定义日志"></li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1].<a href="https://blog.csdn.net/qq_44519484/article/details/114242544?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.no_search_link&amp;spm=1001.2101.3001.4242">printf打印彩色字符，还能闪烁！</a><br>[2].<a href="http://d0m021ng.github.io/2017/02/24/PWN/Linux%E5%A0%86%E6%BC%8F%E6%B4%9E%E4%B9%8BDouble-free/">Linux堆漏洞之Double free</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux系统编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C, Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSON</title>
      <link href="/2021/09/20/JSON/"/>
      <url>/2021/09/20/JSON/</url>
      
        <content type="html"><![CDATA[<p>JSON(<code>JavaScrip Object Notation</code>) 是一种<code>轻量级的数据交换格式</code>。它基于 <code>ECMAScript</code> (欧洲计算机协会制定的 js 规范) 的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。</p><p>关于上面的描述可以精简为一句话：<code>Json 是一种数据格式，和语言无关，在什么语言中都可以使用 Json</code>。基于这种通用的数据格式，一般处理两方面的任务：</p><p>组织数据（数据序列化），用于数据的网络传输<br>组织数据（数据序列化），写磁盘文件实现数据的持久化存储（一般以<code>.json</code> 作为文件后缀）<br>Json 中主要有两种数据格式：Json 数组和 Json 对象，并且这两种格式可以交叉嵌套使用，下面依次介绍下这两种数据格式：</p><h1 id="Json-数组"><a href="#Json-数组" class="headerlink" title="Json 数组"></a>Json 数组</h1><p>Json 数组使用 [] 表示，[] 里边是元素，元素和元素之间使用逗号间隔，最后一个元素后边没有逗号，一个 Json 数组中支持同时存在多种不同类型的成员，包括：<code>整形</code>、 <code>浮点</code>、 <code>字符串</code>、 <code>布尔类型</code>、 json数组、 <code>json对象</code>、 <code>空值-null</code>。由此可见 <code>Json</code> 数组比起 <code>C/C++</code> 数组要灵活很多。</p><ul><li><p>Json 数组中的元素数据类型一致</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整形</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="comment">// 字符串</span></span><br><span class="line">[<span class="string">&quot;luffy&quot;</span>, <span class="string">&quot;sanji&quot;</span>, <span class="string">&quot;zoro&quot;</span>, <span class="string">&quot;nami&quot;</span>, <span class="string">&quot;robin&quot;</span>]</span><br></pre></td></tr></table></figure></li><li><p>Json 数组中的元素数据类型不一致</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">12</span>, <span class="number">13.34</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="string">&quot;hello,world&quot;</span>, <span class="literal">null</span>]</span><br></pre></td></tr></table></figure></li><li><p>Json 数组中的数组嵌套使用</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    [<span class="string">&quot;cat&quot;</span>, <span class="string">&quot;dog&quot;</span>, <span class="string">&quot;panda&quot;</span>, <span class="string">&quot;beer&quot;</span>, <span class="string">&quot;rabbit&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>, <span class="string">&quot;天津&quot;</span>, <span class="string">&quot;重庆&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;luffy&quot;</span>, <span class="string">&quot;boy&quot;</span>, <span class="number">19</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>Json 数组和对象嵌套使用</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;luffy&quot;</span>:&#123;</span><br><span class="line">            <span class="attr">&quot;age&quot;</span>:<span class="number">19</span>,</span><br><span class="line">            <span class="attr">&quot;father&quot;</span>:<span class="string">&quot;Monkey·D·Dragon&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;grandpa&quot;</span>:<span class="string">&quot;Monkey D Garp&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;brother1&quot;</span>:<span class="string">&quot;Portgas D Ace&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;brother2&quot;</span>:<span class="string">&quot;Sabo&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul><h1 id="Json-对象"><a href="#Json-对象" class="headerlink" title="Json 对象"></a>Json 对象</h1><p>Json 对象使用 {} 来描述，每个 Json 对象中可以存储若干个元素，每一个元素对应一个键值对（key：value 结构），元素和元素之间使用逗号间隔，最后一个元素后边没有逗号。对于每个元素中的键值对有以下细节需要注意：</p><p>键值（key）必须是字符串，位于同一层级的键值不要重复（因为是通过键值取出对应的 value 值）<br>value 值的类型是可选的，可根据实际需求指定，可用类型包括：<code>整形</code>、 <code>浮点</code>、 <code>字符串</code>、 <code>布尔类型</code>、 <code>json数组</code>、 <code>json对象</code>、 <code>空值-null</code>。<br>使用 Json 对象描述一个人的信息:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;Name&quot;</span>:<span class="string">&quot;Ace&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;Sex&quot;</span>:<span class="string">&quot;man&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;Age&quot;</span>:<span class="number">20</span>,</span><br><span class="line">    <span class="attr">&quot;Family&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;Father&quot;</span>:<span class="string">&quot;Gol·D·Roger&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;Mother&quot;</span>:<span class="string">&quot;Portgas·D·Rouge&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;Brother&quot;</span>:[<span class="string">&quot;Sabo&quot;</span>, <span class="string">&quot;Monkey D. Luffy&quot;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;IsAlive&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;Comment&quot;</span>:<span class="string">&quot;yyds&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>通过上面的介绍可用看到，Json 的结构虽然简单，但是进行嵌套之后就可以描述很复杂的事情，在项目开发过程中往往需要我们根据实际需求自己定义 Json 格式用来存储项目数据。</p><p>另外，如果需要将 Json 数据持久化到磁盘文件中，需要注意一个问题：<code>在一个 Json 文件中只能有一个 Json 数组或者 Json 对象的根节点，不允许同时存储多个并列的根节点</code>。下面举例说明：</p><ul><li>错误的写法<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.json</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>:<span class="string">&quot;luffy&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;age&quot;</span>:<span class="number">19</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;user&quot;</span>:<span class="string">&quot;ace&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;passwd&quot;</span>:<span class="string">&quot;123456&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>错误原因：<code>在一个 Json 文件中有两个并列的 Json 根节点（并列包含 Json 对象和 Json 对象、Json 对象和 Json 数组、Json 数组和 Json 数组），根节点只能有一个。</code></li><li>正确的写法<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.json</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;Name&quot;</span>:<span class="string">&quot;Ace&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;Sex&quot;</span>:<span class="string">&quot;man&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;Age&quot;</span>:<span class="number">20</span>,</span><br><span class="line">    <span class="attr">&quot;Family&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;Father&quot;</span>:<span class="string">&quot;Gol·D·Roger&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;Mother&quot;</span>:<span class="string">&quot;Portgas·D·Rouge&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;Brother&quot;</span>:[<span class="string">&quot;Sabo&quot;</span>, <span class="string">&quot;Monkey D. Luffy&quot;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;IsAlive&quot;</span>:<span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;Comment&quot;</span>:<span class="string">&quot;yyds&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><code>在上面的例子中通过Json对象以及Json数组的嵌套描述了一个人的身份信息，并且根节点只有一个就是Json对象，如果还需要使用Json数组或者Json对象描述其他信息，需要将这些信息写入到其他文件中，不要和这个Json对象并列写入到同一个文件里边，切记！！！</code></p>]]></content>
      
      
      <categories>
          
          <category> cJSON </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JSON </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cJSON-01-cJSON的使用</title>
      <link href="/2021/09/20/cJSON-01-cJSON%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2021/09/20/cJSON-01-cJSON%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>cJSON是一个轻量级的使用c语言编写的JSON解析器;<br>本系列笔记以<a href="https://github.com/DaveGamble/cJSON">cJSON开源项目</a>为<code>JSON</code>解析库; <code>JSON</code>数据格式参考<a class="btn-beautify button--animated outline green larger" href="/2021/09/20/JSON/" title="JSON"><i class="far fa-hand-point-right"></i><span>JSON</span></a></p><h1 id="cJSON结构体"><a href="#cJSON结构体" class="headerlink" title="cJSON结构体"></a>cJSON结构体</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cJSON</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cJSON</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cJSON</span> *<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cJSON</span> *<span class="title">child</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *valuestring;</span><br><span class="line">    <span class="keyword">int</span> valueint;</span><br><span class="line">    <span class="keyword">double</span> valuedouble;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *<span class="built_in">string</span>;</span><br><span class="line">&#125; cJSON;</span><br></pre></td></tr></table></figure><h1 id="视频数据类型"><a href="#视频数据类型" class="headerlink" title="视频数据类型"></a>视频数据类型</h1><p>以如下视频数据类型为示例讲解一个简单的<code>cJSON</code>的使用与部分函数的实现过程<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Jack (\&quot;Bee\&quot;) Nimble&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;format&quot;</span>:       &#123;</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;rect&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;width&quot;</span>:        <span class="number">1920</span>,</span><br><span class="line">                <span class="attr">&quot;height&quot;</span>:       <span class="number">1080</span>,</span><br><span class="line">                <span class="attr">&quot;interlace&quot;</span>:    <span class="literal">false</span>,</span><br><span class="line">                <span class="attr">&quot;frame rate&quot;</span>:   <span class="number">24</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="cJSON-CreateObject"><a href="#cJSON-CreateObject" class="headerlink" title="cJSON_CreateObject"></a>cJSON_CreateObject</h2><p><code>cJSON_CreateObject</code>创建了一个<code>json</code>对象<code>root</code><br>1.函数<code>cJSON_New_Item</code>给<code>cJSON</code>类型分配内存, 并初始化为0<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CJSON_PUBLIC(cJSON *)</span><br><span class="line">cJSON_CreateObject(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cJSON *item = cJSON_New_Item(&amp;global_hooks);</span><br><span class="line">    <span class="keyword">if</span> (item)&#123;</span><br><span class="line">        item-&gt;type = cJSON_Object;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="value"><a href="#value" class="headerlink" title="value"></a>value</h2><p><code>&quot;name&quot;: &quot;Jack (\&quot;Bee\&quot;) Nimble&quot;</code>是一个<code>cJSON</code>数据类型, 使用<code>cJSON_CreateString(&quot;Jack (\&quot;Bee\&quot;) Nimble&quot;)</code>创建一个<code>cJSON</code>类型的数据;<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CJSON_PUBLIC(cJSON *)</span><br><span class="line">cJSON_CreateString(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="built_in">string</span>)&#123;</span><br><span class="line">    cJSON *item = cJSON_New_Item(&amp;global_hooks);</span><br><span class="line">    <span class="keyword">if</span> (item)&#123;</span><br><span class="line">        item-&gt;type = cJSON_String;</span><br><span class="line">        item-&gt;valuestring = (<span class="keyword">char</span> *)cJSON_strdup((<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *)<span class="built_in">string</span>, &amp;global_hooks);</span><br><span class="line">        <span class="keyword">if</span> (!item-&gt;valuestring)&#123;</span><br><span class="line">            cJSON_Delete(item);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>1.函数<code>cJSON_New_Item</code>给<code>cJSON</code>类型分配内存, 并初始化为0<br>2.指定<code>type</code>为<code>cJSON_String</code><br>3.函数<code>cJSON_strdup</code>为指针<code>valuestring</code>分配内存, 并把<code>string</code>的字符拷贝给<code>valuestring</code><br>4.函数返回<code>cJSON</code>类型的指针<code>item</code></p><blockquote><p>此时<code>item</code>的<code>valuestring</code>和<code>type</code>已被初始化, 但键<code>key[string]</code>还没有初始化;即仅仅是<code>&quot;Jack (\&quot;Bee\&quot;) Nimble&quot;</code></p></blockquote><h2 id="绑定到root"><a href="#绑定到root" class="headerlink" title="绑定到root"></a>绑定到root</h2><p><code>cJSON_CreateString(&quot;Jack (\&quot;Bee\&quot;) Nimble&quot;)</code>创建了一对<code>key-value</code>(还没有设置<code>key</code>), 该<code>cJSON*</code>以<code>child</code>的身份存在于<code>root</code>中;</p><ul><li><p>调用<code>add_item_to_array</code>之前, 为<code>item</code>设定<code>key</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">cJSON_AddItemToObject(root, <span class="string">&quot;name&quot;</span>, cJSON_CreateString(<span class="string">&quot;Jack (\&quot;Bee\&quot;) Nimble&quot;</span>));</span><br><span class="line"></span><br><span class="line">CJSON_PUBLIC(cJSON_bool)</span><br><span class="line">cJSON_AddItemToObject(cJSON *object, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="built_in">string</span>, cJSON *item)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> add_item_to_object(object, <span class="built_in">string</span>, item, &amp;global_hooks, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> cJSON_bool <span class="title">add_item_to_object</span><span class="params">(cJSON *<span class="keyword">const</span> object, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> <span class="built_in">string</span>, cJSON *<span class="keyword">const</span> item, \</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> internal_hooks *<span class="keyword">const</span> hooks, <span class="keyword">const</span> cJSON_bool constant_key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *new_key = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> new_type = cJSON_Invalid;</span><br><span class="line">    <span class="comment">// 为key分配内存</span></span><br><span class="line">    new_key = (<span class="keyword">char</span> *)cJSON_strdup((<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *)<span class="built_in">string</span>, hooks);</span><br><span class="line"></span><br><span class="line">    new_type = item-&gt;type &amp; ~cJSON_StringIsConst;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(item-&gt;type &amp; cJSON_StringIsConst) &amp;&amp; (item-&gt;<span class="built_in">string</span> != <span class="literal">NULL</span>))&#123;</span><br><span class="line">        hooks-&gt;deallocate(item-&gt;<span class="built_in">string</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    item-&gt;<span class="built_in">string</span> = new_key;</span><br><span class="line">    item-&gt;type = new_type;</span><br><span class="line">    <span class="keyword">return</span> add_item_to_array(object, item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>add_item_to_array</code><br>** <code>child</code>为空<br>当<code>child</code>为空时(第一次调用), 如图-<code>add_item_to_array_first</code>所示, 调用前灰色部分为空; 调用后非空</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> cJSON_bool <span class="title">add_item_to_array</span><span class="params">(cJSON *<span class="built_in">array</span>, cJSON *item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cJSON *child = <span class="literal">NULL</span>;</span><br><span class="line">    child = <span class="built_in">array</span>-&gt;child;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">/* list is empty, start new one */</span></span><br><span class="line">        <span class="built_in">array</span>-&gt;child = item;</span><br><span class="line">        item-&gt;prev = item;</span><br><span class="line">        item-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">/* append to the end */</span></span><br><span class="line">        <span class="keyword">if</span> (child-&gt;prev)&#123;</span><br><span class="line">            suffix_object(child-&gt;prev, item);</span><br><span class="line">            <span class="built_in">array</span>-&gt;child-&gt;prev = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/add_item_to_array_first.png" alt="add_item_to_array_first"><br>** <code>child</code>非空<br>当<code>child</code>为非空时(非第一次调用), 如图<code>add_item_to_array_no_first</code>所示, 使用<code>array</code>的第一个<code>item</code>子节点的<code>prev</code>指针来定位最后一个<code>item</code>子节点(如红色指向所示), 形成双向链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">suffix_object</span><span class="params">(cJSON *prev, cJSON *item)</span></span>&#123;</span><br><span class="line">    prev-&gt;next = item;</span><br><span class="line">    item-&gt;prev = prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/add_item_to_array_no_first.png" alt="add_item_to_array_no_first"></p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>自此已构建如下所示最简单的<code>JSON</code>数据<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Jack (\&quot;Bee\&quot;) Nimble&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> cJSON </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C, JSON </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake-01</title>
      <link href="/2021/09/20/CMake-01/"/>
      <url>/2021/09/20/CMake-01/</url>
      
        <content type="html"><![CDATA[<h1 id="常用的函数"><a href="#常用的函数" class="headerlink" title="常用的函数"></a>常用的函数</h1><h2 id="project"><a href="#project" class="headerlink" title="project"></a>project</h2><p>参考<a href="https://www.jianshu.com/p/cdd6e56c2422">Cmake命令之project介绍</a></p><h1 id="option"><a href="#option" class="headerlink" title="option"></a>option</h1><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">option</span>(&lt;option_variable&gt; <span class="string">&quot;help string describing option&quot;</span></span><br><span class="line">       [initial value])</span><br></pre></td></tr></table></figure><p><code>option</code>给用户提供<strong>打开</strong>或<strong>关闭</strong>的选项, 如果没有提供初始值, 则使用<code>OFF</code> </p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><ol><li>CMakeLists.txt<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">test</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span>(SWITCH_SUPPORT_ESP8266 <span class="string">&quot;option for support ESP8266 &quot;</span> <span class="keyword">OFF</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (SWITCH_SUPPORT_ESP8266)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;SWITCH_SUPORT_ESP8266 is ON.&quot;</span>)</span><br><span class="line"><span class="keyword">add_definitions</span>(-DSUPPORT_ESP8266)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;SWITCH_SUPPORT_ESP8266 is OFF.&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> ./main.c)</span><br></pre></td></tr></table></figure></li></ol><p>2.<code>main.c</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SUPPORT_ESP8266</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s has defined macro SUPPORT_ESP8266.\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s has not defined macro SUPPORT_ESP8266.\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p><p>3.编译与测试<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜  draft_ws mkdir build</span><br><span class="line">➜  draft_ws <span class="built_in">cd</span> build                            </span><br><span class="line">➜  build cmake -DSWITCH_SUPPORT_ESP8266=ON ..</span><br><span class="line">...</span><br><span class="line">-- SWITCH_SUPORT_ESP8266 is ON.</span><br><span class="line">...</span><br><span class="line">➜  build make       </span><br><span class="line">Scanning dependencies of target <span class="built_in">test</span></span><br><span class="line">[ 50%] Building C object CMakeFiles/test.dir/main.c.o</span><br><span class="line">[100%] Linking C executable <span class="built_in">test</span></span><br><span class="line">[100%] Built target <span class="built_in">test</span></span><br><span class="line">➜  build ./<span class="built_in">test</span> </span><br><span class="line">./<span class="built_in">test</span> has defined macro SUPPORT_ESP8266.</span><br></pre></td></tr></table></figure></p><h1 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h1><ul><li><p>启动对C11标准的支持</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_C_STANDARD <span class="number">11</span>)</span><br></pre></td></tr></table></figure></li><li><p>-Werror<br>遇到以下错误时, 取消编译选项<code>-Werror</code>; <code>-Werror</code>它要求<code>gcc</code>将所有的警告当成错误进行处理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/home/tangshp/Code_ws/cJSON/test.c:111:13: error: ‘create_objects’ defined but not used [-Werror=unused-function]</span><br><span class="line">  111 | static void create_objects(void)</span><br><span class="line">      |             ^~~~~~~~~~~~~~</span><br><span class="line">cc1: all warnings being treated as errors</span><br><span class="line">make[2]: *** [CMakeFiles/cJSON_test.dir/build.make:63: CMakeFiles/cJSON_test.dir/test.c.o] Error 1</span><br><span class="line">make[1]: *** [CMakeFiles/Makefile2:229: CMakeFiles/cJSON_test.dir/all] Error 2</span><br><span class="line">make: *** [Makefile:141: all] Error 2</span><br></pre></td></tr></table></figure></li><li><p>-Wall<br>使用<code>-Wall</code>打开<code>gcc</code>的所有警告</p></li></ul><h1 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h1><p><a href="https://cmake.org/cmake/help/latest/manual/cmake-variables.7.html"><code>CMake</code>官网</a>给出有哪些特殊变量;</p><h2 id="CMAKE-lt-LANG-gt-COMPILER-ID"><a href="#CMAKE-lt-LANG-gt-COMPILER-ID" class="headerlink" title="CMAKE_&lt;LANG&gt;_COMPILER_ID"></a><code>CMAKE_&lt;LANG&gt;_COMPILER_ID</code></h2><ul><li><code>CMAKE_&lt;LANG&gt;_COMPILER_ID</code>是编译器标识字符串, 被用来标识编译器类型;以下可能的取值<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Absoft = Absoft Fortran (absoft.com)</span><br><span class="line">ADSP = Analog VisualDSP++ (analog.com)</span><br><span class="line">AppleClang = Apple Clang (apple.com)</span><br><span class="line">ARMCC = ARM Compiler (arm.com)</span><br><span class="line">ARMClang = ARM Compiler based <span class="keyword">on</span> Clang (arm.com)</span><br><span class="line">Bruce = Bruce C Compiler</span><br><span class="line">CCur = Concurrent Fortran (ccur.com)</span><br><span class="line">Clang = LLVM Clang (clang.llvm.org)</span><br><span class="line">Cray = Cray Compiler (cray.com)</span><br><span class="line">Embarcadero, Borland = Embarcadero (embarcadero.com)</span><br><span class="line">Flang = Flang LLVM Fortran Compiler</span><br><span class="line">Fujitsu = Fujitsu HPC compiler (Trad mode)</span><br><span class="line">FujitsuClang = Fujitsu HPC compiler (Clang mode)</span><br><span class="line">G95 = G95 Fortran (g95.org)</span><br><span class="line">GNU = GNU Compiler Collection (gcc.gnu.org)</span><br><span class="line">GHS = Green Hills Software (www.ghs.com)</span><br><span class="line">HP = Hewlett-Packard Compiler (hp.com)</span><br><span class="line">IAR = IAR Systems (iar.com)</span><br><span class="line">Intel = Intel Compiler (intel.com)</span><br><span class="line">IntelLLVM = Intel LLVM-Based Compiler (intel.com)</span><br><span class="line">MSVC = Microsoft Visual Studio (microsoft.com)</span><br><span class="line">NVHPC = NVIDIA HPC SDK Compiler (nvidia.com)</span><br><span class="line">NVIDIA = NVIDIA CUDA Compiler (nvidia.com)</span><br><span class="line">OpenWatcom = Open Watcom (openwatcom.org)</span><br><span class="line">PGI = The Portland Group (pgroup.com)</span><br><span class="line">PathScale = PathScale (pathscale.com)</span><br><span class="line">SDCC = Small Device C Compiler (sdcc.sourceforge.net)</span><br><span class="line">SunPro = Oracle Solaris Studio (oracle.com)</span><br><span class="line">TI = Texas Instruments (ti.com)</span><br><span class="line">TinyCC = Tiny C Compiler (tinycc.org)</span><br><span class="line">XL, VisualAge, zOS = IBM XL (ibm.com)</span><br><span class="line">XLClang = IBM Clang-based XL (ibm.com)</span><br></pre></td></tr></table></figure></li><li>示例<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="string">&quot;$&#123;CMAKE_C_COMPILER_ID&#125;&quot;</span> <span class="keyword">STREQUAL</span> <span class="string">&quot;Clang&quot;</span>) <span class="keyword">OR</span> (<span class="string">&quot;$&#123;CMAKE_C_COMPILER_ID&#125;&quot;</span> <span class="keyword">STREQUAL</span> <span class="string">&quot;GNU&quot;</span>))</span><br><span class="line">...</span><br><span class="line"><span class="keyword">elseif</span>(<span class="string">&quot;$&#123;CMAKE_C_COMPILER_ID&#125;&quot;</span> <span class="keyword">STREQUAL</span> <span class="string">&quot;MSVC&quot;</span>)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure></li></ul><h2 id="make命令cans"><a href="#make命令cans" class="headerlink" title="make命令cans"></a>make命令cans</h2><h3 id="make-VERBOSE-1"><a href="#make-VERBOSE-1" class="headerlink" title="make VERBOSE=1"></a>make VERBOSE=1</h3><p>查看编译细节 </p>]]></content>
      
      
      <categories>
          
          <category> CMake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>googletest-04</title>
      <link href="/2021/09/14/googletest-04/"/>
      <url>/2021/09/14/googletest-04/</url>
      
        <content type="html"><![CDATA[<h1 id="框架说明"><a href="#框架说明" class="headerlink" title="框架说明"></a>框架说明</h1><ul><li>由于<code>TEST_F</code>的测试案例名必须是一个继承<code>testing::Test</code>的类的类名; 所以为了有效组织测试, 公共测试功能模块在类<code>A</code>中集中实现, 使用派生类<code>B</code>来测试测试用例</li></ul><h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><blockquote><p>一个测试场景是需要考量每个测试用时是否都是小于5s, 大于5s被认为测试失败; 该功能在一系列测试案例中被使用; 所以定义一个类<code>QuickTest</code>来继承<code>testing::Test</code>; 之后在以<code>QuickTest</code>为父类, 派生出两个用于测试的类<code>IntegerFunctionTest</code>和<code>QueueTest</code></p></blockquote><p><img src="/images/deriving.png" alt="派生关系"></p><ul><li><code>IntegerFunctionTest</code>中没有实现<code>SetUp</code>和<code>TearDown</code></li><li><code>QueueTest</code>实现了<code>SetUp</code>, 必须显示调用<code>QuickTest::SetUp();</code>, 否则<code>start_time</code>得不到更新</li><li><code>EXPECT_TRUE(end_time - start_time_ &lt;= 5)</code>返回一个输出对象</li></ul><h1 id="源文件"><a href="#源文件" class="headerlink" title="源文件"></a>源文件</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;gtest/gtest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sample1.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sample3-inl.h&quot;</span></span></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuickTest</span> :</span> <span class="keyword">public</span> testing::Test &#123;</span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetUp</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;SetUp()===.\n&quot;</span>);</span><br><span class="line">    start_time_ = <span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">TearDown</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Gets the time when the test finishes</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">time_t</span> end_time = <span class="built_in">time</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">EXPECT_TRUE</span>(end_time - start_time_ &lt;= <span class="number">5</span>) &lt;&lt; <span class="string">&quot;The test took too long.&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The UTC time (in seconds) when the test starts</span></span><br><span class="line">  <span class="keyword">time_t</span> start_time_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntegerFunctionTest</span> :</span> <span class="keyword">public</span> QuickTest &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tests Factorial()</span></span><br><span class="line"><span class="built_in">TEST_F</span>(IntegerFunctionTest, Factorial) &#123;</span><br><span class="line">  <span class="comment">// Tests factorial of negative numbers.</span></span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(<span class="number">1</span>, <span class="built_in">Factorial</span>(<span class="number">-5</span>));</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(<span class="number">1</span>, <span class="built_in">Factorial</span>(<span class="number">-1</span>));</span><br><span class="line">  <span class="built_in">EXPECT_GT</span>(<span class="built_in">Factorial</span>(<span class="number">-10</span>), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tests factorial of 0.</span></span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(<span class="number">1</span>, <span class="built_in">Factorial</span>(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tests factorial of positive numbers.</span></span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(<span class="number">1</span>, <span class="built_in">Factorial</span>(<span class="number">1</span>));</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(<span class="number">2</span>, <span class="built_in">Factorial</span>(<span class="number">2</span>));</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(<span class="number">6</span>, <span class="built_in">Factorial</span>(<span class="number">3</span>));</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(<span class="number">40320</span>, <span class="built_in">Factorial</span>(<span class="number">8</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tests IsPrime()</span></span><br><span class="line"><span class="built_in">TEST_F</span>(IntegerFunctionTest, IsPrime) &#123;</span><br><span class="line">  <span class="comment">// Tests negative input.</span></span><br><span class="line">  <span class="built_in">EXPECT_FALSE</span>(<span class="built_in">IsPrime</span>(<span class="number">-1</span>));</span><br><span class="line">  <span class="built_in">EXPECT_FALSE</span>(<span class="built_in">IsPrime</span>(<span class="number">-2</span>));</span><br><span class="line">  <span class="built_in">EXPECT_FALSE</span>(<span class="built_in">IsPrime</span>(INT_MIN));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tests some trivial cases.</span></span><br><span class="line">  <span class="built_in">EXPECT_FALSE</span>(<span class="built_in">IsPrime</span>(<span class="number">0</span>));</span><br><span class="line">  <span class="built_in">EXPECT_FALSE</span>(<span class="built_in">IsPrime</span>(<span class="number">1</span>));</span><br><span class="line">  <span class="built_in">EXPECT_TRUE</span>(<span class="built_in">IsPrime</span>(<span class="number">2</span>));</span><br><span class="line">  <span class="built_in">EXPECT_TRUE</span>(<span class="built_in">IsPrime</span>(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tests positive input.</span></span><br><span class="line">  <span class="built_in">EXPECT_FALSE</span>(<span class="built_in">IsPrime</span>(<span class="number">4</span>));</span><br><span class="line">  <span class="built_in">EXPECT_TRUE</span>(<span class="built_in">IsPrime</span>(<span class="number">5</span>));</span><br><span class="line">  <span class="built_in">EXPECT_FALSE</span>(<span class="built_in">IsPrime</span>(<span class="number">6</span>));</span><br><span class="line">  <span class="built_in">EXPECT_TRUE</span>(<span class="built_in">IsPrime</span>(<span class="number">23</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueueTest</span> :</span> <span class="keyword">public</span> QuickTest &#123;</span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetUp</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 需要显示调用QuickTest::SetUp()</span></span><br><span class="line">    QuickTest::<span class="built_in">SetUp</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Second, some additional setup for this fixture.</span></span><br><span class="line">    q1_.<span class="built_in">Enqueue</span>(<span class="number">1</span>);</span><br><span class="line">    q2_.<span class="built_in">Enqueue</span>(<span class="number">2</span>);</span><br><span class="line">    q2_.<span class="built_in">Enqueue</span>(<span class="number">3</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// virtual void TearDown() &#123;</span></span><br><span class="line">  <span class="comment">//   QuickTest::TearDown();</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">  Queue&lt;<span class="keyword">int</span>&gt; q0_;</span><br><span class="line">  Queue&lt;<span class="keyword">int</span>&gt; q1_;</span><br><span class="line">  Queue&lt;<span class="keyword">int</span>&gt; q2_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now, let&#x27;s write tests using the QueueTest fixture.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Tests the default constructor.</span></span><br><span class="line"><span class="built_in">TEST_F</span>(QueueTest, DefaultConstructor) &#123; <span class="built_in">EXPECT_EQ</span>(<span class="number">0u</span>, q0_.<span class="built_in">Size</span>()); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tests Dequeue().</span></span><br><span class="line"><span class="built_in">TEST_F</span>(QueueTest, Dequeue) &#123;</span><br><span class="line">  <span class="keyword">int</span>* n = q0_.<span class="built_in">Dequeue</span>();</span><br><span class="line">  <span class="built_in">EXPECT_TRUE</span>(n == <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  n = q1_.<span class="built_in">Dequeue</span>();</span><br><span class="line">  <span class="built_in">EXPECT_TRUE</span>(n != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(<span class="number">1</span>, *n);</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(<span class="number">0u</span>, q1_.<span class="built_in">Size</span>());</span><br><span class="line">  <span class="keyword">delete</span> n;</span><br><span class="line"></span><br><span class="line">  n = q2_.<span class="built_in">Dequeue</span>();</span><br><span class="line">  <span class="built_in">EXPECT_TRUE</span>(n != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(<span class="number">2</span>, *n);</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(<span class="number">1u</span>, q2_.<span class="built_in">Size</span>());</span><br><span class="line">  <span class="keyword">delete</span> n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> googletest </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C, C++, 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>googletest-03</title>
      <link href="/2021/09/12/googletest-03/"/>
      <url>/2021/09/12/googletest-03/</url>
      
        <content type="html"><![CDATA[<h1 id="TEST-F-test-fixture"><a href="#TEST-F-test-fixture" class="headerlink" title="TEST_F(test fixture)"></a>TEST_F(<code>test fixture</code>)</h1><blockquote><p>1.<code>TEST_F</code>被使用在”很多测试使用共同的测试数据, 每次都需要相同初始化过程与清理过程”, 避免重复地初始化和清理过程<br>2.一个<code>TEST_F</code>不应该因为另一个测试<code>TEST_F</code>失败而失败<br>3.每个<code>TEST_F</code>都有新的数据复本, 不能期望将一个测试<code>TEST_F</code>修改的数据传递给另一个测试<code>TEST_F</code></p></blockquote><h2 id="TEST-F的使用"><a href="#TEST-F的使用" class="headerlink" title="TEST_F的使用"></a><code>TEST_F</code>的使用</h2><h3 id="继承类的定义"><a href="#继承类的定义" class="headerlink" title="继承类的定义"></a>继承类的定义</h3><blockquote><p>要使用<code>test fixture</code>需要定义一个派生<code>testing::Test</code>的<code>C++</code>类<code>XXXTest</code>, 具体参考类<code>QueueTestSmpl3</code>的定义</p><ul><li>在类<code>XXXTest</code>的定义中使用关键字<code>protected</code>, 使得能够被子类访问</li><li>每一个<code>TEST_F</code>被运行之<strong>前</strong>都会调用<code>virtual void SetUp()</code>, 可以在函数<code>virtual void SetUp()</code>中定义所有变量的初始化工作;如果不定义则会被跳过</li><li>每一个<code>TEST_F</code>被运行之<strong>后</strong>都会调用<code>virtual void TearDown()</code>, 所以可以在<code>virtual void TearDown()</code>中定义清理工作; 如果不定义则可以省略</li><li>还可以在类中定义其它的辅助测试的函数</li><li>在类<code>XXXTest</code>中声明哪些测试中需要用到的变量(Declares the variables your tests want to use.)</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueueTestSmpl3</span> :</span> <span class="keyword">public</span> testing::Test &#123;</span><br><span class="line"> <span class="keyword">protected</span>:  <span class="comment">// You should make the members protected s.t. they can be</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetUp</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    q1_.<span class="built_in">Enqueue</span>(<span class="number">1</span>);</span><br><span class="line">    q2_.<span class="built_in">Enqueue</span>(<span class="number">2</span>);</span><br><span class="line">    q2_.<span class="built_in">Enqueue</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;index :: %s::%d[local_index]\n&quot;</span>, __func__, local_index++);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">TearDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;TearDown~\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// A helper function that some test uses.</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Double</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span> * n; &#125;</span><br><span class="line">  <span class="comment">// A helper function for testing Queue::Map().</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">MapTester</span><span class="params">(<span class="keyword">const</span> Queue&lt;<span class="keyword">int</span>&gt;* q)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Creates a new queue, where each element is twice as big as the</span></span><br><span class="line">    <span class="comment">// corresponding one in q.</span></span><br><span class="line">    <span class="keyword">const</span> Queue&lt;<span class="keyword">int</span>&gt;* <span class="keyword">const</span> new_q = q-&gt;<span class="built_in">Map</span>(Double);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Verifies that the new queue has the same size as q.</span></span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(q-&gt;<span class="built_in">Size</span>(), new_q-&gt;<span class="built_in">Size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Verifies the relationship between the elements of the two queues.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> QueueNode&lt;<span class="keyword">int</span>&gt;*n1 = q-&gt;<span class="built_in">Head</span>(), *n2 = new_q-&gt;<span class="built_in">Head</span>();</span><br><span class="line">         n1 != <span class="literal">nullptr</span>; n1 = n1-&gt;<span class="built_in">next</span>(), n2 = n2-&gt;<span class="built_in">next</span>()) &#123;</span><br><span class="line">      <span class="built_in">EXPECT_EQ</span>(<span class="number">2</span> * n1-&gt;<span class="built_in">element</span>(), n2-&gt;<span class="built_in">element</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> new_q;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Queue&lt;<span class="keyword">int</span>&gt; q0_;</span><br><span class="line">  Queue&lt;<span class="keyword">int</span>&gt; q1_;</span><br><span class="line">  Queue&lt;<span class="keyword">int</span>&gt; q2_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="TEST-F测试函数的编写"><a href="#TEST-F测试函数的编写" class="headerlink" title="TEST_F测试函数的编写"></a><code>TEST_F</code>测试函数的编写</h3><blockquote><p><strong>测试案例名必须是之前定义的派生类名</strong>, 使得测试函数中能够使用之前定义的成员函数; 但测试名可以自定义</p><ul><li>可以把测试案例<code>TEST_F</code>当作类<code>QueueTestSmpl3</code>的成员方法一样使用其<strong>成员变量</strong>和<strong>成员方法</strong></li><li><code>EXPECT_TRUE(condition)</code></li><li><code>EXPECT_FALSE(condition)</code></li><li><code>ASSERT_TRUE(condition)</code></li><li><code>ASSERT_FALSE(condition)</code></li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;gtest/gtest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sample3-inl.h&quot;</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> local_index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"><span class="comment">// To use a test fixture, derive a class from testing::Test.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueueTestSmpl3</span> :</span> <span class="keyword">public</span> testing::Test &#123;</span><br><span class="line"> <span class="keyword">protected</span>:  <span class="comment">// You should make the members protected s.t. they can be</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetUp</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    q1_.<span class="built_in">Enqueue</span>(<span class="number">1</span>);</span><br><span class="line">    q2_.<span class="built_in">Enqueue</span>(<span class="number">2</span>);</span><br><span class="line">    q2_.<span class="built_in">Enqueue</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;index :: %s::%d[local_index]\n&quot;</span>, __func__, local_index++);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">TearDown</span><span class="params">()</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">&quot;TearDown~\n&quot;</span>); &#125;</span><br><span class="line">  <span class="comment">// A helper function that some test uses.</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Double</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span> * n; &#125;</span><br><span class="line">  <span class="comment">// A helper function for testing Queue::Map().</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">MapTester</span><span class="params">(<span class="keyword">const</span> Queue&lt;<span class="keyword">int</span>&gt;* q)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Creates a new queue, where each element is twice as big as the</span></span><br><span class="line">    <span class="comment">// corresponding one in q.</span></span><br><span class="line">    <span class="keyword">const</span> Queue&lt;<span class="keyword">int</span>&gt;* <span class="keyword">const</span> new_q = q-&gt;<span class="built_in">Map</span>(Double);</span><br><span class="line">    <span class="comment">// Verifies that the new queue has the same size as q.</span></span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(q-&gt;<span class="built_in">Size</span>(), new_q-&gt;<span class="built_in">Size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Verifies the relationship between the elements of the two queues.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> QueueNode&lt;<span class="keyword">int</span>&gt;*n1 = q-&gt;<span class="built_in">Head</span>(), *n2 = new_q-&gt;<span class="built_in">Head</span>();</span><br><span class="line">         n1 != <span class="literal">nullptr</span>; n1 = n1-&gt;<span class="built_in">next</span>(), n2 = n2-&gt;<span class="built_in">next</span>()) &#123;</span><br><span class="line">      <span class="built_in">EXPECT_EQ</span>(<span class="number">2</span> * n1-&gt;<span class="built_in">element</span>(), n2-&gt;<span class="built_in">element</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> new_q;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Declares the variables your tests want to use.</span></span><br><span class="line">  Queue&lt;<span class="keyword">int</span>&gt; q0_;</span><br><span class="line">  Queue&lt;<span class="keyword">int</span>&gt; q1_;</span><br><span class="line">  Queue&lt;<span class="keyword">int</span>&gt; q2_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Tests the default c&#x27;tor.</span></span><br><span class="line"><span class="built_in">TEST_F</span>(QueueTestSmpl3, DefaultConstructor) &#123;</span><br><span class="line">  <span class="comment">// You can access data in the test fixture here.</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;start[Change] ...\n&quot;</span>);</span><br><span class="line">  <span class="built_in">EXPECT_NE</span>(<span class="number">0u</span>, q0_.<span class="built_in">Size</span>());</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;finish.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tests Dequeue().</span></span><br><span class="line"><span class="built_in">TEST_F</span>(QueueTestSmpl3, Dequeue) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;start[Change] ...\n&quot;</span>);</span><br><span class="line">  <span class="keyword">int</span>* n = q0_.<span class="built_in">Dequeue</span>();</span><br><span class="line">  <span class="built_in">EXPECT_TRUE</span>(n == <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  n = q1_.<span class="built_in">Dequeue</span>();</span><br><span class="line">  <span class="built_in">ASSERT_FALSE</span>(n != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Remaining 4 compare.&quot;</span>);</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(<span class="number">1</span>, *n);</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(<span class="number">0u</span>, q1_.<span class="built_in">Size</span>());</span><br><span class="line">  <span class="keyword">delete</span> n;</span><br><span class="line"></span><br><span class="line">  n = q2_.<span class="built_in">Dequeue</span>();</span><br><span class="line">  <span class="built_in">ASSERT_TRUE</span>(n != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(<span class="number">2</span>, *n);</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(<span class="number">1u</span>, q2_.<span class="built_in">Size</span>());</span><br><span class="line">  <span class="keyword">delete</span> n;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;finish.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tests the Queue::Map() function.</span></span><br><span class="line"><span class="built_in">TEST_F</span>(QueueTestSmpl3, Map) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;start ...\n&quot;</span>);</span><br><span class="line">  <span class="built_in">MapTester</span>(&amp;q0_);</span><br><span class="line">  <span class="built_in">MapTester</span>(&amp;q1_);</span><br><span class="line">  <span class="built_in">MapTester</span>(&amp;q2_);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;finish.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="EXPECT与ASSERT的对比"><a href="#EXPECT与ASSERT的对比" class="headerlink" title="EXPECT与ASSERT的对比"></a>EXPECT与ASSERT的对比</h3><ul><li><code>EXPECT_XXX</code>测试失败后会继续执行前测试案例中的剩余测试语句; 而<code>ASSERT_XXX</code>测试失败后不会继续测试剩余的语句, 直接执行当前测试案例对应的<code>TearDown()</code>函数; 查看代码与测试结果可得该结论<br><img src="/images/EXPECT_ASSERT.png" alt="EXPECT_XXX与ASSERT_XXX的对比"></li></ul><h1 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h1><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS += -I ./samples </span><br><span class="line">CFLAGS += -I ./<span class="keyword">include</span></span><br><span class="line">LFLAGS +=  ../build/lib/libgtest.a  -lpthread </span><br><span class="line">BINPATH = <span class="string">&quot;./testBin/&quot;</span></span><br><span class="line">OBJS = $&#123;BINPATH&#125; $&#123;BINPATH&#125;sample3_unittest</span><br><span class="line"></span><br><span class="line">ALL : $&#123;OBJS&#125;</span><br><span class="line">echo <span class="string">&quot;generate &quot;</span>$&#123;BINPATH&#125;<span class="variable">$^</span></span><br><span class="line"></span><br><span class="line">$&#123;BINPATH&#125; :</span><br><span class="line">-mkdir <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line">$&#123;BINPATH&#125;sample3_unittest : ./samples/sample3_unittest.cc ./src/gtest_main.cc</span><br><span class="line">g++ $&#123;CFLAGS&#125;  <span class="variable">$^</span> $&#123;LFLAGS&#125;  -o <span class="variable">$@</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.PHONY : clean ALL</span><br><span class="line"></span><br><span class="line">clean :</span><br><span class="line">@rm -r $&#123;BINPATH&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> googletest </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C, C++, 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode的基本使用</title>
      <link href="/2021/09/12/vscode%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2021/09/12/vscode%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><div class="table-container"><table><thead><tr><th style="text-align:center">功能</th><th style="text-align:center">快捷键</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">光标回退</td><td style="text-align:center"><kbd>Alt</kbd> + <kbd>left</kbd></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">光标前进</td><td style="text-align:center"><kbd>Alt</kbd> + <kbd>right</kbd></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">头文件/源文件跳转</td><td style="text-align:center"><kbd>Alt</kbd> + <kbd>o</kbd></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><code>koroFileHeader</code>插件</td><td style="text-align:center"><kbd>Ctrl</kbd> + <kbd>win</kbd>     + <kbd>t</kbd></td><td style="text-align:center"><code>window</code>环境远程<code>vscode</code>用<code>ssh remote</code> 远程 <code>linux</code></td></tr></tbody></table></div><p><br><br></p><h1 id="C-C-插件"><a href="#C-C-插件" class="headerlink" title="C/C++插件"></a><code>C/C++</code>插件</h1><h2 id="C-C-插件代码标红"><a href="#C-C-插件代码标红" class="headerlink" title="C/C++插件代码标红"></a><code>C/C++</code>插件代码标红</h2><p><img src="/images/C_C++_red_line.png" alt="C/C++插件代码标红"></p><ul><li>打开:文件-&gt;首选项-&gt;设置</li><li>选择:<code>Enable</code>（开启）或者<code>Disable</code>（关闭）<br><img src="/images/C_C++_red_line_solve.png" alt></li></ul><p><br><br></p><h1 id="vscode中添加msys2-shell"><a href="#vscode中添加msys2-shell" class="headerlink" title="vscode中添加msys2 shell"></a><code>vscode</code>中添加<code>msys2 shell</code></h1><ul><li><p>下载<code>Shell launcher</code>插件</p></li><li><p>在<code>settings.json</code>中添加配置项<br><kbd>Ctrl</kbd> + <kbd>Shift</kbd>     + <kbd>p</kbd> 输入<code>setting.json</code>打开<code>settings.json</code>; 添加如下内容<br><img src="/images/setting_msys2.png" alt="setting"></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;shellLauncher.shells.windows&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;shell&quot;</span>: <span class="string">&quot;C:\\Windows\\System32\\cmd.exe&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;label&quot;</span>: <span class="string">&quot;cmd&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;shell&quot;</span>: <span class="string">&quot;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;label&quot;</span>: <span class="string">&quot;PowerShell&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;shell&quot;</span>: <span class="string">&quot;C:\\Program Files\\Git\\bin\\bash.exe&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;label&quot;</span>: <span class="string">&quot;Git bash&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;shell&quot;</span>: <span class="string">&quot;E:\\msys64\\usr\\bin\\bash.exe&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;label&quot;</span>: <span class="string">&quot;MSYS64&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;args&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;--login&quot;</span>,</span><br><span class="line">            <span class="string">&quot;-i&quot;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;env&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;MSYSTEM&quot;</span>: <span class="string">&quot;MINGW64&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;CHERE_INVOKING&quot;</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;MSYS2_PATH_TYPE&quot;</span>: <span class="string">&quot;inherit&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;shell&quot;</span>: <span class="string">&quot;C:\\Windows\\System32\\bash.exe&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;label&quot;</span>: <span class="string">&quot;WSL Bash&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">],</span><br></pre></td></tr></table></figure><blockquote><p>记得增加<code>arg</code>和<code>env</code>,否则会找不到<code>msys2</code>的工具链路径</p></blockquote></li><li><p>修改快捷键<br><img src="/images/shell_launcher_key.png" alt="修改快捷键"><br>键入<kbd>Ctrl</kbd> + <kbd>k</kbd>可以选择<code>shell</code><br><img src="/images/shell_launcher_K.png" alt="输入ctrl+k"></p></li></ul><p><code>vscode</code>中使用<code>msys2</code>参考<a href="https://zhuanlan.zhihu.com/p/115006022">在VS Code中集成MSYS2（2020年更新）</a></p><h1 id="VSCode调试STM32"><a href="#VSCode调试STM32" class="headerlink" title="VSCode调试STM32"></a>VSCode调试STM32</h1><h2 id="事项准备"><a href="#事项准备" class="headerlink" title="事项准备"></a>事项准备</h2><ul><li><code>ST-LINK</code>硬件<br><img src="/images/ST-LINK.png" width="212" position:absolute height="221" left="10px" top="10px"></li><li><strong>安装</strong><code>openocd-0.11.0-3</code>,并<strong>添加</strong>到<code>window</code>的<strong>高级/环境变量</strong>中</li><li><strong>安装</strong><code>Cortex-Debug</code>插件<br><img src="/images/cortex_debug.png" alt="cortex_debug"></li><li>使用<code>STM32CubeMX</code>配置<code>ST-Link</code><br><img src="/images/STM32_ST_LINK.png" alt="STM32_ST_LINK"></li></ul><h2 id="VSCode配置"><a href="#VSCode配置" class="headerlink" title="VSCode配置"></a>VSCode配置</h2><ul><li><strong>编译任务</strong><br><code>`.vscode\tasks.json</code><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;label&quot;</span>: <span class="string">&quot;Build&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;shell&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;make&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;args&quot;</span>: [],</span><br><span class="line">    <span class="attr">&quot;problemMatcher&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;$gcc&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;group&quot;</span>: <span class="string">&quot;build&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>编译+下载任务</strong><br><code>.vscode\tasks.json</code><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;label&quot;</span>: <span class="string">&quot;Build &amp; Update&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;shell&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;openocd&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;args&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;-f&quot;</span>,</span><br><span class="line">        <span class="string">&quot;E:/xpack-openocd-0.11.0-3/scripts/interface/stlink-v2.cfg&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-f&quot;</span>,</span><br><span class="line">        <span class="string">&quot;E:/xpack-openocd-0.11.0-3/scripts/target/stm32f1x.cfg&quot;</span>,</span><br><span class="line">        <span class="string">&quot;-c&quot;</span>,</span><br><span class="line">        <span class="string">&quot;program build/template_usart.elf verify reset exit&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;problemMatcher&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;$gcc&quot;</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;group&quot;</span>: <span class="string">&quot;build&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;dependsOn&quot;</span>: <span class="string">&quot;Build&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>调试</strong><br><code>.vscode\launch.json</code><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;workspaceRoot&#125;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;executable&quot;</span>: <span class="string">&quot;build/template_usart.elf&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Debug with OpenOCD&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;cortex-debug&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;servertype&quot;</span>: <span class="string">&quot;openocd&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;configFiles&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;E:/xpack-openocd-0.11.0-3/scripts/interface/stlink-v1.cfg&quot;</span>,</span><br><span class="line">                <span class="string">&quot;E:/xpack-openocd-0.11.0-3/scripts/target/stm32f1x.cfg&quot;</span>,</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;searchDir&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;runToEntryPoint&quot;</span>: <span class="string">&quot;main&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;showDevDebugOutput&quot;</span>: <span class="string">&quot;none&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;preLaunchTask&quot;</span>: <span class="string">&quot;Build &amp; Update&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调试过程"><a href="#调试过程" class="headerlink" title="调试过程"></a>调试过程</h2><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">  <iframe src="/videos/vscode_openocd_debug.mp4" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 78%; left: 0; top: 0;"> </iframe></div></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发环境 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>googletest-02</title>
      <link href="/2021/09/12/googletest-02/"/>
      <url>/2021/09/12/googletest-02/</url>
      
        <content type="html"><![CDATA[<h1 id="使用TEST测试C-类的成员函数"><a href="#使用TEST测试C-类的成员函数" class="headerlink" title="使用TEST测试C++类的成员函数"></a>使用TEST测试C++类的成员函数</h1><blockquote><p>字符串是否相等(其中<code>STRCASE</code>表明不区分大小写)</p></blockquote><ul><li><code>EXPECT_STREQ(s1, s2)</code></li><li><code>EXPECT_STRNE(s1, s2)</code></li><li><code>EXPECT_STRCASEEQ(s1, s2)</code> </li><li><code>EXPECT_STRCASENE(s1, s2)</code> </li></ul><h1 id="文件说明"><a href="#文件说明" class="headerlink" title="文件说明"></a>文件说明</h1><ul><li><p>头文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GOOGLETEST_SAMPLES_SAMPLE2_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GOOGLETEST_SAMPLES_SAMPLE2_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// A simple string class.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* c_string_;</span><br><span class="line">  <span class="keyword">const</span> MyString&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyString&amp; rhs);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Clones a 0-terminated C string, allocating memory using new.</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">CloneCString</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* a_c_string)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">////////////////////////////////////////////////////////////</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// C&#x27;tors</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// The default c&#x27;tor constructs a NULL string.</span></span><br><span class="line">  <span class="built_in">MyString</span>() : <span class="built_in">c_string_</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Constructs a MyString by cloning a 0-terminated C string.</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">MyString</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* a_c_string)</span> : c_string_(nullptr) &#123;</span></span><br><span class="line">    <span class="built_in">Set</span>(a_c_string);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy c&#x27;tor</span></span><br><span class="line">  <span class="built_in">MyString</span>(<span class="keyword">const</span> MyString&amp; string) : <span class="built_in">c_string_</span>(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">Set</span>(string.c_string_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">////////////////////////////////////////////////////////////</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// D&#x27;tor.  MyString is intended to be a final class, so the d&#x27;tor</span></span><br><span class="line">  <span class="comment">// doesn&#x27;t need to be virtual.</span></span><br><span class="line">  ~<span class="built_in">MyString</span>() &#123; <span class="keyword">delete</span>[] c_string_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Gets the 0-terminated C string this MyString object represents.</span></span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">c_string</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c_string_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">Length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c_string_ == <span class="literal">nullptr</span> ? <span class="number">0</span> : <span class="built_in">strlen</span>(c_string_); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Sets the 0-terminated C string this MyString object represents.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* c_string)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> </span></span><br></pre></td></tr></table></figure></li><li><p>源文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sample2.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="comment">// Clones a 0-terminated C string, allocating memory using new.</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">MyString::CloneCString</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* a_c_string)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a_c_string == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> len = <span class="built_in">strlen</span>(a_c_string);</span><br><span class="line">  <span class="keyword">char</span>* <span class="keyword">const</span> clone = <span class="keyword">new</span> <span class="keyword">char</span>[ len + <span class="number">1</span> ];</span><br><span class="line">  <span class="built_in">memcpy</span>(clone, a_c_string, len + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Sets the 0-terminated C string this MyString object</span></span><br><span class="line"><span class="comment">// represents.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyString::Set</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* a_c_string)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Makes sure this works when c_string == c_string_</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> temp = MyString::<span class="built_in">CloneCString</span>(a_c_string);</span><br><span class="line">  <span class="keyword">delete</span>[] c_string_;</span><br><span class="line">  c_string_ = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>测试函数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sample2.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;gtest/gtest.h&quot;</span></span></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"><span class="comment">// In this example, we test the MyString class (a simple string).</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Tests the default c&#x27;tor.</span></span><br><span class="line"><span class="built_in">TEST</span>(MyString, DefaultConstructor) &#123;</span><br><span class="line">  <span class="keyword">const</span> MyString s;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Asserts that s.c_string() returns NULL.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// &lt;TechnicalDetails&gt;</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// If we write NULL instead of</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//   static_cast&lt;const char *&gt;(NULL)</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// in this assertion, it will generate a warning on gcc 3.4.  The</span></span><br><span class="line">  <span class="comment">// reason is that EXPECT_EQ needs to know the types of its</span></span><br><span class="line">  <span class="comment">// arguments in order to print them when it fails.  Since NULL is</span></span><br><span class="line">  <span class="comment">// #defined as 0, the compiler will use the formatter function for</span></span><br><span class="line">  <span class="comment">// int to print it.  However, gcc thinks that NULL should be used as</span></span><br><span class="line">  <span class="comment">// a pointer, not an int, and therefore complains.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// The root of the problem is C++&#x27;s lack of distinction between the</span></span><br><span class="line">  <span class="comment">// integer number 0 and the null pointer constant.  Unfortunately,</span></span><br><span class="line">  <span class="comment">// we have to live with this fact.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// &lt;/TechnicalDetails&gt;</span></span><br><span class="line">  <span class="built_in">EXPECT_STREQ</span>(<span class="literal">nullptr</span>, s.<span class="built_in">c_string</span>());</span><br><span class="line"></span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(<span class="number">0u</span>, s.<span class="built_in">Length</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> kHelloString[] = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tests the c&#x27;tor that accepts a C string.</span></span><br><span class="line"><span class="built_in">TEST</span>(MyString, ConstructorFromCString) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> MyString <span class="title">s</span><span class="params">(kHelloString)</span></span>;</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(<span class="number">0</span>, <span class="built_in">strcmp</span>(s.<span class="built_in">c_string</span>(), kHelloString));</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(kHelloString)/<span class="built_in"><span class="keyword">sizeof</span></span>(kHelloString[<span class="number">0</span>]) - <span class="number">1</span>,</span><br><span class="line">            s.<span class="built_in">Length</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tests the copy c&#x27;tor.</span></span><br><span class="line"><span class="built_in">TEST</span>(MyString, CopyConstructor) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> MyString <span class="title">s1</span><span class="params">(kHelloString)</span></span>;</span><br><span class="line">  <span class="keyword">const</span> MyString s2 = s1;</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(<span class="number">0</span>, <span class="built_in">strcmp</span>(s2.<span class="built_in">c_string</span>(), kHelloString));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tests the Set method.</span></span><br><span class="line"><span class="built_in">TEST</span>(MyString, Set) &#123;</span><br><span class="line">  MyString s;</span><br><span class="line"></span><br><span class="line">  s.<span class="built_in">Set</span>(kHelloString);</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(<span class="number">0</span>, <span class="built_in">strcmp</span>(s.<span class="built_in">c_string</span>(), kHelloString));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set should work when the input pointer is the same as the one</span></span><br><span class="line">  <span class="comment">// already in the MyString object.</span></span><br><span class="line">  s.<span class="built_in">Set</span>(s.<span class="built_in">c_string</span>());</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(<span class="number">0</span>, <span class="built_in">strcmp</span>(s.<span class="built_in">c_string</span>(), kHelloString));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Can we set the MyString to NULL?</span></span><br><span class="line">  s.<span class="built_in">Set</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">EXPECT_STREQ</span>(<span class="literal">nullptr</span>, s.<span class="built_in">c_string</span>());</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li></ul><h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS += -I ./samples </span><br><span class="line">CFLAGS += -I ./<span class="keyword">include</span></span><br><span class="line">LFLAGS +=  ../build/lib/libgtest.a  -lpthread </span><br><span class="line">BINPATH = <span class="string">&quot;./testBin/&quot;</span></span><br><span class="line">OBJS = $&#123;BINPATH&#125; $&#123;BINPATH&#125;sample3_unittest</span><br><span class="line"></span><br><span class="line">ALL : $&#123;OBJS&#125;</span><br><span class="line">echo <span class="string">&quot;generate &quot;</span>$&#123;BINPATH&#125;<span class="variable">$^</span></span><br><span class="line"></span><br><span class="line">$&#123;BINPATH&#125; :</span><br><span class="line">-mkdir <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line">$&#123;BINPATH&#125;sample2_unittest : ./samples/sample2_unittest.cc ./samples/sample2.cc ./src/gtest_main.cc</span><br><span class="line">g++ $&#123;CFLAGS&#125;  <span class="variable">$^</span> $&#123;LFLAGS&#125;  -o <span class="variable">$@</span> </span><br><span class="line"></span><br><span class="line">.PHONY : clean ALL</span><br><span class="line"></span><br><span class="line">clean :</span><br><span class="line">@rm -r $&#123;BINPATH&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> googletest </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C, C++, 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo-blog-template</title>
      <link href="/2021/09/11/hexo-blog-template/"/>
      <url>/2021/09/11/hexo-blog-template/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> hexo本身 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C, C++, 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>googletest-01</title>
      <link href="/2021/09/11/googletest-01/"/>
      <url>/2021/09/11/googletest-01/</url>
      
        <content type="html"><![CDATA[<h1 id="TEST"><a href="#TEST" class="headerlink" title="TEST"></a>TEST</h1><h2 id="TEST使用说明"><a href="#TEST使用说明" class="headerlink" title="TEST使用说明"></a>TEST使用说明</h2><blockquote><p>简单的测试需要一下三步<br>1.包行必备的头文件, 使用<code>gtest/gtest.h</code>来声明测试框架<br>2.使用宏<code>TEST</code>来定义测试, <code>TEST</code>包含测试案例名(<code>test case name</code>, 即后面的<code>FactorialTest</code>)和测试名(<code>test name</code>)两个参数, 这两个参数的命名可随意, 不同于后面的<code>TEST_F</code>; 在所有的一对花括号<code>&#123;&#125;</code>中定义测试逻辑, 可以在头文件中<code>gtest.h</code> 查看所有可使用的宏, 如下所示:</p><ul><li><code>EXPECT_EQ(val1, val2)</code></li><li><code>EXPECT_NE(val1, val2)</code></li><li><code>EXPECT_LE(val1, val2)</code></li><li><code>EXPECT_LT(val1, val2)</code></li><li><code>EXPECT_GE(val1, val2)</code></li><li><code>EXPECT_GT(val1, val2)</code><br>3.使用定义在<code>main()</code>的宏函数<code>RUN_ALL_TESTS()</code> ,主函数如下所示;</li></ul></blockquote><p>主函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;gtest/gtest.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> GTEST_OS_ESP8266 || GTEST_OS_ESP32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> GTEST_OS_ESP8266</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  testing::InitGoogleTest();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123; RUN_ALL_TESTS(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> GTEST_OS_ESP8266</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">GTEST_API_ <span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Running main() from %s\n&quot;</span>, __FILE__);</span><br><span class="line">  testing::InitGoogleTest(&amp;argc, argv);</span><br><span class="line">  <span class="keyword">return</span> RUN_ALL_TESTS();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p><h2 id="文件说明"><a href="#文件说明" class="headerlink" title="文件说明"></a>文件说明</h2><ul><li>头文件<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GOOGLETEST_SAMPLES_SAMPLE1_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GOOGLETEST_SAMPLES_SAMPLE1_H_</span></span><br><span class="line"><span class="comment">// Returns n! (the factorial of n).  For negative n, n! is defined to be 1.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Factorial</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="comment">// Returns true if and only if n is a prime number.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsPrime</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> </span></span><br></pre></td></tr></table></figure></li><li>源文件<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sample1.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns n! (the factorial of n).  For negative n, n! is defined to be 1.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Factorial</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    result *= i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns true if and only if n is a prime number.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsPrime</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Trivial case 1: small numbers</span></span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Trivial case 2: even numbers</span></span><br><span class="line">  <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> n == <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Now, we have that n is odd and n &gt;= 3.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Try to divide n by every odd number i, starting from 3</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; ; i += <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// We only have to try i up to the square root of n</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; n/i) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now, we have i &lt;= n/i &lt; n.</span></span><br><span class="line">    <span class="comment">// If n is divisible by i, n is not prime.</span></span><br><span class="line">    <span class="keyword">if</span> (n % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// n has no integer factor in the range (1, n), and thus is prime.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>以下是测试文件, 包含两个测试案例<code>FactorialTest</code>和<code>IsPrimeTest</code>; 测试案例<code>FactorialTest</code>包含<code>Negative</code>、<code>Zero</code>和<code>Positive</code>三个测试;测试案例<code>IsPrimeTest</code>包含<code>Negative</code>、<code>Trivial</code>和<code>Positive</code>三个测试</p><ul><li>测试文件<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sample1.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;gtest/gtest.h&quot;</span></span></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tests Factorial().</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Tests factorial of negative numbers.</span></span><br><span class="line"><span class="built_in">TEST</span>(FactorialTest, Negative) &#123;</span><br><span class="line">  <span class="comment">// This test is named &quot;Negative&quot;, and belongs to the &quot;FactorialTest&quot;</span></span><br><span class="line">  <span class="comment">// test case.</span></span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(<span class="number">1</span>, <span class="built_in">Factorial</span>(<span class="number">-5</span>));</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(<span class="number">1</span>, <span class="built_in">Factorial</span>(<span class="number">-1</span>));</span><br><span class="line">  <span class="built_in">EXPECT_GT</span>(<span class="built_in">Factorial</span>(<span class="number">-10</span>), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tests factorial of 0.</span></span><br><span class="line"><span class="built_in">TEST</span>(FactorialTest, Zero) &#123; <span class="built_in">EXPECT_EQ</span>(<span class="number">1</span>, <span class="built_in">Factorial</span>(<span class="number">0</span>)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tests factorial of positive numbers.</span></span><br><span class="line"><span class="built_in">TEST</span>(FactorialTest, Positive) &#123;</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(<span class="number">1</span>, <span class="built_in">Factorial</span>(<span class="number">1</span>));</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(<span class="number">2</span>, <span class="built_in">Factorial</span>(<span class="number">2</span>));</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(<span class="number">6</span>, <span class="built_in">Factorial</span>(<span class="number">3</span>));</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(<span class="number">40320</span>, <span class="built_in">Factorial</span>(<span class="number">8</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tests IsPrime()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Tests negative input.</span></span><br><span class="line"><span class="built_in">TEST</span>(IsPrimeTest, Negative) &#123;</span><br><span class="line">  <span class="comment">// This test belongs to the IsPrimeTest test case.</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">EXPECT_FALSE</span>(<span class="built_in">IsPrime</span>(<span class="number">-1</span>));</span><br><span class="line">  <span class="built_in">EXPECT_FALSE</span>(<span class="built_in">IsPrime</span>(<span class="number">-2</span>));</span><br><span class="line">  <span class="built_in">EXPECT_FALSE</span>(<span class="built_in">IsPrime</span>(INT_MIN));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tests some trivial cases.</span></span><br><span class="line"><span class="built_in">TEST</span>(IsPrimeTest, Trivial) &#123;</span><br><span class="line">  <span class="built_in">EXPECT_FALSE</span>(<span class="built_in">IsPrime</span>(<span class="number">0</span>));</span><br><span class="line">  <span class="built_in">EXPECT_FALSE</span>(<span class="built_in">IsPrime</span>(<span class="number">1</span>));</span><br><span class="line">  <span class="built_in">EXPECT_TRUE</span>(<span class="built_in">IsPrime</span>(<span class="number">2</span>));</span><br><span class="line">  <span class="built_in">EXPECT_TRUE</span>(<span class="built_in">IsPrime</span>(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tests positive input.</span></span><br><span class="line"><span class="built_in">TEST</span>(IsPrimeTest, Positive) &#123;</span><br><span class="line">  <span class="built_in">EXPECT_FALSE</span>(<span class="built_in">IsPrime</span>(<span class="number">4</span>));</span><br><span class="line">  <span class="built_in">EXPECT_TRUE</span>(<span class="built_in">IsPrime</span>(<span class="number">5</span>));</span><br><span class="line">  <span class="built_in">EXPECT_FALSE</span>(<span class="built_in">IsPrime</span>(<span class="number">6</span>));</span><br><span class="line">  <span class="built_in">EXPECT_TRUE</span>(<span class="built_in">IsPrime</span>(<span class="number">23</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;  <span class="comment">// namespace</span></span><br></pre></td></tr></table></figure><h2 id="Makefile说明"><a href="#Makefile说明" class="headerlink" title="Makefile说明"></a><code>Makefile</code>说明</h2>注意<code>pthread</code>必须放在<code>libgtest.a</code>后<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS += -I ./samples </span><br><span class="line">CFLAGS += -I ./<span class="keyword">include</span></span><br><span class="line">LFLAGS +=  ../build/lib/libgtest.a  -lpthread </span><br><span class="line"></span><br><span class="line">sample1_unittest : ./samples/sample1_unittest.cc ./samples/sample1.cc ./src/gtest_main.cc</span><br><span class="line">  g++ $&#123;CFLAGS&#125;  <span class="variable">$^</span> $&#123;LFLAGS&#125;  -o <span class="variable">$@</span> </span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line"></span><br><span class="line">clean :</span><br><span class="line">  @rm -v sample1_unittest</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="执行测试"><a href="#执行测试" class="headerlink" title="执行测试"></a>执行测试</h2><blockquote><p>故意修改最后一个测试, 测试结果如下</p></blockquote><p><img src="/images/TEST_RES.png" alt="TEST执行结果"></p><h1 id="googletest-amp-cmake"><a href="#googletest-amp-cmake" class="headerlink" title="googletest&amp;cmake"></a>googletest&amp;cmake</h1><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(googleTest_mockcpp)</span><br><span class="line"><span class="keyword">enable_testing</span>()</span><br><span class="line"><span class="keyword">find_package</span>(GTest REQUIRED)</span><br><span class="line"><span class="keyword">if</span>(GTest_FOUND)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;GTEST_INCLUDE_DIRS:$&#123;GTEST_INCLUDE_DIRS&#125;&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;GTEST_BOTH_LIBRARIES:$&#123;GTEST_BOTH_LIBRARIES&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>(GTest_FOUND)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(Threads REQUIRED)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> ./<span class="keyword">test</span>/ft_test.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;GTEST_BOTH_LIBRARIES&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> pthread)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> googletest </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C, C++, 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo, Hello World</title>
      <link href="/2021/09/08/hexo-hello-world/"/>
      <url>/2021/09/08/hexo-hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h1 id="Tabs"><a href="#Tabs" class="headerlink" title="Tabs"></a>Tabs</h1><div class="tabs" id="test2"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test2-1">出师表</button></li><li class="tab"><button type="button" data-href="#test2-2">图库</button></li><li class="tab active"><button type="button" data-href="#test2-3">李白</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test2-1"><p>臣亮言：先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍衞之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。<br>宫中府中，俱为一体；陟罚臧否，不宜异同：若有作奸犯科及为忠善者，宜付有司论其刑赏，以昭陛下平明之理；不宜偏私，使内外异法也。<br>侍中、侍郎郭攸之、费祎、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下：愚以为宫中之事，事无大小，悉以谘之，然后施行，必能裨补阙漏，有所广益。<br>将军向宠，性行淑均，晓畅军事，试用于昔日，先帝称之曰“能”，是以众议举宠为督：愚以为营中之事，悉以谘之，必能使行阵和睦，优劣得所。<br>亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未嘗不叹息痛恨于桓、灵也。侍中、尚书、长史、参军，此悉贞良死节之臣，愿陛下亲之、信之，则汉室之隆，可计日而待也。<br>臣本布衣，躬耕于南阳，苟全性命于乱世，不求闻达于诸侯。先帝不以臣卑鄙，猥自枉屈，三顾臣于草庐之中，谘臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任于败军之际，奉命于危难之间：尔来二十有一年矣。<br>先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧叹，恐託付不效，以伤先帝之明；故五月渡泸，深入不毛。今南方已定，兵甲已足，当奖率三军，北定中原，庶竭驽钝，攘除奸兇，兴復汉室，还于旧都。此臣所以报先帝而忠陛下之职分也。至于斟酌损益，进尽忠言，则攸之、祎、允之任也。<br>愿陛下託臣以讨贼兴復之效，不效，则治臣之罪，以告先帝之灵。若无兴德之言，则责攸之、祎、允等之慢，以彰其咎；陛下亦宜自谋，以谘诹善道，察纳雅言，深追先帝遗诏。臣不胜受恩感激。<br>今当远离，临表涕零，不知所言。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test2-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content active" id="test2-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="Button"><a href="#Button" class="headerlink" title="Button"></a>Button</h1><h1 id="Inline"><a href="#Inline" class="headerlink" title="Inline"></a>Inline</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This is my website, click the button &#123;% btn &#x27;https://butterfly.js.org&#x27;,Butterfly %&#125;</span><br><span class="line">This is my website, click the button &#123;% btn &#x27;https://butterfly.js.org&#x27;,Butterfly,,outline%&#125;</span><br></pre></td></tr></table></figure><p>This is my website, click the button <a class="btn-beautify button--animated " href="https://butterfly.js.org" title="Butterfly"><span>Butterfly</span></a><br>This is my website, click the button <a class="btn-beautify button--animated outline" href="https://butterfly.js.org" title="Butterfly"><span>Butterfly</span></a></p><h1 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">This is my website, click the button  &#123;% btn &#x27;https://butterfly.js.org&#x27;,Butterfly,far fa-hand-point-right,block larger %&#125;</span><br><span class="line">This is my website, click the button  &#123;% btn &#x27;https://butterfly.js.org&#x27;,Butterfly,far fa-hand-point-right,block center larger %&#125;</span><br><span class="line">This is my website, click the button  &#123;% btn &#x27;https://butterfly.js.org&#x27;,Butterfly,far fa-hand-point-right,block right blue larger %&#125;</span><br></pre></td></tr></table></figure><p>This is my website, click the button  <a class="btn-beautify button--animated block larger" href="https://butterfly.js.org" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a><br>This is my website, click the button  <a class="btn-beautify button--animated block center larger" href="https://butterfly.js.org" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a><br>This is my website, click the button  <a class="btn-beautify button--animated block right blue larger" href="https://butterfly.js.org" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a></p><h1 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h1><blockquote><p>more than one button in center<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;btn-center&quot;</span>&gt;</span></span></span><br><span class="line">&#123;% btn &#x27;https://butterfly.js.org&#x27;,Butterfly,far fa-hand-point-right,larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://butterfly.js.org&#x27;,Butterfly,far fa-hand-point-right,blue larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://butterfly.js.org&#x27;,Butterfly,far fa-hand-point-right,pink larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://butterfly.js.org&#x27;,Butterfly,far fa-hand-point-right,red larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://butterfly.js.org&#x27;,Butterfly,far fa-hand-point-right,purple larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://butterfly.js.org&#x27;,Butterfly,far fa-hand-point-right,orange larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://butterfly.js.org&#x27;,Butterfly,far fa-hand-point-right,orange larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://butterfly.js.org&#x27;,Butterfly,far fa-hand-point-right,orange larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://butterfly.js.org&#x27;,Butterfly,far fa-hand-point-right,green larger %&#125;</span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p></blockquote><div class="btn-center"><a class="btn-beautify button--animated larger" href="https://butterfly.js.org" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a><a class="btn-beautify button--animated blue larger" href="https://butterfly.js.org" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a><a class="btn-beautify button--animated pink larger" href="https://butterfly.js.org" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a><a class="btn-beautify button--animated red larger" href="https://butterfly.js.org" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a><a class="btn-beautify button--animated purple larger" href="https://butterfly.js.org" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a><a class="btn-beautify button--animated orange larger" href="https://butterfly.js.org" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a><a class="btn-beautify button--animated orange larger" href="https://butterfly.js.org" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a><a class="btn-beautify button--animated orange larger" href="https://butterfly.js.org" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a><a class="btn-beautify button--animated green larger" href="https://butterfly.js.org" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a></div><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;btn-center&quot;</span>&gt;</span></span></span><br><span class="line">&#123;% btn &#x27;https://butterfly.js.org&#x27;,Butterfly,far fa-hand-point-right,outline larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://butterfly.js.org&#x27;,Butterfly,far fa-hand-point-right,outline blue larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://butterfly.js.org&#x27;,Butterfly,far fa-hand-point-right,outline pink larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://butterfly.js.org&#x27;,Butterfly,far fa-hand-point-right,outline red larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://butterfly.js.org&#x27;,Butterfly,far fa-hand-point-right,outline purple larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://butterfly.js.org&#x27;,Butterfly,far fa-hand-point-right,outline orange larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://butterfly.js.org&#x27;,Butterfly,far fa-hand-point-right,outline green larger %&#125;</span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><div class="btn-center"><a class="btn-beautify button--animated outline larger" href="https://butterfly.js.org" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a><a class="btn-beautify button--animated outline blue larger" href="https://butterfly.js.org" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a><a class="btn-beautify button--animated outline pink larger" href="https://butterfly.js.org" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a><a class="btn-beautify button--animated outline red larger" href="https://butterfly.js.org" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a><a class="btn-beautify button--animated outline purple larger" href="https://butterfly.js.org" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a><a class="btn-beautify button--animated outline orange larger" href="https://butterfly.js.org" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a><a class="btn-beautify button--animated outline green larger" href="https://butterfly.js.org" title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a></div><h1 id="Note-Bootstrap-Callout"><a href="#Note-Bootstrap-Callout" class="headerlink" title="Note (Bootstrap Callout)"></a>Note (Bootstrap Callout)</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><blockquote><p>simple<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note simple %&#125;</span><br><span class="line">默认 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default simple %&#125;</span><br><span class="line">default 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary simple %&#125;</span><br><span class="line">primary 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success simple %&#125;</span><br><span class="line">success 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info simple %&#125;</span><br><span class="line">info 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning simple %&#125;</span><br><span class="line">warning 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger simple %&#125;</span><br><span class="line">danger 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><br><div class="note simple"><p>默认 提示块标籤</p></div></p></blockquote><div class="note default simple"><p>default 提示块标籤</p></div><div class="note primary simple"><p>primary 提示块标籤</p></div><div class="note success simple"><p>success 提示块标籤</p></div><div class="note info simple"><p>info 提示块标籤</p></div><div class="note warning simple"><p>warning 提示块标籤</p></div><div class="note danger simple"><p>danger 提示块标籤</p></div><blockquote><p>modern<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note modern %&#125;</span><br><span class="line">默认 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default modern %&#125;</span><br><span class="line">default 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary modern %&#125;</span><br><span class="line">primary 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success modern %&#125;</span><br><span class="line">success 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info modern %&#125;</span><br><span class="line">info 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning modern %&#125;</span><br><span class="line">warning 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger modern %&#125;</span><br><span class="line">danger 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><br><div class="note modern"><p>默认 提示块标籤</p></div></p></blockquote><div class="note default modern"><p>default 提示块标籤</p></div><div class="note primary modern"><p>primary 提示块标籤</p></div><div class="note success modern"><p>success 提示块标籤</p></div><div class="note info modern"><p>info 提示块标籤</p></div><div class="note warning modern"><p>warning 提示块标籤</p></div><div class="note danger modern"><p>danger 提示块标籤</p></div><h1 id="特殊字符输入"><a href="#特殊字符输入" class="headerlink" title="特殊字符输入"></a>特殊字符输入</h1><h2 id="表格中输入竖线"><a href="#表格中输入竖线" class="headerlink" title="表格中输入竖线"></a>表格中输入竖线</h2><div class="table-container"><table><thead><tr><th style="text-align:center">符号</th><th style="text-align:center">区别</th><th style="text-align:center">运用场景</th></tr></thead><tbody><tr><td style="text-align:center"><code>[]</code></td><td style="text-align:center"><code>1</code>一次匹配一个字符<code>[abc]</code></td><td style="text-align:center">匹配单个字符</td></tr><tr><td style="text-align:center">&#124;</td><td style="text-align:center">a &#124; b &#124; c &#124; string</td><td style="text-align:center">匹配单词</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> hexo本身 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用工具安装</title>
      <link href="/2021/09/02/Linux%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85/"/>
      <url>/2021/09/02/Linux%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="tldr"><a href="#tldr" class="headerlink" title="tldr"></a>tldr</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g tldr</span><br></pre></td></tr></table></figure><h1 id="node"><a href="#node" class="headerlink" title="node"></a>node</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载nodejs</span></span><br><span class="line">➜ Tools wget https://nodejs.org/dist/latest-v12.x/node-v12.22.6-linux-arm64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">➜ Tools tar zxvf ./node-v12.22.6-linux-arm64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重命名</span></span><br><span class="line">➜ Tools mv node-v12.22.6-linux-arm64 node</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移动到/usr/local</span></span><br><span class="line">➜ Tools sudo mv ./node /usr/<span class="built_in">local</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加环境变量</span></span><br><span class="line">➜ Tools cat ~/.zshrc | tail -n 1</span><br><span class="line">PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/node/bin</span><br><span class="line"><span class="comment"># 查看node版本</span></span><br><span class="line"></span><br><span class="line">➜ Tools node -v</span><br><span class="line">v12.22.6</span><br></pre></td></tr></table></figure><h1 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h1><h2 id="必须先安装node-js"><a href="#必须先安装node-js" class="headerlink" title="必须先安装node-js"></a>必须先安装<code>node-js</code></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装cnpm, 使用淘宝的源可快速下载hexo</span></span><br><span class="line">➜ Tools npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line">npm WARN deprecated har-validator@5.1.5: this library is no longer supported</span><br><span class="line">/usr/<span class="built_in">local</span>/node/bin/cnpm -&gt; /usr/<span class="built_in">local</span>/node/lib/node_modules/cnpm/bin/cnpm</span><br><span class="line">+ cnpm@7.0.0</span><br><span class="line">added 709 packages from 970 contributors <span class="keyword">in</span> 74.274s</span><br></pre></td></tr></table></figure><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">➜ Tools cnpm install -g hexo-cli</span><br><span class="line">Downloading hexo-cli to /usr/<span class="built_in">local</span>/node/lib/node_modules/hexo-cli_tmp</span><br><span class="line">Copying /usr/<span class="built_in">local</span>/node/lib/node_modules/hexo-cli_tmp/_hexo-cli@4.3.0@hexo-cli to /usr/<span class="built_in">local</span>/node/lib/node_modules/hexo-cli</span><br><span class="line">Installing hexo-cli<span class="string">&#x27;s dependencies to /usr/local/node/lib/node_modules/hexo-cli/node_modules</span></span><br><span class="line"><span class="string">[1/10] abbrev@^1.1.1 installed at node_modules/_abbrev@1.1.1@abbrev</span></span><br><span class="line"><span class="string">[2/10] tildify@^2.0.0 installed at node_modules/_tildify@2.0.0@tildify</span></span><br><span class="line"><span class="string">[3/10] hexo-log@^2.0.0 installed at node_modules/_hexo-log@2.0.0@hexo-log</span></span><br><span class="line"><span class="string">[4/10] minimist@^1.2.5 installed at node_modules/_minimist@1.2.5@minimist</span></span><br><span class="line"><span class="string">[5/10] command-exists@^1.2.8 installed at node_modules/_command-exists@1.2.9@command-exists</span></span><br><span class="line"><span class="string">[6/10] bluebird@^3.5.5 installed at node_modules/_bluebird@3.7.2@bluebird</span></span><br><span class="line"><span class="string">platform unsupported hexo-fs@3.1.0 › chokidar@3.5.2 › fsevents@~2.3.2 Package require os(darwin) not compatible with your platform(linux)</span></span><br><span class="line"><span class="string">[fsevents@~2.3.2] optional install error: Package require os(darwin) not compatible with your platform(linux)</span></span><br><span class="line"><span class="string">[7/10] chalk@^4.0.0 installed at node_modules/_chalk@4.1.2@chalk</span></span><br><span class="line"><span class="string">[8/10] hexo-fs@^3.0.1 installed at node_modules/_hexo-fs@3.1.0@hexo-fs</span></span><br><span class="line"><span class="string">[9/10] resolve@^1.11.0 installed at node_modules/_resolve@1.20.0@resolve</span></span><br><span class="line"><span class="string">[10/10] hexo-util@^2.0.0 installed at node_modules/_hexo-util@2.5.0@hexo-util</span></span><br><span class="line"><span class="string">Recently updated (since 2021-08-26): 2 packages (detail see file /usr/local/node/lib/node_modules/hexo-cli/node_modules/.recently_updates.txt)</span></span><br><span class="line"><span class="string">  2021-08-29</span></span><br><span class="line"><span class="string">    → hexo-util@2.5.0 › htmlparser2@6.1.0 › domhandler@^4.0.0(4.2.2) (22:18:56)</span></span><br><span class="line"><span class="string">  2021-08-28</span></span><br><span class="line"><span class="string">    → hexo-util@2.5.0 › htmlparser2@6.1.0 › domutils@^2.5.2(2.8.0) (07:21:51)</span></span><br><span class="line"><span class="string">All packages installed (57 packages installed from npm registry, used 3s(network 3s), speed 481.11KB/s, json 57(137.48KB), tarball 1.42MB)</span></span><br><span class="line"><span class="string">[hexo-cli@4.3.0] link /usr/local/node/bin/hexo@ -&gt; /usr/local/node/lib/node_modules/hexo-cli/bin/hexo</span></span><br></pre></td></tr></table></figure><h2 id="hexo-cnpm-npm都被安装在node文件夹下"><a href="#hexo-cnpm-npm都被安装在node文件夹下" class="headerlink" title="hexo, cnpm, npm都被安装在node文件夹下"></a>hexo, cnpm, npm都被安装在node文件夹下</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜ bin <span class="built_in">pwd</span></span><br><span class="line">/usr/<span class="built_in">local</span>/node/bin</span><br><span class="line">➜ bin ll</span><br><span class="line">总用量 46M</span><br><span class="line">lrwxrwxrwx 1 pi pi  33 9月   2 22:27 cnpm -&gt; ../lib/node_modules/cnpm/bin/cnpm</span><br><span class="line">lrwxrwxrwx 1 pi pi  37 9月   2 22:29 hexo -&gt; ../lib/node_modules/hexo-cli/bin/hexo</span><br><span class="line">-rwxr-xr-x 1 pi p 46M 8月  31 01:39 node</span><br><span class="line">lrwxrwxrwx 1 pi pi  38 8月  31 01:39 npm -&gt; ../lib/node_modules/npm/bin/npm-cli.js</span><br><span class="line">lrwxrwxrwx 1 pi pi  38 8月  31 01:39 npx -&gt; ../lib/node_modules/npm/bin/npx-cli.js</span><br></pre></td></tr></table></figure><h1 id="pm2"><a href="#pm2" class="headerlink" title="pm2"></a>pm2</h1><ul><li>PM2是node进程管理工具，可以利用它来简化很多node应用管理的繁琐任务，如性能监控、自动重启、负载均衡等，而且使用非常简单;如何使用参考<a href="/2021/08/15/Linux-命令/index.html">Linux-命令</a>;<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g pm2</span><br></pre></td></tr></table></figure></li><li>安装完成后,会自动创建下面目录<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜ .pm2 <span class="built_in">pwd</span></span><br><span class="line">/home/pi/.pm2</span><br><span class="line">➜ .pm2 ls</span><br><span class="line">dump.pm2  logs  module_conf.json  modules  pids  pm2.log  pm2.pid  pub.sock  rpc.sock  touch</span><br></pre></td></tr></table></figure></li></ul><h1 id="ubuntu-packages"><a href="#ubuntu-packages" class="headerlink" title="ubuntu packages"></a><code>ubuntu packages</code></h1><p>在<a href="https://packages.ubuntu.com/">ubuntu packages</a>查找要安装的库,如下图所示<br><img src="/images/ubuntuPackages.png" alt="Ubuntu Packages Search"><br>[1]-<a href="https://www.cnblogs.com/EasonJim/p/7863099.html">zsh的安装</a></p><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><h2 id="截图工具"><a href="#截图工具" class="headerlink" title="截图工具"></a>截图工具</h2><ul><li><code>shutter</code><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:linuxuprising/shutter</span><br><span class="line">sudo apt install shutter</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux的基本使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-内核学习-03</title>
      <link href="/2021/08/29/Linux-%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0-03/"/>
      <url>/2021/08/29/Linux-%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0-03/</url>
      
        <content type="html"><![CDATA[<h1 id="一个调用驱动里的write函数的示例"><a href="#一个调用驱动里的write函数的示例" class="headerlink" title="一个调用驱动里的write函数的示例"></a>一个调用驱动里的write函数的示例</h1><h2 id="源文件"><a href="#源文件" class="headerlink" title="源文件"></a>源文件</h2><p>要调用驱动里的<code>write</code>函数, 需要使用<code>mknod</code>命令建立驱动文件, 在<strong>应用层</strong>像打开文件一样打开该驱动文件, 使用读<code>read</code>函数和写<code>write</code>函数实现对驱动里的<code>write</code>函数进行调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">➜  test_hello_demo cat test_hello_demo.c</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span> <span class="comment">// 为了能够使用O_RDWR</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span> <span class="comment">// 为了使用 write 和 read</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA_NUM (64)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fd, i;</span><br><span class="line">        <span class="keyword">int</span> r_len, w_len;</span><br><span class="line">        <span class="keyword">char</span> buf[DATA_NUM] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, DATA_NUM);</span><br><span class="line">        fd = open(<span class="string">&quot;/dev/hello&quot;</span>, O_RDWR);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fd : %d\r\n&quot;</span>, fd);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">-1</span> == fd)</span><br><span class="line">        &#123;</span><br><span class="line">                perror(<span class="string">&quot;open file error\r\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;open success.\r\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        w_len = write(fd, buf, DATA_NUM);</span><br><span class="line">        r_len = read(fd, buf, DATA_NUM);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\r\n&quot;</span>, w_len, r_len);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\r\n&quot;</span>, buf);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>使用最简单的<code>Makefile</code>进行编译即可<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test_hello_demo : test_hello_demo.c</span><br><span class="line">        gcc <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        rm -v test_hello_demo</span><br></pre></td></tr></table></figure></p><h2 id="执行demo"><a href="#执行demo" class="headerlink" title="执行demo"></a>执行<code>demo</code></h2><ul><li><strong>首先需要将Linux-内核学习-02中的驱动文件<code>helloDev.ko</code>插入, 然后查看内核日志，并查看当前内核的驱动</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  hello_demo sudo insmod helloDev.ko</span><br><span class="line">➜  hello_demo sudo dmesg</span><br><span class="line">[41194.279575] register_chrdev_region ok</span><br><span class="line">[41194.279578]  hello driver init </span><br><span class="line">➜  hello_demo sudo lsmod | head -n 10</span><br><span class="line">Module                  Size  Used by</span><br><span class="line">helloDev               16384  0</span><br><span class="line">rfcomm                 81920  4</span><br></pre></td></tr></table></figure><blockquote><p>查看内核日志可知<code>helloDev</code>设备驱动已插入</p></blockquote></li></ul><ul><li><strong>创建驱动文件</strong><br>使用<code>mknod</code>命令创建驱动文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  hello_demo sudo mknod /dev/hello c 232 0</span><br><span class="line">➜  hello_demo ls -l /dev/hello</span><br><span class="line">crw-r--r-- 1 Root root 232, 0 8月  29 22:52 /dev/hello</span><br></pre></td></tr></table></figure><blockquote><p><code>mknod</code>命令详解如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">       mknod - make block or character special files</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       mknod [OPTION]... NAME TYPE [MAJOR MINOR]</span><br><span class="line">       主设备号 次设备号</span><br></pre></td></tr></table></figure></blockquote></li></ul><ul><li><p><strong>执行<code>demo</code></strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  test_hello_demo sudo ./test_hello_demo</span><br><span class="line">fd : 3</span><br><span class="line">open success.</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure><blockquote><p><code>open</code>,<code>write</code>和<code>read</code>都被成功执行了</p></blockquote></li><li><p><strong>删除驱动文件并查看当前内核日志</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  test_hello_demo sudo rm /dev/hello</span><br><span class="line">➜  test_hello_demo sudo dmesg</span><br><span class="line">[41194.279575] register_chrdev_region ok</span><br><span class="line">[41194.279578]  hello driver init</span><br><span class="line">[41274.403093] hello_open</span><br><span class="line">[41274.403152] hello_write</span><br><span class="line">[41274.403154] hello_read</span><br></pre></td></tr></table></figure><blockquote><p>示例<code>demo</code>中相继执行了<code>open</code>,<code>write</code>和<code>read</code>, 而内核日志中也相继执行了<code>hello_open</code>, <code>hello_write</code>和<code>hello_write</code></p></blockquote></li></ul><ul><li><strong>卸载设备驱动</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  test_hello_demo sudo rmmod helloDev</span><br><span class="line">➜  test_hello_demo sudo dmesg</span><br><span class="line">[41194.279575] register_chrdev_region ok</span><br><span class="line">[41194.279578]  hello driver init</span><br><span class="line">[41274.403093] hello_open</span><br><span class="line">[41274.403152] hello_write</span><br><span class="line">[41274.403154] hello_read</span><br><span class="line">[41346.707954] unregister_chrdev_region ok</span><br></pre></td></tr></table></figure><blockquote><p>查看内核日志可知设备驱动成功被卸载</p></blockquote></li></ul><h1 id="调用过程分析"><a href="#调用过程分析" class="headerlink" title="调用过程分析"></a>调用过程分析</h1><p>内核的调用过程如下图[应用层write-&gt;内核-&gt;驱动]所示, <strong>最终实现了<code>file-&gt;f_op-&gt;write(file, p, count, pos)</code>的调用, 其中<code>f_op</code>是<code>struct file_operations</code>类型的变量, 结构内定义了文件操作的相关函数类型, 并在驱动设备初始化时初始化了write, 如图[f_op的初始化]所示</strong><br><img src="/images/write2write.png" alt="应用层write-&gt;内核-&gt;驱动"><br><img src="/images/driverWrite.png" alt="f_op的初始化"></p>]]></content>
      
      
      <categories>
          
          <category> Linux内核 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C, 驱动开发, Linux内核 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-内核学习-02</title>
      <link href="/2021/08/29/Linux-%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0-02/"/>
      <url>/2021/08/29/Linux-%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0-02/</url>
      
        <content type="html"><![CDATA[<h1 id="实现一个字符设备驱动"><a href="#实现一个字符设备驱动" class="headerlink" title="实现一个字符设备驱动"></a>实现一个字符设备驱动</h1><h2 id="字符串设备驱动的框架"><a href="#字符串设备驱动的框架" class="headerlink" title="字符串设备驱动的框架"></a>字符串设备驱动的框架</h2><p>字符串设备驱动的框架包括以下三个函数：</p><p>驱动的入口函数是<code>module_init(fun_init)</code><br>驱动的出口函数是<code>module_exit(fun_exit)</code><br>驱动的版权函数是<code>MODULE_LICENSE(&quot;GPL&quot;)</code></p><h2 id="入口函数"><a href="#入口函数" class="headerlink" title="入口函数"></a>入口函数</h2><p>驱动的入口函数<code>module_init(fun_init)</code>负责在内核中申请设备号，定义设备类型对象，设置该设备对应的打开，读，写等操作；并把设备号与设备对象关联起来，把设备对象与文件操作关联起来；</p><ul><li><p><strong>在内核中申请设备号</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reg_major是主设备号，reg_minor是次设备号</span></span><br><span class="line"><span class="comment">// 用主次设备号生成一个设备号devNum</span></span><br><span class="line">devNum = MKDEV(reg_major, reg_minor);</span><br><span class="line"><span class="comment">// 在内核中注册该设备号，在内核中唯一标识了一个id，该id在内核中不能被其他设备暂用</span></span><br><span class="line"><span class="comment">// subDevNum表示目前开始注册第subDevNum个设备号</span></span><br><span class="line"><span class="keyword">if</span>(OK == register_chrdev_region(devNum, subDevNum, <span class="string">&quot;helloworld&quot;</span>))&#123;</span><br><span class="line">    printk(KERN_EMERG<span class="string">&quot;register_chrdev_region ok \n&quot;</span>); </span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">printk(KERN_EMERG<span class="string">&quot;register_chrdev_region error n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line">printk(KERN_EMERG<span class="string">&quot; hello driver init \n&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>定义字符设备类型对象</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cdev表示一个字符设备</span></span><br><span class="line">gDev = kzalloc(<span class="keyword">sizeof</span>(struct cdev), GFP_KERNEL);</span><br></pre></td></tr></table></figure></li><li><p><strong>定义相关操作</strong><br>linux把设备也抽象成文件，所以要定义文件的读写相关操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// linux中设备也是文件，可以用file_operations来定义一些对文件操作的函数</span></span><br><span class="line">gFile = kzalloc(<span class="keyword">sizeof</span>(struct file_operations), GFP_KERNEL);</span><br><span class="line"><span class="comment">// 对要制作的字符串设备驱动定义 打开，读，写的操作函数</span></span><br><span class="line">gFile-&gt;open = hello_open;</span><br><span class="line">gFile-&gt;read = hello_read;</span><br><span class="line">gFile-&gt;write = hello_write;</span><br><span class="line">gFile-&gt;owner = THIS_MODULE;</span><br></pre></td></tr></table></figure></li><li><p><strong>把设备号与设备对象关联起来，把设备对象与文件操作关联起来</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符设备初始化，把字符设备驱动和该驱动相关的操作函数联系起来</span></span><br><span class="line">cdev_init(gDev, gFile);</span><br><span class="line"><span class="comment">// 设定该字符驱动的在内核中的设备号，1表示我们注册了一个设备</span></span><br><span class="line">cdev_add(gDev, devNum, <span class="number">1</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>操作函数的定义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hello_open</span><span class="params">(struct inode *p, struct file *f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(KERN_EMERG<span class="string">&quot;hello_open\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">hello_write</span><span class="params">(struct file *f, <span class="keyword">const</span> <span class="keyword">char</span> __user *u, <span class="keyword">size_t</span> s, <span class="keyword">loff_t</span> *l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(KERN_EMERG<span class="string">&quot;hello_write\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">hello_read</span><span class="params">(struct file *f, <span class="keyword">char</span> __user *u, <span class="keyword">size_t</span> s, <span class="keyword">loff_t</span> *l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(KERN_EMERG<span class="string">&quot;hello_read\r\n&quot;</span>);      </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="出口函数"><a href="#出口函数" class="headerlink" title="出口函数"></a>出口函数</h2><p>驱动的出口函数是<code>module_exit(fun_exit)</code>负责卸载该设备的相关操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">printk(KERN_EMERG<span class="string">&quot;unregister_chrdev_region ok \n&quot;</span>); </span><br><span class="line">cdev_del(gDev);</span><br><span class="line">unregister_chrdev_region(devNum, subDevNum);</span><br></pre></td></tr></table></figure><h2 id="许可协议"><a href="#许可协议" class="headerlink" title="许可协议"></a>许可协议</h2><p><a href="https://baike.baidu.com/item/GNU%E9%80%9A%E7%94%A8%E5%85%AC%E5%85%B1%E8%AE%B8%E5%8F%AF%E8%AF%81/393832?fromtitle=GPL&amp;fromid=2357903&amp;fr=aladdin">GPL说明</a><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure></p><h2 id="源文件"><a href="#源文件" class="headerlink" title="源文件"></a>源文件</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/moduleparam.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/slab.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_MAX    (10)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK            (0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR         (-1)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> *<span class="title">gDev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">gFile</span>;</span></span><br><span class="line"><span class="keyword">dev_t</span>  devNum;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> subDevNum = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> reg_major  =  <span class="number">232</span>;    </span><br><span class="line"><span class="keyword">int</span> reg_minor =   <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> *buffer;</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hello_open</span><span class="params">(struct inode *p, struct file *f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(KERN_EMERG<span class="string">&quot;hello_open\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">hello_write</span><span class="params">(struct file *f, <span class="keyword">const</span> <span class="keyword">char</span> __user *u, <span class="keyword">size_t</span> s, <span class="keyword">loff_t</span> *l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(KERN_EMERG<span class="string">&quot;hello_write\r\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">hello_read</span><span class="params">(struct file *f, <span class="keyword">char</span> __user *u, <span class="keyword">size_t</span> s, <span class="keyword">loff_t</span> *l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(KERN_EMERG<span class="string">&quot;hello_read\r\n&quot;</span>);      </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hello_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// reg_major是主设备号，reg_minor是次设备号</span></span><br><span class="line">    <span class="comment">// 用主次设备号生成一个设备号devNum</span></span><br><span class="line">    devNum = MKDEV(reg_major, reg_minor);</span><br><span class="line"><span class="comment">// 在内核中注册该设备号，在内核中唯一标识了一个id，该id在内核中不能被其他设备暂用</span></span><br><span class="line"><span class="comment">// subDevNum表示目前开始注册第subDevNum个设备号</span></span><br><span class="line">    <span class="keyword">if</span>(OK == register_chrdev_region(devNum, subDevNum, <span class="string">&quot;helloworld&quot;</span>))&#123;</span><br><span class="line">        printk(KERN_EMERG<span class="string">&quot;register_chrdev_region ok \n&quot;</span>); </span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    printk(KERN_EMERG<span class="string">&quot;register_chrdev_region error n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(KERN_EMERG<span class="string">&quot; hello driver init \n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// cdev表示一个字符设备</span></span><br><span class="line">    gDev = kzalloc(<span class="keyword">sizeof</span>(struct cdev), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line"><span class="comment">// linux中设备也是文件，可以用file_operations来定义一些对文件操作的函数</span></span><br><span class="line">    gFile = kzalloc(<span class="keyword">sizeof</span>(struct file_operations), GFP_KERNEL);</span><br><span class="line"><span class="comment">// 对要制作的字符串设备驱动定义 打开，读，写的操作函数</span></span><br><span class="line">    gFile-&gt;open = hello_open;</span><br><span class="line">    gFile-&gt;read = hello_read;</span><br><span class="line">    gFile-&gt;write = hello_write;</span><br><span class="line">    gFile-&gt;owner = THIS_MODULE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符设备初始化，把字符设备驱动和该驱动相关的操作函数联系起来</span></span><br><span class="line">    cdev_init(gDev, gFile);</span><br><span class="line"><span class="comment">// 设定该字符驱动的在内核中的设备号，1表示我们注册了一个设备</span></span><br><span class="line">    cdev_add(gDev, devNum, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> __exit <span class="title">hello_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">printk(KERN_EMERG<span class="string">&quot;unregister_chrdev_region ok \n&quot;</span>); </span><br><span class="line">    cdev_del(gDev);</span><br><span class="line">    unregister_chrdev_region(devNum, subDevNum);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="Makefile文件"><a href="#Makefile文件" class="headerlink" title="Makefile文件"></a>Makefile文件</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(KERNELRELEASE)</span>,)</span><br><span class="line">obj-m := helloDev.o</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">PWD := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"><span class="comment">#KDIR:= /lib/modules/4.4.0-31-generic/build</span></span><br><span class="line">KDIR := /lib/modules/`uname -r`/build</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -rf *.o *.ko *.mod.c *.symvers *.c~ *~</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><ul><li><strong><code>Makefile</code>文件说明</strong><ul><li>执行<code>Makefile</code>时, <code>KERNELRELEASE</code>是空, 所以执行到了<code>else</code>; </li><li><code>PWD</code>变量是为了二次执行该<code>Makefile</code>;</li><li><code>KDIR</code>是内核开发包的路径，在该路径执行玩Makefile后, <code>KERNELRELEASE</code>变成非空</li><li>参数<code>M</code>表示在路径<code>KDIR</code>下执行完后, 回到<code>PWD</code>路径执行<code>Makefile</code></li><li>回到当前路径二次执行<code>Makefile</code>时, 内核会收集所有<code>obj-m</code>对象, 把源文件加工为<code>.o</code>文件；在把<code>.o</code>文件加工为<code>.ko</code>文件</li></ul></li></ul><blockquote><p><code>.ko</code>文件是驱动文件</p></blockquote><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h2 id="驱动的插入"><a href="#驱动的插入" class="headerlink" title="驱动的插入"></a>驱动的插入</h2><ul><li><p><strong>为了方便查看内核日志，先清理内核日志</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dmesg -c</span><br></pre></td></tr></table></figure></li><li><p><strong>插入驱动</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  hello_demo sudo insmod helloDev.ko</span><br><span class="line">➜  hello_demo sudo dmesg <span class="comment"># 查看内核日志</span></span><br><span class="line">[21306.529205] helloDev: loading out-of-tree module taints kernel.</span><br><span class="line">[21306.529243] helloDev: module verification failed: signature and/or required key missing - tainting kernel</span><br><span class="line">[21306.529880] register_chrdev_region ok</span><br><span class="line">[21306.529882]  hello driver init</span><br></pre></td></tr></table></figure></li></ul><h2 id="查看内核驱动"><a href="#查看内核驱动" class="headerlink" title="查看内核驱动"></a>查看内核驱动</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜  hello_demo lsmod | head -n 10</span><br><span class="line">Module                  Size  Used by</span><br><span class="line">helloDev               16384  0</span><br><span class="line">rfcomm                 81920  4</span><br><span class="line">ccm                    20480  3</span><br><span class="line">joydev                 28672  0</span><br><span class="line">cmac                   16384  1</span><br><span class="line">bnep                   24576  2</span><br><span class="line">snd_hda_codec_hdmi     61440  1</span><br><span class="line">snd_sof_pci            20480  0</span><br><span class="line">snd_sof_intel_hda_common    65536  1 snd_sof_pci</span><br></pre></td></tr></table></figure><p>由于helloDev驱动还未被使用， 所以<code>Used by</code>还是<code>0</code></p><h2 id="驱动的卸载"><a href="#驱动的卸载" class="headerlink" title="驱动的卸载"></a>驱动的卸载</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  hello_demo sudo rmmod helloDev</span><br><span class="line">➜  hello_demo sudo dmesg -c <span class="comment"># 查看内核日志并删除内核日志</span></span><br><span class="line">[22011.735186] unregister_chrdev_region ok</span><br></pre></td></tr></table></figure><ul><li><strong>查看内核日志, 驱动已被卸载</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜  hello_demo lsmod | head -n 10</span><br><span class="line">Module                  Size  Used by</span><br><span class="line">rfcomm                 81920  4</span><br><span class="line">ccm                    20480  3</span><br><span class="line">joydev                 28672  0</span><br><span class="line">cmac                   16384  1</span><br><span class="line">bnep                   24576  2</span><br><span class="line">snd_hda_codec_hdmi     61440  1</span><br><span class="line">snd_sof_pci            20480  0</span><br><span class="line">snd_sof_intel_hda_common    65536  1 snd_sof_pci</span><br><span class="line">snd_soc_hdac_hda       24576  1 snd_sof_intel_hda_common</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux内核 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C, 驱动开发, Linux内核 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows上将linux目录映射网络驱动器</title>
      <link href="/2021/08/27/Windows%E4%B8%8A%E5%B0%86linux%E7%9B%AE%E5%BD%95%E6%98%A0%E5%B0%84%E7%BD%91%E7%BB%9C%E9%A9%B1%E5%8A%A8%E5%99%A8/"/>
      <url>/2021/08/27/Windows%E4%B8%8A%E5%B0%86linux%E7%9B%AE%E5%BD%95%E6%98%A0%E5%B0%84%E7%BD%91%E7%BB%9C%E9%A9%B1%E5%8A%A8%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="安装samba"><a href="#安装samba" class="headerlink" title="安装samba"></a>安装samba</h2><p><a href="https://baike.baidu.com/item/samba/455025?fr=aladdin">samba介绍</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install samba</span><br></pre></td></tr></table></figure><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> sudo vim /etc/samba/smb.conf</span><br><span class="line"><span class="comment"># 在文件末尾添加以下内容</span></span><br><span class="line">[raspberrypi]</span><br><span class="line">    path = /home/tangshp</span><br><span class="line">    public = yes</span><br><span class="line">    writeable = yes</span><br><span class="line">    browseable = yes</span><br><span class="line">    guest ok = yes</span><br><span class="line">    create mask = 0777</span><br><span class="line">    directory mask = 0777</span><br><span class="line">    available = yes</span><br><span class="line">    comment = share folder</span><br><span class="line">    valid user = tangshp</span><br></pre></td></tr></table></figure><p><code>public</code>的命名后续会被用到</p><h2 id="添加samba用户"><a href="#添加samba用户" class="headerlink" title="添加samba用户"></a>添加samba用户</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo smbpasswd -a tangshp</span><br></pre></td></tr></table></figure><h2 id="重启smbd生效"><a href="#重启smbd生效" class="headerlink" title="重启smbd生效"></a>重启smbd生效</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/smbd restart</span><br></pre></td></tr></table></figure><h1 id="在windows上映射网络驱动器"><a href="#在windows上映射网络驱动器" class="headerlink" title="在windows上映射网络驱动器"></a>在windows上映射网络驱动器</h1><p><img src="/images/netDrivers.png" alt="网络驱动器"></p><blockquote><p>注意<code>ip</code>地址后的路径必须使用之前的<code>public</code>，必须要一致;要勾选<strong>使用其它凭据登入</strong></p></blockquote><p>最终效果如下图</p><p><img src="/images/netDriversNAT.png" alt="效果"></p>]]></content>
      
      
      <categories>
          
          <category> Linux的基本使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 网络驱动器 </tag>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-内核学习-01</title>
      <link href="/2021/08/15/Linux-%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0-01/"/>
      <url>/2021/08/15/Linux-%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0-01/</url>
      
        <content type="html"><![CDATA[<h1 id="生成linux-4-9-229内核镜像"><a href="#生成linux-4-9-229内核镜像" class="headerlink" title="生成linux-4.9.229内核镜像"></a>生成linux-4.9.229内核镜像</h1><h2 id="源码编译linux-4-9-229内核"><a href="#源码编译linux-4-9-229内核" class="headerlink" title="源码编译linux-4.9.229内核"></a>源码编译linux-4.9.229内核</h2><h3 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h3><blockquote><p>ubuntu 18.04<br>linux-4.9.229<br>busybox-1.30.0<br>qemu-system-x86_64</p></blockquote><h3 id="编译过程说明"><a href="#编译过程说明" class="headerlink" title="编译过程说明"></a>编译过程说明</h3><p>1.下载<a href="https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/linux-4.9.229.tar.gz">linux-4.9.229.tar.gz</a>并解压，进入<code>linux-4.9.229</code></p><p>2.`linux-4.9.229/arch/‘中包含很多框架的代码, 为了减少安装编译器的过程，我在本例中使用的是x86<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  linux-4.9.229 <span class="built_in">export</span> ARCH=x86</span><br></pre></td></tr></table></figure></p><p>3.生成默认编译选项<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  linux-4.9.229 make x86_64_defconfig</span><br></pre></td></tr></table></figure><br>默认配置文件被写入<code>.config</code>中。</p><p>4.自定义编译选项, 配置内核<br>这一步其实是对第2步的菜单进行微调，我们需要内核支持ramdisk驱动，所以需要选中如下配置：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  linux-4.9.229 make menuconfig</span><br></pre></td></tr></table></figure></p><blockquote><p>执行该命令后可能会报<code>fatal error: curses.h: 没有那个文件或目录</code>的错误, 则应该安装<code>libncurses5-dev</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ sudo apt-get install libncurses5-dev</span><br></pre></td></tr></table></figure></p></blockquote><p>安如下配置：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">General setup  ---&gt;</span><br><span class="line"></span><br><span class="line">       ----&gt; [*] Initial RAM filesystem and RAM disk (initramfs/initrd) support</span><br><span class="line"></span><br><span class="line">    Device Drivers  ---&gt;</span><br><span class="line"></span><br><span class="line">       [*] Block devices  ---&gt;</span><br><span class="line"></span><br><span class="line">               &lt;*&gt;   RAM block device support</span><br><span class="line"></span><br><span class="line">               (65536) Default RAM disk size (kbytes)</span><br></pre></td></tr></table></figure></p><ol><li>编译内核<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><blockquote><p>编译成功后的内核在<code>arch/x86_64/boot/bzImage</code></p></blockquote></li></ol><hr><h1 id="一个最小的busybox文件系统"><a href="#一个最小的busybox文件系统" class="headerlink" title="一个最小的busybox文件系统"></a>一个最小的busybox文件系统</h1><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>1.下载<a href="https://busybox.net/downloads/busybox-1.30.0.tar.bz2">busybox-1.30.0.tar.bz2</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tar xvf busybox-1.30.0.tar.bz2</span></span><br></pre></td></tr></table></figure></p><p>2.配置busybox源码</p><blockquote><p>在这里我们把busybox配置为静态编译，这样busybox在运行的时候就不需要额外的动态链接库了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># make menuconfig</span></span><br><span class="line"></span><br><span class="line">Busybox Settings  ---&gt;</span><br><span class="line">      Build Options  ---&gt;</span><br><span class="line">            [*] Build BusyBox as a static binary (no shared libs)</span><br></pre></td></tr></table></figure></p></blockquote><p>3.编译安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure></p><blockquote><p>不用担心<code>install</code>会安装到系统的文件中，没有加<code>sudo</code>权限；编译完成后的<code>busybox</code>就安装在源码根目录下的<code>_install</code>目录了; <code>_install/usr/bin</code>内中任意一个文件<code>file</code>都是链接到<code>busybox</code>这么一个可执行文件，运行时，<code>file</code>是<code>busybox</code>的参数</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  _install ls</span><br><span class="line">bin  linuxrc  sbin  usr</span><br></pre></td></tr></table></figure><ul><li><code>_install</code>下的文件不是一个完整的文件系统，需要完善；内核不能直接使用这些文件，所以完善后也不能直接使用；需要需要把这些文件打包成内核可识别的文件系统。</li></ul><h2 id="补充一些必要的文件"><a href="#补充一些必要的文件" class="headerlink" title="补充一些必要的文件"></a>补充一些必要的文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mkdir etc dev mnt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mkdir -p proc sys tmp mnt </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mkdir -p etc/init.d/ # 该文件夹存放一些开机启动的脚本</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># vim etc/fstab # 存放一些挂载的文件信息</span></span><br><span class="line">proc        /proc           proc         defaults        0        0</span><br><span class="line">tmpfs       /tmp            tmpfs    　　defaults        0        0</span><br><span class="line">sysfs       /sys            sysfs        defaults        0        0</span><br><span class="line"><span class="comment"># 把proc虚拟文件系统挂载在/proc下</span></span><br><span class="line"><span class="comment"># 把临时文件系统挂载在/tmp下</span></span><br><span class="line"><span class="comment"># sysfs文件系统挂载在/sys下</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># vim etc/init.d/rcS # 启动要运行的文件</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;Welcome to tinyLinux&quot;</span></span><br><span class="line">/bin/mount -a <span class="comment"># 把etc/fstab下的要挂载的文件挂载</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;Remounting the root filesystem&quot;</span></span><br><span class="line">mount  -o  remount,rw  / <span class="comment"># 重新挂载根文件系统, 使得跟文件系统可读可写</span></span><br><span class="line">mkdir -p /dev/pts</span><br><span class="line">mount -t devpts devpts /dev/pts <span class="comment"># 挂载文件系统</span></span><br><span class="line"><span class="built_in">echo</span> /sbin/mdev &gt; /proc/sys/kernel/hotplug <span class="comment"># 处理热插拔</span></span><br><span class="line">mdev -s</span><br><span class="line"></span><br><span class="line"><span class="comment"># chmod 755 etc/init.d/rcS #busybox在启动运行的一段代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># vim etc/inittab # busybox的一些启动文件</span></span><br><span class="line">::sysinit:/etc/init.d/rcS <span class="comment"># 调用rcS文件运行</span></span><br><span class="line">::respawn:-/bin/sh <span class="comment"># 使得可以在控制台使用命令</span></span><br><span class="line">::askfirst:-/bin/sh</span><br><span class="line">::ctrlaltdel:/bin/umount -a -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># chmod 755 etc/inittab</span></span><br><span class="line"><span class="comment"># cd dev</span></span><br><span class="line"><span class="comment"># mknod console c 5 1</span></span><br><span class="line"><span class="comment"># mknod null c 1 3</span></span><br><span class="line"><span class="comment"># mknod tty1 c 4 1</span></span><br></pre></td></tr></table></figure><blockquote><p>这样一个最小的、完整的可以被内核启动的文件系统就齐活啦。</p></blockquote><p>2.制作根文件系统镜像文件</p><blockquote><p>思路<br>   1.先制作一个空的镜像文件；<br>   2.然后把此镜像文件格式化为ext3格式；<br>   3.然后把此镜像文件挂载，并把根文件系统复制到挂载目录；<br>   4.卸载该镜像文件。<br>   5.打成gzip包。<br>打包脚本如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">rm -rf rootfs.ext3</span><br><span class="line">rm -rf fs</span><br><span class="line">dd <span class="keyword">if</span>=/dev/zero of=./rootfs.ext3 bs=1M count=32</span><br><span class="line">mkfs.ext3 rootfs.ext3</span><br><span class="line">mkdir fs</span><br><span class="line">mount -o loop rootfs.ext3 ./fs</span><br><span class="line">cp -rf ./_install/* ./fs</span><br><span class="line">umount ./fs</span><br><span class="line">gzip --best -c rootfs.ext3 &gt; rootfs.img.gz</span><br></pre></td></tr></table></figure><br>最终生成的文件系统镜像名字为：rootfs.img.gz</p><p>在ubuntu20.04中, 树莓派4B+8G的软硬件环境编译<code>busybox</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#----------------环境配置</span></span><br><span class="line"><span class="comment">#       aarch64-linux-gnu-g++</span></span><br><span class="line">sudo apt install -y g++ g++-aarch64-linux-gnu </span><br><span class="line"><span class="comment">#       menuconfig</span></span><br><span class="line">sudo apt install -y libncurses5-dev flex bison</span><br><span class="line"></span><br><span class="line"><span class="comment">#----------------编译过程</span></span><br><span class="line"><span class="comment">#下载源码</span></span><br><span class="line">wget https://busybox.net/downloads/busybox-1.31.1.tar.bz2</span><br><span class="line">tar -jxvf busybox-1.31.1.tar.bz2</span><br><span class="line"><span class="built_in">cd</span> busybox-1.31.1</span><br><span class="line"></span><br><span class="line"><span class="comment">#生成默认编译配置    生成文件大小约2.04MB。</span></span><br><span class="line">make defconfig    </span><br><span class="line"></span><br><span class="line"><span class="comment">#编辑配置</span></span><br><span class="line">make menuconfig</span><br><span class="line"><span class="comment">#Settings ---&gt;</span></span><br><span class="line"><span class="comment">#    --- Build Options</span></span><br><span class="line"><span class="comment">#    [ ] Build static binary (no shared libs)   #按“空格键”勾选此项。</span></span><br><span class="line"></span><br><span class="line">make -j8 ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu-    <span class="comment">#-j8代表8线程编译</span></span><br></pre></td></tr></table></figure></p></blockquote><h1 id="qemu模拟器启动"><a href="#qemu模拟器启动" class="headerlink" title="qemu模拟器启动"></a>qemu模拟器启动</h1><p>1.安装模拟器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ sudo apt-get install qemu-system-x86</span><br></pre></td></tr></table></figure></p><p>2.通过qemu模拟器启动我们自己编译的内核和文件系统：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># qemu-system-x86_64 \</span></span><br><span class="line">  -kernel ./linux-4.9.229/arch/x86_64/boot/bzImage  \</span><br><span class="line">  -initrd ./busybox-1.30.0/rootfs.img.gz   \</span><br><span class="line">  -append <span class="string">&quot;root=/dev/ram init=/linuxrc&quot;</span>  \</span><br><span class="line">  -serial file:output.txt</span><br></pre></td></tr></table></figure></p><h1 id="在树莓派-buntu20-04编译"><a href="#在树莓派-buntu20-04编译" class="headerlink" title="在树莓派+buntu20.04编译"></a>在树莓派+buntu20.04编译</h1><p>&gt;</p><h2 id="编译Linux内核"><a href="#编译Linux内核" class="headerlink" title="编译Linux内核"></a>编译Linux内核</h2><blockquote><p>编译流程与前述类似, 不同之处在以下; 同时编译得到的内核位于<code>Linux_ws/linux-4.9.229/arch/arm64/boot/Image</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> ARCH=arm64</span><br><span class="line"><span class="built_in">export</span> CROSS_COMPILE=aarch64-linux-gnu-</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="编译busybox文件系统"><a href="#编译busybox文件系统" class="headerlink" title="编译busybox文件系统"></a>编译busybox文件系统</h2><p>1.编译流程与前述类似, 不同之处在需修改<code>busybox-1.30.0/util-linux/rdata.c</code>,添加<code>stime</code>函数定义;<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">time_t</span> *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">        tv.tv_sec = *t;</span><br><span class="line">        tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> settimeofday(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.修改<code>fstab</code>文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  busybox-1.30.0 cat ./_install/etc/fstab</span><br><span class="line">proc        /proc           proc         defaults        0        0</span><br><span class="line">sysfs       /sys            sysfs        defaults        0        0</span><br><span class="line"><span class="comment">#tmpfs       /tmp            tmpfs    　　defaults        0        0</span></span><br></pre></td></tr></table></figure></p><p>3.修改打包方式<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  _install <span class="built_in">pwd</span></span><br><span class="line">/home/tangshp/Tools/Linux_ws/busybox-1.30.0/_install</span><br><span class="line">➜  _install find . | cpio -o --format=newc &gt; rootfs.img</span><br><span class="line">➜  busybox-1.30.0 cp ./_install/rootfs.img ./</span><br></pre></td></tr></table></figure></p><h2 id="使用模拟器启动"><a href="#使用模拟器启动" class="headerlink" title="使用模拟器启动"></a>使用模拟器启动</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  Linux_ws ls</span><br><span class="line">busybox-1.30.0  linux-4.9.229</span><br><span class="line">➜  Linux_ws sudo qemu-system-aarch64 -cpu cortex-a72 -machine <span class="built_in">type</span>=virt -nographic -smp 8 -m 1024M -kernel ./linux-4.9.229/arch/arm64/boot/Image -append <span class="string">&quot;root=/dev/ram rdinit=/linuxrc&quot;</span> -initrd ./busybox-1.30.0/rootfs.img -device virtio-scsi-device</span><br></pre></td></tr></table></figure><ul><li>退出<code>qemu-system-aarch64</code><blockquote><p>按下<kbd>ctrl</kbd>+<kbd>a</kbd> 后松开;按下<kbd>x</kbd></p></blockquote></li></ul><p><a href="https://www.bilibili.com/read/cv11271232">1.文档参考</a><br><a href="https://www.bilibili.com/video/BV1Vo4y117Xx">2.视频参考</a><br><a href="https://blog.csdn.net/u010739216/article/details/113914370">3.Ubuntu上使用qemu模拟Arm64 linux</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux内核 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C, 驱动开发, Linux内核 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 命令</title>
      <link href="/2021/08/15/Linux-%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/08/15/Linux-%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="查看系统信息"><a href="#查看系统信息" class="headerlink" title="查看系统信息"></a>查看系统信息</h1><h2 id="du"><a href="#du" class="headerlink" title="du"></a>du</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  drivers du -sh</span><br><span class="line">491M.</span><br></pre></td></tr></table></figure><h2 id="htop"><a href="#htop" class="headerlink" title="htop"></a>htop</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">htop</span><br></pre></td></tr></table></figure><p><img src="/images/htopRes.png" alt="htop查看cpu运行状态及进程信息"></p><h2 id="nproc"><a href="#nproc" class="headerlink" title="$(nproc)"></a><code>$(nproc)</code></h2><h2 id="查看cpu温度"><a href="#查看cpu温度" class="headerlink" title="查看cpu温度"></a>查看cpu温度</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜ ~ cat /sys/class/thermal/thermal_zone0/temp</span><br><span class="line">36511 <span class="comment"># 36511/1000 = 36.511 C°</span></span><br></pre></td></tr></table></figure><h2 id="查看cpu当前的频率"><a href="#查看cpu当前的频率" class="headerlink" title="查看cpu当前的频率"></a>查看cpu当前的频率</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ sudo cat /sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_cur_freq</span><br><span class="line">[sudo] password <span class="keyword">for</span> tangshp:</span><br><span class="line">1500000 <span class="comment"># hz</span></span><br></pre></td></tr></table></figure><h1 id="查看网络信息"><a href="#查看网络信息" class="headerlink" title="查看网络信息"></a>查看网络信息</h1><h2 id="ip-addr"><a href="#ip-addr" class="headerlink" title="ip addr"></a><code>ip addr</code></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜ Blog ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line"><span class="comment"># 回环接口</span></span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000</span><br><span class="line"><span class="comment"># 以太网</span></span><br><span class="line">3: wlan0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span><br><span class="line"><span class="comment"># 无线</span></span><br></pre></td></tr></table></figure><ul><li><code>ip addr show eth0</code><br>显示指定网卡<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts ip a s eth0</span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line">➜  Scripts ip addr show eth0</span><br></pre></td></tr></table></figure></li></ul><h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><h2 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h2><ul><li>递归地创建父级子级目录<br><code>mkdir -p aa/bb/cc</code><blockquote><p>如果aa不存在, 先创建aa; 如果bb不存在, 再继续创建bb; 最终创建cc</p></blockquote></li></ul><h2 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h2><h2 id="file"><a href="#file" class="headerlink" title="file"></a>file</h2><p>查看文件类型<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  P2 file a.c</span><br><span class="line">a.c: C <span class="built_in">source</span>, ASCII text</span><br><span class="line">➜  P2 file a.o</span><br><span class="line">a.o: ELF 64-bit LSB relocatable, ARM aarch64, version 1 (SYSV), not stripped <span class="comment"># 可重定位的ELF(Executable Linked Format)文件</span></span><br><span class="line">➜  P2 file a.out</span><br><span class="line">a.out: ELF 64-bit LSB shared object, ARM aarch64, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-aarch64.so.1, BuildID[sha1]=4713c0f336e8afc0c5742c06096106688ca52070, <span class="keyword">for</span> GNU/Linux 3.7.0, not stripped <span class="comment"># 可执行的文件</span></span><br></pre></td></tr></table></figure></p><h2 id="getconf"><a href="#getconf" class="headerlink" title="getconf"></a>getconf</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 查看glibc的版本</span><br><span class="line">➜  ~ getconf GNU_LIBC_VERSION </span><br><span class="line">glibc 2.31 </span><br><span class="line"># 查看操作系统的位数</span><br><span class="line">➜  ~ getconf LONG_BIT</span><br><span class="line">64</span><br></pre></td></tr></table></figure><h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><p><code>ps</code>命令用于显示当前进程的状态，类似于<code>windows</code>的任务管理器,全称为<code>process status</code>。</p><h3 id="ps-ef"><a href="#ps-ef" class="headerlink" title="ps -ef"></a><code>ps -ef</code></h3><ul><li><p>参数说明</p><ul><li><code>e</code> 等同于参数<code>A</code>,查看所有进程</li><li><code>f</code> full-format,以表格的形式展示</li></ul></li><li><p>示例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  build ps -ef | grep test_top</span><br><span class="line">tangshp    20460   17304  0 14:41 pts/2    00:00:00 ./test_top</span><br><span class="line">tangshp    20504   11929  0 14:41 pts/0    00:00:00 grep --color=auto test_top</span><br></pre></td></tr></table></figure><ul><li><code>tangshp</code>是启动该程序的用户</li><li><code>20460</code>是该程序的进程<code>ID</code></li><li><code>17304</code>是该程序的夫进程<code>ID</code>, 父进程<code>ID</code>小于子进程<code>ID</code></li><li><code>0</code>是<code>CPU</code>占用率</li><li><code>14:41</code>是程序的启动时间</li><li><code>pts/2</code>表示运行在哪个终端(虚拟终端); 如果是<code>?</code>,表示与终端无关;</li><li><code>00:00:00</code>是使用了多长时间<code>CPU</code></li><li><code>./test_top</code>是应用程序的名字</li></ul></li></ul><h3 id="ps-aux"><a href="#ps-aux" class="headerlink" title="ps -aux"></a><code>ps -aux</code></h3><p><code>ps -aux</code>使用<code>BSD</code>风格显示进程状态</p><ul><li>示例<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  build ps -aux | grep test_top</span><br><span class="line">tangshp    20460  0.1  0.0  10320   508 pts/2    Sl+  14:41   0:02 ./test_top</span><br><span class="line">tangshp    21058  0.0  0.0   9048   756 pts/0    S+   15:11   0:00 grep --color=auto test_top</span><br><span class="line">➜  build ps -aux | head -n 1</span><br><span class="line">USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br></pre></td></tr></table></figure><ul><li><code>VSZ</code>表示使用的虚拟内存(Kbytes)</li><li><code>RSS</code>表示使用的固定内存(Kbytes)</li><li><code>STAT</code>表示进程的状态; 查看<code>man ps</code>中的<code>PROCESS STATE CODES</code>可知<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">D    uninterruptible sleep (usually IO) 不可终端状态</span><br><span class="line">I    Idle kernel thread</span><br><span class="line">R    running or runnable (on run queue) 目前正在运行或者在运行队列中</span><br><span class="line">S    interruptible sleep (waiting <span class="keyword">for</span> an event to complete) 表示该程序正在睡眠中,但可以被某些信号唤醒</span><br><span class="line">T    stopped by job control signal 目前该程序暂停了,转到后台运行</span><br><span class="line">t    stopped by debugger during the tracing</span><br><span class="line">W    paging (not valid since the 2.6.xx kernel)</span><br><span class="line">X    dead (should never be seen)</span><br><span class="line">Z    defunct (<span class="string">&quot;zombie&quot;</span>) process, terminated but not reaped by its parent 僵尸进程(该进程已经中止,但父进程却无法正常的中止它)</span><br><span class="line">Others-------------</span><br><span class="line">&lt;    high-priority (not nice to other users) 高优先级</span><br><span class="line">N    low-priority (nice to other users) 低优先级</span><br><span class="line">L    has pages locked into memory (<span class="keyword">for</span> real-time and custom IO) </span><br><span class="line">s    is a session leader 有子进程</span><br><span class="line">l    is multi-threaded (using CLONE_THREAD, like NPTL pthreads <span class="keyword">do</span>) 多线程进程</span><br><span class="line">+    is <span class="keyword">in</span> the foreground process group 前台运行</span><br></pre></td></tr></table></figure><blockquote><p><kbd>Ctrl</kbd>+<kbd>z</kbd>是发送<code>SIGSTOP</code>信号,<strong>挂起</strong>一个进程, 使其暂停;转到后台运行<br><kbd>Ctrl</kbd>+<kbd>c</kbd>是发送<code>SIGINT</code>信号,<strong>中止</strong>一个进程, 使其停止</p></blockquote></li></ul></li></ul><p><strong>僵尸进程</strong>:僵尸进程是当<strong>子进程</strong>比<strong>父进程</strong>先结束,而<strong>父进程</strong>又<strong>没有回收子进程</strong>,<strong>没有释放子进程占用的资源</strong>,此时子进程将成为一个僵尸进程。如果<strong>父进程先退出</strong>,子进程被init接管,子进程退出后init会回收其占用的相关资源。</p><h3 id="ps-1"><a href="#ps-1" class="headerlink" title="ps"></a><code>ps</code></h3><p>查看当前终端下执行的程序<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  build ./test_top 2&gt;thread_log.txt&amp;</span><br><span class="line">[1] 23054</span><br><span class="line">[1]  + 23054 suspended (tty input)  ./test_top 2&gt; thread_log.txt</span><br><span class="line">➜  build ps</span><br><span class="line">    PID TTY          TIME CMD</span><br><span class="line">  22724 pts/2    00:00:07 zsh <span class="comment"># 负责当前终端-&gt;相关打印</span></span><br><span class="line">  23054 pts/2    00:00:00 test_top <span class="comment"># 当前终端运行的程序</span></span><br><span class="line">  23059 pts/2    00:00:00 ps <span class="comment"># 正在执行的ps</span></span><br></pre></td></tr></table></figure></p><h2 id="top"><a href="#top" class="headerlink" title="top"></a><code>top</code></h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p><strong>动态</strong>查看进程状态(可实时更新进程状态)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">top - 15:45:18 up  6:37,  3 users,  load average: 0.10, 0.10, 0.09</span><br><span class="line">Tasks: 186 total,   1 running, 183 sleeping,   2 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  0.2 us,  0.3 sy,  0.0 ni, 99.5 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">MiB Mem :   7759.4 total,   5449.4 free,    580.4 used,   1729.6 buff/cache</span><br><span class="line">MiB Swap:      0.0 total,      0.0 free,      0.0 used.   7064.9 avail Mem</span><br></pre></td></tr></table></figure></p><ul><li>第一行和<code>uptime</code>的结果一模一样</li><li><code>Tasks: 186 total,   1 running, 183 sleeping,   2 stopped,   0 zombie</code>分别表示<strong>进程</strong>的数量, <strong>运行进程</strong>的数量, <strong>睡眠的进程</strong>的数量, <strong>暂停的进程</strong>的数量, <strong>僵尸进程</strong>的数量;   </li><li>在使用<code>top</code>查看动态进程状态时,按下<kbd>1</kbd>时, 第3行会变成如下(显示每个核的具体信息, 这里可知为什么<code>CPU</code>使用率会超过100%, 多核的原因); <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%Cpu0  :  0.3 us,  0.3 sy,  0.0 ni, 99.3 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">%Cpu1  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">%Cpu2  :  0.0 us,  1.0 sy,  0.0 ni, 99.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">%Cpu3  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br></pre></td></tr></table></figure><ul><li><code>us</code> 用户进程使用<code>CPU</code>的百分比</li><li><code>sy</code> 内核进程使用<code>CPU</code>的百分比</li><li><code>ni</code> 用户空间内<strong>改变过优先级的进程</strong>占用<code>CPU</code>的百分比</li><li><code>id</code> 空闲<code>CPU</code>的百分比</li></ul></li><li><code>MiB Mem :   7759.4 total,   5449.4 free,    580.4 used,   1729.6 buff/cache</code>分别表示<strong>物理内存</strong>的总量,<strong>空闲内存</strong>的总量,<strong>已使用内存</strong>的总量,<strong>缓存</strong>的总量<blockquote><p>后三项之和等于第一项</p></blockquote></li></ul><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><ul><li>默认是<code>3s</code>的刷新周期, 使用<kbd>space</kbd>手动刷新</li><li>使用<kbd>q</kbd>退出</li><li>使用<kbd>M</kbd>对<strong>内存排序</strong></li><li>使用<kbd>P</kbd>对<code>CPU</code>排序</li><li>使用<kbd> &lt; </kbd> 或 <kbd> &gt; </kbd> 翻页</li></ul><h3 id="查看进程的线程是否运行"><a href="#查看进程的线程是否运行" class="headerlink" title="查看进程的线程是否运行"></a>查看进程的线程是否运行</h3><p>运行<a href="/2021/10/02/Linux系统编程-04-Pthreads/">6.3中的程序</a>, 主线程接收<code>start</code>或者<code>stop</code>来开启子线程;按如下运行</p><ul><li><code>start</code><br>按一下运行<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start <span class="comment"># 开启子线程</span></span><br><span class="line">start new thread.</span><br><span class="line">can<span class="string">&#x27;t set process name.</span></span><br><span class="line"><span class="string">process name is do_something.</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ ps -ef | grep test_top</span><br><span class="line">tangshp    21717   11929  0 16:37 pts/0    00:00:00 ./test_top</span><br><span class="line">tangshp    21738   17056  0 16:38 pts/3    00:00:00 grep --color=auto test_top</span><br><span class="line">➜  ~ top -Hp 21717 <span class="comment"># 可知子线程开启</span></span><br><span class="line">top - 16:38:41 up  7:30,  3 users,  load average: 0.01, 0.06, 0.01</span><br><span class="line">Threads:   2 total,   0 running,   2 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  0.0 us,  0.2 sy,  0.0 ni, 99.8 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">MiB Mem :   7759.4 total,   5702.2 free,    334.6 used,   1722.5 buff/cache</span><br><span class="line">MiB Swap:      0.0 total,      0.0 free,      0.0 used.   7310.7 avail Mem</span><br><span class="line"></span><br><span class="line">    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND</span><br><span class="line">  21717 tangshp   20   0   10320    512    440 S   0.0   0.0   0:00.00 test_top</span><br><span class="line">  21718 tangshp   20   0   10320    512    440 S   0.0   0.0   0:00.03 do_something</span><br></pre></td></tr></table></figure><ul><li><code>stop</code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stop <span class="comment"># 关闭子线程</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ top -Hp 21717</span><br><span class="line">top - 16:39:44 up  7:31,  3 users,  load average: 0.00, 0.05, 0.01</span><br><span class="line">Threads:   1 total,   0 running,   1 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  0.0 us,  0.2 sy,  0.0 ni, 99.8 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">MiB Mem :   7759.4 total,   5700.3 free,    336.4 used,   1722.7 buff/cache</span><br><span class="line">MiB Swap:      0.0 total,      0.0 free,      0.0 used.   7308.9 avail Mem</span><br><span class="line"></span><br><span class="line">    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND</span><br><span class="line">  21717 tangshp   20   0   10320    780    696 S   0.0   0.0   0:00.00 test_top</span><br></pre></td></tr></table></figure><h2 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a><code>uptime</code></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  build uptime</span><br><span class="line"> 15:48:29 up  6:40,  3 users,  load average: 0.00, 0.05, 0.07</span><br></pre></td></tr></table></figure><ul><li><code>15:48:29</code>是<strong>系统时间</strong></li><li><code>6:40</code>是<strong>系统运行时长</strong></li><li><code>3</code>表示<strong>有3个用户</strong></li><li><strong>系统负载</strong>(任务队列长度),表示过去<code>1min</code>,<code>5mins</code>,<code>15mins</code>内平均值<blockquote><p>内核数量X3 <code>&gt;</code> 系统负载(0.07)时表示<strong>负载不严重</strong></p></blockquote></li></ul><h2 id="xxd"><a href="#xxd" class="headerlink" title="xxd"></a><code>xxd</code></h2><p>使用<code>xxd</code>把给定的文件转化为<strong>16进制</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  build xxd /bin/ls | less</span><br><span class="line">00000000: 7f45 4c46 0201 0100 0000 0000 0000 0000  .ELF............</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><blockquote><p>其中第3个字节到第5个字节<code>45 4c46</code>对应<code>ELF</code>(查看<code>man ascii</code>可知)</p></blockquote><h2 id="cat"><a href="#cat" class="headerlink" title="cat"></a><code>cat</code></h2><p><code>echo_a.txt</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello world, I&#x27;m for show echo -A </span><br><span class="line">&quot;China&quot; </span><br></pre></td></tr></table></figure><ul><li><p><code>-A</code> - 显示所有的字符(包括换行和结束符)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts cat -A ./echo_a.txt</span><br><span class="line">hello world, I<span class="string">&#x27;m for show echo -A $</span></span><br><span class="line"><span class="string">&quot;China&quot; % </span></span><br></pre></td></tr></table></figure></li><li><p><code>-n</code> - 显示行号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts cat -n ./echo_a.txt </span><br><span class="line">     1  hello world, I<span class="string">&#x27;m for show echo -A </span></span><br><span class="line"><span class="string">     2  &quot;China&quot;%   </span></span><br></pre></td></tr></table></figure></li></ul><h2 id="column"><a href="#column" class="headerlink" title="column"></a>column</h2><ul><li><strong>列对齐</strong> <code>-t</code><br><strong>对齐前</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts ls -lh | awk <span class="string">&#x27;NR&gt;1&#123;print $5,$9&#125;&#x27;</span></span><br><span class="line">40 0-debug.sh</span><br><span class="line">131 ascii.txt</span><br><span class="line">137 bracket.txt</span><br><span class="line">56 echo_a.txt</span><br><span class="line">603 grep_help.txt</span><br><span class="line">10 id_card_list.txt</span><br><span class="line">177 id.txt</span><br><span class="line">78 p.py</span><br><span class="line">72 question_mark.txt</span><br><span class="line">225 sed_test.txt</span><br></pre></td></tr></table></figure><strong>对齐后</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts ls -lh | awk <span class="string">&#x27;NR&gt;1&#123;print $5,$9&#125;&#x27;</span> | column -t</span><br><span class="line">40   0-debug.sh</span><br><span class="line">131  ascii.txt</span><br><span class="line">137  bracket.txt</span><br><span class="line">56   echo_a.txt</span><br><span class="line">603  grep_help.txt</span><br><span class="line">10   id_card_list.txt</span><br><span class="line">177  id.txt</span><br><span class="line">78   p.py</span><br><span class="line">72   question_mark.txt</span><br><span class="line">225  sed_test.txt</span><br></pre></td></tr></table></figure></li></ul><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><p>素材参考<a href="/2021/11/21/shell编程/">awk数组运用</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  Scripts awk -F/ <span class="string">&#x27;&#123;array[$3]++&#125;END&#123;for(i in array)print i,array[i]&#125;&#x27;</span> ./url.txt | column -t | sort -rnk2</span><br><span class="line">github.com                       3</span><br><span class="line">leetcode-cn.com                  2</span><br><span class="line">www.open3d.org                   1</span><br><span class="line">realpython.com                   1</span><br><span class="line">python3-cookbook.readthedocs.io  1</span><br></pre></td></tr></table></figure></p><ul><li><code>-r, --reverse; reverse the result of comparisons</code> <strong>逆序</strong></li><li><code>-n, --numeric-sort; compare according to string numerical value</code> <strong>根据字符串对应数组排序</strong></li><li><code>-k, --key=KEYDEF;sort via a key; KEYDEF gives location and type</code> <strong>根据第几列排序</strong></li></ul><h2 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h2><ul><li>统计文件的<strong>行数</strong>、<strong>单词数</strong>、<strong>文件大小</strong>(<code>byte</code>)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  draft_ws wc ./SimpleSection_h.txt </span><br><span class="line">  19   88 1027 ./SimpleSection_h.txt</span><br></pre></td></tr></table></figure></li></ul><h2 id="size"><a href="#size" class="headerlink" title="size"></a>size</h2><p>查看<code>ELF</code>文件的<strong>代码段</strong>、<strong>数据段</strong>和<code>BSS</code>的长度,及这<code>3</code>段总和(<strong>十进制和十六进制</strong>)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  draft_ws size SimpleSection.o</span><br><span class="line">   text    data     bss     dec     hex filename</span><br><span class="line">    216      12      12     240      f0 SimpleSection.o</span><br></pre></td></tr></table></figure></p><h2 id="objdump"><a href="#objdump" class="headerlink" title="objdump"></a>objdump</h2><p>结合<a href="/2021/12/17/链接、装载与库3/">链接、装载与库3</a>内容学习以下内容</p><h3 id="h"><a href="#h" class="headerlink" title="-h"></a><code>-h</code></h3><p>查看<strong>目标文件</strong>的<code>section header</code>的<strong>摘要信息</strong><br><code>Display summary information from the section headers of the object file.</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">➜  draft_ws objdump -h ./SimpleSection.o                                            </span><br><span class="line"></span><br><span class="line">./SimpleSection.o:     file format elf64-littleaarch64</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  0 .text         0000007c  0000000000000000  0000000000000000  00000040  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE</span><br><span class="line">  1 .data         0000000c  0000000000000000  0000000000000000  000000bc  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  2 .bss          0000000c  0000000000000000  0000000000000000  000000c8  2**2</span><br><span class="line">                  ALLOC</span><br><span class="line">  3 .rodata       00000004  0000000000000000  0000000000000000  000000c8  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  4 .comment      0000002b  0000000000000000  0000000000000000  000000cc  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  5 .note.GNU-stack 00000000  0000000000000000  0000000000000000  000000f7  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line">  6 .eh_frame     00000058  0000000000000000  0000000000000000  000000f8  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA</span><br></pre></td></tr></table></figure><br><br></p><h3 id="d"><a href="#d" class="headerlink" title="-d"></a><code>-d</code></h3><p>查看<strong>目标文件</strong>的<strong>机器代码</strong>与相应的<strong>汇编代码</strong><br><code>Display the assembler mnemonics for the machine instructions from the input file.</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">➜  draft_ws objdump -d ./SimpleSection.o</span><br><span class="line"></span><br><span class="line">./SimpleSection.o:     file format elf64-littleaarch64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;func1&gt;:</span><br><span class="line">   0:   a9be7bfd        stp     x29, x30, [sp, <span class="comment">#-32]!</span></span><br><span class="line">   4:   910003fd        mov     x29, sp</span><br><span class="line">   8:   b9001fe0        str     w0, [sp, <span class="comment">#28]</span></span><br><span class="line">   c:   b9401fe1        ldr     w1, [sp, <span class="comment">#28]</span></span><br><span class="line">  10:   90000000        adrp    x0, 0 &lt;func1&gt;</span><br><span class="line">  14:   91000000        add     x0, x0, <span class="comment">#0x0</span></span><br><span class="line">  18:   94000000        bl      0 &lt;<span class="built_in">printf</span>&gt;</span><br><span class="line">  1c:   d503201f        nop</span><br><span class="line">  20:   a8c27bfd        ldp     x29, x30, [sp], <span class="comment">#32</span></span><br><span class="line">  24:   d65f03c0        ret</span><br><span class="line"></span><br><span class="line">0000000000000028 &lt;main&gt;:</span><br><span class="line">  28:   a9be7bfd        stp     x29, x30, [sp, <span class="comment">#-32]!</span></span><br><span class="line">  2c:   910003fd        mov     x29, sp</span><br><span class="line">  30:   52800140        mov     w0, <span class="comment">#0xa                        // #10</span></span><br><span class="line">  34:   b90017e0        str     w0, [sp, <span class="comment">#20]</span></span><br><span class="line">  38:   52800020        mov     w0, <span class="comment">#0x1                        // #1</span></span><br><span class="line">  3c:   b9001be0        str     w0, [sp, <span class="comment">#24]</span></span><br><span class="line">  40:   90000000        adrp    x0, 0 &lt;func1&gt;</span><br><span class="line">  44:   91000000        add     x0, x0, <span class="comment">#0x0</span></span><br><span class="line">  48:   b9400001        ldr     w1, [x0]</span><br><span class="line">  4c:   90000000        adrp    x0, 0 &lt;func1&gt;</span><br><span class="line">  50:   91000000        add     x0, x0, <span class="comment">#0x0</span></span><br><span class="line">  54:   b9400000        ldr     w0, [x0]</span><br><span class="line">  58:   0b000021        add     w1, w1, w0</span><br><span class="line">  5c:   b9401be0        ldr     w0, [sp, <span class="comment">#24]</span></span><br><span class="line">  60:   0b000021        add     w1, w1, w0</span><br><span class="line">  64:   b9401fe0        ldr     w0, [sp, <span class="comment">#28]</span></span><br><span class="line">  68:   0b000020        add     w0, w1, w0</span><br><span class="line">  6c:   94000000        bl      0 &lt;func1&gt;</span><br><span class="line">  70:   52800000        mov     w0, <span class="comment">#0x0                        // #0</span></span><br><span class="line">  74:   a8c27bfd        ldp     x29, x30, [sp], <span class="comment">#32</span></span><br><span class="line">  78:   d65f03c0        ret</span><br></pre></td></tr></table></figure><br><br></p><h3 id="s"><a href="#s" class="headerlink" title="-s"></a><code>-s</code></h3><p>查看目标文件所有<code>section</code>的内容<br><code>Display the full contents of any sections requested.  By default all non-empty sections are displayed.</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">➜  draft_ws objdump -s ./SimpleSection.o</span><br><span class="line"></span><br><span class="line">./SimpleSection.o:     file format elf64-littleaarch64</span><br><span class="line"></span><br><span class="line">Contents of section .text:</span><br><span class="line"> 0000 fd7bbea9 fd030091 e01f00b9 e11f40b9  .&#123;............@.</span><br><span class="line"> 0010 00000090 00000091 00000094 1f2003d5  ............. ..</span><br><span class="line"> 0020 fd7bc2a8 c0035fd6 fd7bbea9 fd030091  .&#123;...._..&#123;......</span><br><span class="line"> 0030 40018052 e01700b9 20008052 e01b00b9  @..R.... ..R....</span><br><span class="line"> 0040 00000090 00000091 010040b9 00000090  ..........@.....</span><br><span class="line"> 0050 00000091 000040b9 2100000b e01b40b9  ......@.!.....@.</span><br><span class="line"> 0060 2100000b e01f40b9 2000000b 00000094  !.....@. .......</span><br><span class="line"> 0070 00008052 fd7bc2a8 c0035fd6           ...R.&#123;...._.    </span><br><span class="line">Contents of section .data:</span><br><span class="line"> 0000 54000000 55000000 01000000           T...U.......    </span><br><span class="line">Contents of section .rodata:</span><br><span class="line"> 0000 25640a00                             %d..            </span><br><span class="line">Contents of section .comment:</span><br><span class="line"> 0000 00474343 3a202855 62756e74 7520392e  .GCC: (Ubuntu 9.</span><br><span class="line"> 0010 332e302d 31377562 756e7475 317e3230  3.0-17ubuntu1~20</span><br><span class="line"> 0020 2e303429 20392e33 2e3000             .04) 9.3.0.     </span><br><span class="line">Contents of section .eh_frame:</span><br><span class="line"> 0000 10000000 00000000 017a5200 04781e01  .........zR..x..</span><br><span class="line"> 0010 1b0c1f00 1c000000 18000000 00000000  ................</span><br><span class="line"> 0020 28000000 00410e20 9d049e03 48dedd0e  (....A. ....H...</span><br><span class="line"> 0030 00000000 20000000 38000000 00000000  .... ...8.......</span><br><span class="line"> 0040 54000000 00410e20 9d049e03 53dedd0e  T....A. ....S...</span><br><span class="line"> 0050 00000000 00000000                    ........  </span><br></pre></td></tr></table></figure><br><br></p><h3 id="t"><a href="#t" class="headerlink" title="-t"></a><code>-t</code></h3><p>查看符号表中的<strong>每个符号</strong>在哪个<code>section</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">➜  draft_ws git:(master) ✗ objdump -t ./SimpleSection.o </span><br><span class="line"></span><br><span class="line">./SimpleSection.o:     file format elf64-littleaarch64</span><br><span class="line"></span><br><span class="line">SYMBOL TABLE:</span><br><span class="line">0000000000000000 l    df *ABS*  0000000000000000 SimpleSection.c</span><br><span class="line">0000000000000000 l    d  .text  0000000000000000 .text</span><br><span class="line">0000000000000000 l    d  .data  0000000000000000 .data</span><br><span class="line">0000000000000000 l    d  .bss   0000000000000000 .bss</span><br><span class="line">0000000000000000 l     O .bss   0000000000000004 global_static_uninit_var</span><br><span class="line">0000000000000000 l    d  .rodata        0000000000000000 .rodata</span><br><span class="line">0000000000000004 l     O .data  0000000000000004 static_var.3416</span><br><span class="line">0000000000000004 l     O .bss   0000000000000004 static_var2.3417</span><br><span class="line">0000000000000008 l     O .bss   0000000000000004 static_b.3419</span><br><span class="line">0000000000000008 l     O .data  0000000000000004 static_a.3418</span><br><span class="line">0000000000000000 l    d  .note.GNU-stack        0000000000000000 .note.GNU-stack</span><br><span class="line">0000000000000000 l    d  .eh_frame      0000000000000000 .eh_frame</span><br><span class="line">0000000000000000 l    d  .comment       0000000000000000 .comment</span><br><span class="line">0000000000000000 g     O .data  0000000000000004 global_init_var</span><br><span class="line">0000000000000004       O *COM*  0000000000000004 extern_global_uninit_var</span><br><span class="line">0000000000000000 g     F .text  0000000000000028 func1</span><br><span class="line">0000000000000000         *UND*  0000000000000000 <span class="built_in">printf</span></span><br><span class="line">0000000000000028 g     F .text  0000000000000054 main</span><br></pre></td></tr></table></figure></p><p><br><br></p><h2 id="readelf"><a href="#readelf" class="headerlink" title="readelf"></a><code>readelf</code></h2><p>获取<code>elf</code>文件的相关信息, 包括<code>elf</code>文件的<code>header</code>, 文件内容的分布,指令集体系结果,入口地址等;使用代码解析的话,可以使用<code>/usr/include/elf.h</code>提供必要的定义;</p><h3 id="h-1"><a href="#h-1" class="headerlink" title="-h"></a><code>-h</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">➜  draft_ws readelf -h ./SimpleSection.o                               </span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2<span class="string">&#x27;s complement, little endian</span></span><br><span class="line"><span class="string">  Version:                           1 (current)</span></span><br><span class="line"><span class="string">  OS/ABI:                            UNIX - System V</span></span><br><span class="line"><span class="string">  ABI Version:                       0</span></span><br><span class="line"><span class="string">  Type:                              REL (Relocatable file)</span></span><br><span class="line"><span class="string">  Machine:                           AArch64</span></span><br><span class="line"><span class="string">  Version:                           0x1</span></span><br><span class="line"><span class="string">  Entry point address:               0x0</span></span><br><span class="line"><span class="string">  Start of program headers:          0 (bytes into file)</span></span><br><span class="line"><span class="string">  Start of section headers:          1424 (bytes into file)</span></span><br><span class="line"><span class="string">  Flags:                             0x0</span></span><br><span class="line"><span class="string">  Size of this header:               64 (bytes)</span></span><br><span class="line"><span class="string">  Size of program headers:           0 (bytes)</span></span><br><span class="line"><span class="string">  Number of program headers:         0</span></span><br><span class="line"><span class="string">  Size of section headers:           64 (bytes)</span></span><br><span class="line"><span class="string">  Number of section headers:         13</span></span><br><span class="line"><span class="string">  Section header string table index: 12</span></span><br></pre></td></tr></table></figure><p><br><br></p><h2 id="nm"><a href="#nm" class="headerlink" title="nm"></a><code>nm</code></h2><p><code>nm - list symbols from object files</code>列出目标文件中的符号<br><strong>示例参考</strong><code>cut</code></p><p><br><br></p><h2 id="c-filt"><a href="#c-filt" class="headerlink" title="c++filt"></a><code>c++filt</code></h2><p><code>demangle C++ and Java symbols</code>解析<code>C++与Java</code>的符号</p><blockquote><p>对于<code>C++</code>而言, 使用了<strong>符号修饰(<code>Name Decoration</code>)</strong>或<strong>符号改编(<code>Name Mangling</code>)</strong></p></blockquote><p><strong>示例参考</strong><code>cut</code></p><p><br><br></p><h2 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h2><p><code>cut</code> 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段写至标准输出</p><h3 id="d-1"><a href="#d-1" class="headerlink" title="-d"></a><code>-d</code></h3><p>自定义分隔符，默认为<strong>制表符</strong>,需结合<code>-f</code>使用<br><br></p><h3 id="f"><a href="#f" class="headerlink" title="-f"></a><code>-f</code></h3><p>用作指定显示<strong>第几列</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  draft_ws git:(master) ✗ g++ -c ./decorate.cc -o decorate.o</span><br><span class="line">➜  draft_ws git:(master) ✗ nm decorate.o | cut -d <span class="string">&quot; &quot;</span> -f 3 | c++filt | grep func</span><br><span class="line">func(<span class="built_in">float</span>)</span><br><span class="line">func(int)</span><br><span class="line">C::C2::func(int)</span><br><span class="line">C::func(int)</span><br><span class="line">N::C::func(int)</span><br><span class="line">N::func(int)</span><br></pre></td></tr></table></figure><p><code>decorate.cc</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// decorate.cc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;int func(int i)\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">func</span><span class="params">(<span class="keyword">float</span> i)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;float func(float i)\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;float C::func(int i)\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">C2</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;int C2::C::func(int i)\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> N&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;int N::func(int i)\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">C</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;int N::C::func(int i)\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">    C c;</span><br><span class="line">    c.<span class="built_in">func</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    C::C2 c2;</span><br><span class="line">    c2.<span class="built_in">func</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    N::C nc;</span><br><span class="line">    nc.<span class="built_in">func</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p><br><br><br></p><h1 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h1><h2 id="递归地添加权限"><a href="#递归地添加权限" class="headerlink" title="递归地添加权限"></a>递归地添加权限</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod -R 720 /home/ismail/</span><br></pre></td></tr></table></figure><h1 id="第三方工具的使用"><a href="#第三方工具的使用" class="headerlink" title="第三方工具的使用"></a>第三方工具的使用</h1><h2 id="pm2"><a href="#pm2" class="headerlink" title="pm2"></a>pm2</h2><blockquote><p>pm2的安装参考<a href="/2021/09/02/Linux常用工具安装/index.html">pm2的安装</a></p><ul><li>使用pm2让hexo在后台运行</li></ul><ol><li>新建脚本<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//run.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; exec &#125; = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>)</span><br><span class="line">exec(<span class="string">&#x27;hexo server&#x27;</span>,<span class="function">(<span class="params">error, stdout, stderr</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(error)&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;exec error: $&#123;error&#125;&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;stdout: $&#123;stdout&#125;&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;stderr: $&#123;stderr&#125;&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol></blockquote><ol><li>使用pm2运行<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ Blog pm2 start run.js</span><br></pre></td></tr></table></figure><img src="/images/pmstart.png" alt="pm2 start run.js"></li></ol><ul><li>其它基本用法</li></ul><ol><li><p>查看进程状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ Blog pm2 list</span><br></pre></td></tr></table></figure></li><li><p>重启运用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 restart app.js</span><br></pre></td></tr></table></figure></li><li><p>停止特定的应用。可以先通过pm2 list获取应用的名字（—name指定的）或者进程id</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 stop app_name|app_id</span><br></pre></td></tr></table></figure></li><li><p>停止所有应用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 stop all</span><br></pre></td></tr></table></figure></li></ol><h1 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h1><h2 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看系统用户</span></span><br><span class="line">cat /etc/passwd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建新用户</span></span><br><span class="line">sudo adduser myuser <span class="comment"># 这样用户也创建好, 会要求设置密码</span></span><br></pre></td></tr></table></figure><blockquote><p>新建的用户使用sudo, 会报<code>myuser is not in the sudoers file.  This incident will be reported.</code><br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#添加sudo文件的写权限,命令是:</span></span><br><span class="line">chmod u+w /etc/sudoers</span><br><span class="line"></span><br><span class="line"><span class="comment">#编辑sudoers文件</span></span><br><span class="line">vi /etc/sudoers</span><br><span class="line"><span class="comment">#在 root ALL=(ALL) ALL,下面添加myuser ALL=(ALL) ALL </span></span><br><span class="line">myuser ALL=(ALL) ALL</span><br></pre></td></tr></table></figure></p></blockquote><hr><h1 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h1><h2 id="本地与全局"><a href="#本地与全局" class="headerlink" title="本地与全局"></a>本地与全局</h2><p>npm的包安装分为本地安装<code>local</code>、全局安装<code>global</code>两种，从敲的命令行来看，差别只是有没有<code>-g</code>而已，比如<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install grunt <span class="comment"># 本地安装</span></span><br><span class="line">npm install -g grunt-cli <span class="comment"># 全局安装</span></span><br></pre></td></tr></table></figure><br>主要区别在于:</p><ul><li>本地安装<br><strong> 将安装包放在<code>./node_modules</code>下（运行<code>npm</code>时所在的目录）</strong> 可以通过<code>require()</code>来引入本地安装的包</li><li>全局安装<br><strong> 将安装包放在<code>/usr/local</code>下</strong> 可以直接在命令行里使用</li></ul><h2 id="—save"><a href="#—save" class="headerlink" title="—save"></a>—save</h2><ul><li>在<code>npm 5</code>之前的版本<br>使用<code>npm install</code>默认选项安装包时，仅仅会把包下载到<code>node_modules/</code>中，并不会同时修改 <code>package.json</code>。而使用<code>--save</code>选项就可以在安装包的同时，修改<code>package.json</code>文件</li><li>在<code>npm 5</code>之后的版本<br><code>npm install</code>安装包时，默认便会修改<code>package.json</code>文件，所以<code>--save</code>选项已经不再需要了。</li></ul><h1 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h1><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>配置文件位于<code>/etc/vim/vimrc</code>, 可以对其进行相应的设置</p><ul><li>设置<code>tab</code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> ts=4</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux的基本使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Use markdown in hexo</title>
      <link href="/2021/08/08/Use-markdown-in-hexo/"/>
      <url>/2021/08/08/Use-markdown-in-hexo/</url>
      
        <content type="html"><![CDATA[<h1 id="Headers"><a href="#Headers" class="headerlink" title="Headers"></a>Headers</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># H1</span></span><br><span class="line"><span class="section">## H2</span></span><br><span class="line"><span class="section">### H3</span></span><br><span class="line"><span class="section">#### H4</span></span><br><span class="line"><span class="section">##### H5</span></span><br><span class="line"><span class="section">###### H6</span></span><br><span class="line"></span><br><span class="line">Alternatively, for H1 and H2, an underline-ish style:</span><br><span class="line"></span><br><span class="line"><span class="section">Alt-H1</span></span><br><span class="line"><span class="section">======</span></span><br><span class="line"></span><br><span class="line"><span class="section">Alt-H2</span></span><br><span class="line"><span class="section">------</span></span><br></pre></td></tr></table></figure><h1 id="H1"><a href="#H1" class="headerlink" title="H1"></a>H1</h1><h2 id="H2"><a href="#H2" class="headerlink" title="H2"></a>H2</h2><h3 id="H3"><a href="#H3" class="headerlink" title="H3"></a>H3</h3><h4 id="H4"><a href="#H4" class="headerlink" title="H4"></a>H4</h4><h5 id="H5"><a href="#H5" class="headerlink" title="H5"></a>H5</h5><h6 id="H6"><a href="#H6" class="headerlink" title="H6"></a>H6</h6><p>Alternatively, for H1 and H2, an underline-ish style:</p><h1 id="Alt-H1"><a href="#Alt-H1" class="headerlink" title="Alt-H1"></a>Alt-H1</h1><h2 id="Alt-H2"><a href="#Alt-H2" class="headerlink" title="Alt-H2"></a>Alt-H2</h2><h1 id="Emphasis"><a href="#Emphasis" class="headerlink" title="Emphasis"></a>Emphasis</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Emphasis, aka italics, with <span class="emphasis">*asterisks*</span> or <span class="emphasis">_underscores_</span>.</span><br><span class="line"></span><br><span class="line">Strong emphasis, aka bold, with <span class="strong">**asterisks**</span> or <span class="strong">__underscores__</span>.</span><br><span class="line"></span><br><span class="line">Combined emphasis with <span class="strong">**asterisks and <span class="emphasis">_underscores_</span>**</span>.</span><br><span class="line"></span><br><span class="line">Strikethrough uses two tildes. ~~Scratch this.~~</span><br></pre></td></tr></table></figure><p>Emphasis, aka italics, with <em>asterisks</em> or _underscores_.</p><p>Strong emphasis, aka bold, with <strong>asterisks</strong> or <strong>underscores</strong>.</p><p>Combined emphasis with <strong>asterisks and _underscores_</strong>.</p><p>Strikethrough uses two tildes. <del>Scratch this.</del></p><h1 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> First ordered list item</span><br><span class="line"><span class="bullet">2.</span> Another item</span><br><span class="line"><span class="bullet">  *</span> Unordered sub-list.</span><br><span class="line"><span class="bullet">1.</span> Actual numbers don&#x27;t matter, just that it&#x27;s a number</span><br><span class="line"><span class="bullet">  1.</span> Ordered sub-list</span><br><span class="line"><span class="bullet">4.</span> And another item.</span><br><span class="line"></span><br><span class="line">   You can have properly indented paragraphs within list items. Notice the blank line above, and the leading spaces (at least one, but we&#x27;ll use three here to also align the raw Markdown).</span><br><span class="line"></span><br><span class="line">   To have a line break without a paragraph, you will need to use two trailing spaces.  </span><br><span class="line">   Note that this line is separate, but within the same paragraph.  </span><br><span class="line">   (This is contrary to the typical GFM line break behaviour, where trailing spaces are not required.)</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span> Unordered list can use asterisks</span><br><span class="line"><span class="bullet">-</span> Or minuses</span><br><span class="line"><span class="bullet">+</span> Or pluses</span><br><span class="line"><span class="bullet">-</span> Paragraph In unordered list</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span> title-1</span><br><span class="line"><span class="bullet">    -</span> title-2</span><br><span class="line"><span class="bullet">    -</span> title-2</span><br></pre></td></tr></table></figure><ol><li>First ordered list item</li><li>Another item<ul><li>Unordered sub-list.</li></ul></li><li>Actual numbers don’t matter, just that it’s a number<ol><li>Ordered sub-list</li></ol></li><li><p>And another item.</p><p>You can have properly indented paragraphs within list items. Notice the blank line above, and the leading spaces (at least one, but we’ll use three here to also align the raw Markdown).</p><p>To have a line break without a paragraph, you will need to use two trailing spaces.<br>Note that this line is separate, but within the same paragraph.<br>(This is contrary to the typical GFM line break behaviour, where trailing spaces are not required.)</p></li></ol><ul><li>Unordered list can use asterisks</li></ul><ul><li>Or minuses</li></ul><ul><li>Or pluses</li></ul><ul><li>Paragraph In unordered list</li></ul><ul><li>title-1<ul><li>title-2</li><li>title-2</li></ul></li></ul><h1 id="Inline-HTML"><a href="#Inline-HTML" class="headerlink" title="Inline HTML"></a>Inline HTML</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span>To reboot your computer, press <span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>ctrl<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span>+<span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>alt<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span>+<span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>del<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span>.<span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>To reboot your computer, press <kbd>ctrl</kbd>+<kbd>alt</kbd>+<kbd>del</kbd>.</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span></span><br><span class="line"><span class="code">    &lt;dt&gt;Definition list&lt;/dt&gt;</span></span><br><span class="line"><span class="code">    &lt;dd&gt;Is something people use sometimes.&lt;/dd&gt;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    &lt;dt&gt;Markdown in HTML&lt;/dt&gt;</span></span><br><span class="line"><span class="code">    &lt;dd&gt;Does *not* work **very** well. Use HTML &lt;em&gt;tags&lt;/em&gt;.&lt;/dd&gt;</span></span><br><span class="line"><span class="code">&lt;/dl&gt;</span></span><br></pre></td></tr></table></figure><dl>    <dt>Definition list</dt>    <dd>Is something people use sometimes.</dd>    <dt>Markdown in HTML</dt>    <dd>Does *not* work **very** well. Use HTML <em>tags</em>.</dd></dl><h1 id="Links"><a href="#Links" class="headerlink" title="Links"></a>Links</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">I&#x27;m an inline-style link</span>](<span class="link">https://www.google.com</span>)</span><br><span class="line"></span><br><span class="line">[<span class="string">I&#x27;m an inline-style link with title</span>](<span class="link">https://www.google.com &quot;Google&#x27;s Homepage&quot;</span>)</span><br><span class="line"></span><br><span class="line">[<span class="string">I&#x27;m a reference-style link</span>][<span class="symbol">Arbitrary case-insensitive reference text</span>]</span><br><span class="line"></span><br><span class="line">[<span class="string">I&#x27;m a relative reference to a repository file</span>](<span class="link">../blob/master/LICENSE</span>)</span><br><span class="line"></span><br><span class="line">[<span class="string">You can use numbers for reference-style link definitions</span>][<span class="symbol">1</span>]</span><br><span class="line"></span><br><span class="line">Or leave it empty and use the [link text itself]</span><br><span class="line"></span><br><span class="line">Some text to show that the reference links can follow later.</span><br><span class="line"></span><br><span class="line">[<span class="symbol">arbitrary case-insensitive reference text</span>]: <span class="link">https://hexo.io</span></span><br><span class="line">[<span class="symbol">1</span>]: <span class="link">https://hexo.io/docs/</span></span><br><span class="line">[<span class="symbol">link text itself</span>]: <span class="link">https://hexo.io/api/</span></span><br></pre></td></tr></table></figure><p><a href="https://www.google.com">I’m an inline-style link</a></p><p><a href="https://www.google.com" title="Google&#39;s Homepage">I’m an inline-style link with title</a></p><p><a href="https://hexo.io">I’m a reference-style link</a></p><p><a href="../blob/master/LICENSE">I’m a relative reference to a repository file</a></p><p><a href="https://hexo.io/docs/">You can use numbers for reference-style link definitions</a></p><p>Or leave it empty and use the <a href="https://hexo.io/api/">link text itself</a></p><p>Some text to show that the reference links can follow later.</p><h1 id="Images"><a href="#Images" class="headerlink" title="Images"></a>Images</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hover to see the title text:</span><br><span class="line"></span><br><span class="line">Inline-style:</span><br><span class="line"></span><br><span class="line">![<span class="string">alt text</span>](<span class="link">https://hexo.io/icon/favicon-196x196.png &quot;Logo Title Text 1&quot;</span>)</span><br><span class="line"></span><br><span class="line">Reference-style:</span><br><span class="line">![<span class="string">alt text</span>][<span class="symbol">logo</span>]</span><br><span class="line"></span><br><span class="line">[<span class="symbol">logo</span>]: <span class="link">https://hexo.io/icon/favicon-196x196.png &quot;Logo Title Text 2&quot;</span></span><br></pre></td></tr></table></figure><p>hover to see the title text:</p><p>Inline-style:</p><p><img src="https://hexo.io/icon/favicon-196x196.png" alt="alt text" title="Logo Title Text 1"></p><p>Reference-style:<br><img src="https://hexo.io/icon/favicon-196x196.png" alt="alt text" title="Logo Title Text 2"></p><h1 id="Code-and-Syntax-Highlighting"><a href="#Code-and-Syntax-Highlighting" class="headerlink" title="Code and Syntax Highlighting"></a>Code and Syntax Highlighting</h1><p>Inline has it. <code>code back-ticks around</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;JavaScript syntax highlighting&quot;</span>;</span><br><span class="line">alert(s);</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;Python syntax highlighting&quot;</span></span><br><span class="line"><span class="built_in">print</span> s</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">No language indicated, so no syntax highlighting.</span><br><span class="line">But let&#x27;s throw in a &lt;b&gt;tag&lt;/b&gt;.</span><br></pre></td></tr></table></figure><h1 id="Tables"><a href="#Tables" class="headerlink" title="Tables"></a>Tables</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|                |ASCII                          |HTML                         |</span><br><span class="line">|----------------|-------------------------------|-----------------------------|</span><br><span class="line">|Single backticks|<span class="code">`&#x27;Isn&#x27;t this fun?&#x27;`</span>            |&#x27;Isn&#x27;t this fun?&#x27;            |</span><br><span class="line">|Quotes          |<span class="code">`&quot;Isn&#x27;t this fun?&quot;`</span>            |&quot;Isn&#x27;t this fun?&quot;            |</span><br><span class="line">|Dashes          |<span class="code">`-- is en-dash, --- is em-dash`</span>|-- is en-dash, --- is em-dash|</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th></th><th>ASCII</th><th>HTML</th></tr></thead><tbody><tr><td>Single backticks</td><td><code>&#39;Isn&#39;t this fun?&#39;</code></td><td>‘Isn’t this fun?’</td></tr><tr><td>Quotes</td><td><code>&quot;Isn&#39;t this fun?&quot;</code></td><td>“Isn’t this fun?”</td></tr><tr><td>Dashes</td><td><code>-- is en-dash, --- is em-dash</code></td><td>— is en-dash, —- is em-dash</td></tr></tbody></table></div><p>Colons can be used to align columns.<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| Tables        | Are           | Cool  |</span><br><span class="line">| ------------- |:-------------:| -----:|</span><br><span class="line">| col 3 is      | right-aligned |  |</span><br><span class="line">| col 2 is      | centered      |    |</span><br><span class="line">| zebra stripes | are neat      |   </span><br></pre></td></tr></table></figure><br>| Tables        | Are           | Cool  |<br>| ——————- |:——————-:| ——-:|<br>| col 3 is      | right-aligned |  |<br>| col 2 is      | centered      |    |<br>| zebra stripes | are neat      |</p><p>The outer pipes (|) are optional, and you don’t need to make the raw Markdown line up prettily. You can also use inline Markdown.</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Markdown | Less | Pretty</span><br><span class="line">--- | --- | ---</span><br><span class="line"><span class="emphasis">*Still*</span> | <span class="code">`renders`</span> | <span class="strong">**nicely**</span></span><br><span class="line">1 | 2 | 3</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>Markdown</th><th>Less</th><th>Pretty</th></tr></thead><tbody><tr><td><em>Still</em></td><td><code>renders</code></td><td><strong>nicely</strong></td></tr><tr><td>1</td><td>2</td><td>3</td></tr></tbody></table></div><h1 id="Blockquotes"><a href="#Blockquotes" class="headerlink" title="Blockquotes"></a>Blockquotes</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;You can find more information about <span class="strong">**LaTeX**</span> mathematical expressions [<span class="string">here</span>](<span class="link">https://math.meta.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference</span>).</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;equation&#125;\begin&#123;split&#125; a&amp;=b+c-d\\\\</span><br><span class="line">&amp;\quad +e-f\\\\</span><br><span class="line">&amp;=g+h\\\\</span><br><span class="line">&amp; =i </span><br><span class="line">\end&#123;split&#125;\end&#123;equation&#125;</span><br></pre></td></tr></table></figure><p>\begin{equation}\begin{split}<br>a&amp;=b+c-d\\\\<br>&amp;\quad +e-f\\\\<br>&amp;=g+h\\\\<br>&amp; =i<br>\end{split}\end{equation}</p><blockquote><p>You can find more information about <strong>LaTeX</strong> mathematical expressions <a href="https://math.meta.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference">here</a>.</p></blockquote><h1 id="Horizontal-Rule"><a href="#Horizontal-Rule" class="headerlink" title="Horizontal Rule"></a>Horizontal Rule</h1><p>Three or more …</p><h2 id><a href="#" class="headerlink" title></a><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"></span><br><span class="line">Hyphens</span><br><span class="line"></span><br><span class="line"><span class="strong">**<span class="emphasis">*</span></span></span><br><span class="line"><span class="emphasis"><span class="strong"></span></span></span><br><span class="line"><span class="emphasis"><span class="strong">Asterisks</span></span></span><br><span class="line"><span class="emphasis"><span class="strong"></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="strong">__<span class="emphasis">_</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="emphasis"><span class="strong"></span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="emphasis"><span class="strong">Underscores</span></span></span></span></span><br></pre></td></tr></table></figure></h2><p>Hyphens</p><hr><p>Asterisks</p><hr><p>Underscores</p><h1 id="New-Blockquotes"><a href="#New-Blockquotes" class="headerlink" title="New Blockquotes"></a>New Blockquotes</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">This is a regular paragraph.</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span></span><br><span class="line"><span class="code">    &lt;tr&gt;</span></span><br><span class="line"><span class="code">        &lt;td&gt;Foo&lt;/td&gt;</span></span><br><span class="line"><span class="code">    &lt;/tr&gt;</span></span><br><span class="line"><span class="code">&lt;/table&gt;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">This is another regular paragraph.</span><br></pre></td></tr></table></figure><p>This is a regular paragraph.</p><table>    <tr>        <td>Foo</td>    </tr></table><p>This is another regular paragraph.</p><h1 id="Youtube-Videos"><a href="#Youtube-Videos" class="headerlink" title="Youtube Videos"></a>Youtube Videos</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.youtube.com/watch?feature=player_embedded&amp;v=ARted4RniaU</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="xml">&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://img.youtube.com/vi/ARted4RniaU/0.jpg&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml"><span class="attr">alt</span>=<span class="string">&quot;IMAGE ALT TEXT HERE&quot;</span> <span class="attr">width</span>=<span class="string">&quot;240&quot;</span> <span class="attr">height</span>=<span class="string">&quot;180&quot;</span> <span class="attr">border</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">Pure markdown version:</span><br><span class="line"></span><br><span class="line">[<span class="string">![IMAGE ALT TEXT HERE</span>](<span class="link">https://img.youtube.com/vi/ARted4RniaU/0.jpg</span>)](<span class="link">https://www.youtube.com/watch?v=ARted4RniaU</span>)</span><br></pre></td></tr></table></figure><p><a href="https://www.youtube.com/watch?feature=player_embedded&v=ARted4RniaU" target="_blank"><img src="https://img.youtube.com/vi/ARted4RniaU/0.jpg" alt="IMAGE ALT TEXT HERE" width="240" height="180" border="10"></a></p><p>Pure markdown version:</p><p><a href="https://www.youtube.com/watch?v=ARted4RniaU"><img src="https://img.youtube.com/vi/ARted4RniaU/0.jpg" alt="IMAGE ALT TEXT HERE"></a></p><h1 id="表情符号"><a href="#表情符号" class="headerlink" title="表情符号"></a>表情符号</h1><p>&#x1F308;=<code>&amp;#x1F308</code><br>&#x1F353;=<code>&amp;#x1F353</code><br>&#x1F4DE;=<code>&amp;#x1F4DE;</code><br>&#x1F341;=<code>&amp;#x1F341;</code><br>&#x1F463;=<code>&amp;#x1F463;</code><br>&#x1F4E3;=<code>&amp;#x1F4E3;</code><br>&#x1F44D;=<code>&amp;#x1F44D;</code><br>&#x1F44C;=<code>&amp;#x1F44C;</code><br>&#x1F34E;=<code>&amp;#x1F34E;</code><br>&#x1F34F;=<code>&amp;#x1F34F;</code><br>&#x1F4C6;=<code>&amp;#x1F4C6;</code><br>&#x1F4C5;=<code>&amp;#x1F4C5;</code><br>&#x1F554;=<code>&amp;#x1F554;</code><br>&#x1F449;=<code>&amp;#x1F449;</code><br>&#x1F332;=<code>&amp;#x1F332;</code><br>&#x1F4CA;=<code>&amp;#x1F4CA;</code><br>&#x2753;=<code>&amp;#x2753;</code><br>&#x1F4C2;=<code>&amp;#x1F4C2;</code><br>&#x1F349;=<code>&amp;#x1F349;</code><br>&#x1F4E7;=<code>&amp;#x1F4E7;</code><br>&#x1F3A6;=<code>&amp;#x1F3A6;</code></p><h1 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h1><p>●</p><p>参考:<br><a href="https://hexo.io/docs/">1</a>.<a href="https://butterfly.js.org/posts/89757140/#Inline-HTML">use markdown in hexo</a><br>[2].<a href="https://butterfly.js.org/posts/4aa8abbe">个性设置</a><br>[3].<a href="https://tool.lu/tables/">table to markdown</a><br>[4].<a href="https://blog.csdn.net/Aoman_Hao/article/details/81381507?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1.no_search_link&amp;spm=1001.2101.3001.4242">Hexo博客里添加对mathjax的支持</a><br>[5].<a href="https://math.meta.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference">MathJax basic tutorial and quick reference</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo本身 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssh连接服务器</title>
      <link href="/2021/08/08/ssh%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2021/08/08/ssh%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h1><h2 id="1-1-查看是否安装openssh-server"><a href="#1-1-查看是否安装openssh-server" class="headerlink" title="1.1.查看是否安装openssh-server"></a>1.1.查看是否安装openssh-server</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls /etc/ssh/</span><br><span class="line">moduli      sshd_config         ssh_host_ecdsa_key.pub  ssh_host_ed25519_key.pub  ssh_host_rsa_key.pub</span><br><span class="line">ssh_config  ssh_host_ecdsa_key  ssh_host_ed25519_key    ssh_host_rsa_key          ssh_import_id</span><br></pre></td></tr></table></figure><p>查看是否有<em>sshd_config</em>，没有则按照如下安装<em>openssh-server</em><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure></p><h2 id="1-2-查看公钥记录文件路径"><a href="#1-2-查看公钥记录文件路径" class="headerlink" title="1.2.查看公钥记录文件路径"></a>1.2.查看公钥记录文件路径</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/ssh/sshd_config</span><br><span class="line">...</span><br><span class="line"><span class="comment">#AuthorizedKeysFile     .ssh/authorized_keys</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>| 公钥被存放在 <em>.ssh/authorized_keys</em></p><h2 id="1-3-在本地端给生成公钥"><a href="#1-3-在本地端给生成公钥" class="headerlink" title="1.3.在本地端给生成公钥"></a>1.3.在本地端给生成公钥</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\19841\Desktop&gt; ssh-keygen.exe</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (C:\Users\19841/.ssh/id_rsa):</span><br><span class="line">C:\Users\19841/.ssh/id_rsa already exists.</span><br><span class="line">Overwrite (y/n)? y</span><br><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved <span class="keyword">in</span> C:\Users\19841/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> C:\Users\19841/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:PxKM0uO4fPWTPbfVAuXu/kW3HMpAqhaSaDj51vqlnFs 19841@LAPTOP-MC6JUP1G</span><br><span class="line">The key<span class="string">&#x27;s randomart image is:</span></span><br><span class="line"><span class="string">+---[RSA 3072]----+</span></span><br><span class="line"><span class="string">|                 |</span></span><br><span class="line"><span class="string">|                 |</span></span><br><span class="line"><span class="string">|           .  .  |</span></span><br><span class="line"><span class="string">|  o ...o  o  o   |</span></span><br><span class="line"><span class="string">| + o.o+.S. .. ..o|</span></span><br><span class="line"><span class="string">|  + .+..+o  ooo.=|</span></span><br><span class="line"><span class="string">|   o...E..oo ooo+|</span></span><br><span class="line"><span class="string">|  ..o.B  .+.o..o.|</span></span><br><span class="line"><span class="string">|   .+B.    . ++o.|</span></span><br><span class="line"><span class="string">+----[SHA256]-----+</span></span><br><span class="line"><span class="string">PS C:\Users\19841&gt; cd .ssh</span></span><br><span class="line"><span class="string">PS C:\Users\19841\.ssh&gt; ls</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    目录: C:\Users\19841\.ssh</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Mode                 LastWriteTime         Length Name</span></span><br><span class="line"><span class="string">----                 -------------         ------ ----</span></span><br><span class="line"><span class="string">-a----          2021/8/8     16:57           2610 id_rsa</span></span><br><span class="line"><span class="string">-a----          2021/8/8     16:57            576 id_rsa.pub</span></span><br></pre></td></tr></table></figure><p>| 其中公钥被存放在<em>id_rsa.pub</em>中<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;your_email@example.com&quot;</span> <span class="comment"># 其它命令说明</span></span><br></pre></td></tr></table></figure></p><blockquote><p>代码参数含义：<br>-t 指定密钥类型，默认是 rsa ，可以省略。<br>-C 设置注释文字，比如邮箱。</p><h2 id="1-4-将公钥-id-rsa-pub-的内容存放在-ssh-authorized-key-中"><a href="#1-4-将公钥-id-rsa-pub-的内容存放在-ssh-authorized-key-中" class="headerlink" title="1.4.将公钥 id_rsa.pub 的内容存放在 .ssh/authorized_key 中"></a>1.4.将公钥 <em>id_rsa.pub</em> 的内容存放在 <em>.ssh/authorized_key</em> 中</h2></blockquote><h1 id="2-连接"><a href="#2-连接" class="headerlink" title="2.连接"></a>2.连接</h1><h2 id="2-1-使用ssh命令连接"><a href="#2-1-使用ssh命令连接" class="headerlink" title="2.1.使用ssh命令连接"></a>2.1.使用ssh命令连接</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh 用户名@主机IP</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux的基本使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
